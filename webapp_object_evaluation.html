<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aaadviser - <span data-i18n="pageTitle">Оценка объекта</span></title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="/telegram-check.js"></script>
    <script src="/i18n-manager.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 400px;
            margin: 0 auto;
            padding: 20px;
            background: white;
            min-height: 100vh;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
        }

        /* Header Styles */
        .page-title {
            font-size: 24px;
            font-weight: bold;
            color: #333;
            text-align: center;
            margin: 20px 0 10px 0;
        }

        .page-description {
            font-size: 14px;
            color: #666;
            text-align: center;
            margin-bottom: 25px;
            line-height: 1.4;
        }

        /* Form Styles */
        .location-form {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid #e0e0e0;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            font-size: 14px;
            font-weight: 600;
            color: #333;
            margin-bottom: 6px;
        }

        .form-group select {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            background: white;
            color: #333;
        }

        .form-group select:disabled {
            background: #f5f5f5;
            color: #999;
            cursor: not-allowed;
        }

        .confirm-button {
            width: 100%;
            padding: 12px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .confirm-button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .confirm-button:not(:disabled):hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        /* Listing Type Selection Styles */
        .listing-type-section {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            border: 1px solid #e0e0e0;
        }

        .listing-type-title {
            font-size: 14px;
            font-weight: 600;
            color: #333;
            margin-bottom: 12px;
            text-align: center;
        }

        .listing-type-select {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            background: white;
            color: #333;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .listing-type-select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.1);
        }
        
        .listing-type-select:hover {
            border-color: #667eea;
        }

        .listing-type-group {
            margin-bottom: 15px;
        }

        .listing-type-subtitle {
            font-size: 12px;
            font-weight: 600;
            color: #666;
            margin-bottom: 8px;
            padding-left: 4px;
        }

        /* Selected Location Styles */
        .selected-location {
            background: #e8f5e8;
            border: 1px solid #4caf50;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .location-title {
            font-size: 16px;
            font-weight: 600;
            color: #2e7d32;
            margin-bottom: 10px;
        }

        .location-details {
            font-size: 14px;
            color: #333;
            line-height: 1.4;
        }

        .selected-property-types {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #4caf50;
        }

        .property-types-title {
            font-size: 14px;
            font-weight: 600;
            color: #2e7d32;
            margin-bottom: 8px;
        }

        .property-types-details {
            font-size: 13px;
            color: #333;
            line-height: 1.4;
        }

        .property-type-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 0;
            border-bottom: 1px solid #e8f5e8;
        }

        .property-type-item:last-child {
            border-bottom: none;
        }

        .property-type-label {
            font-weight: 500;
            color: #2e7d32;
        }

        .property-type-value {
            color: #333;
            font-weight: 600;
        }

        .admin-ids {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #4caf50;
        }

        .admin-title {
            font-size: 14px;
            font-weight: 600;
            color: #2e7d32;
            margin-bottom: 5px;
        }

        .admin-details {
            font-size: 12px;
            color: #666;
            font-family: monospace;
        }
        
        /* Стили для отдельного блока с ID для админов */
        .admin-ids-block {
            background: #e8f5e8;
            border: 1px solid #4caf50;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }
        
        .admin-ids-title {
            font-size: 16px;
            font-weight: 600;
            color: #2e7d32;
            margin-bottom: 10px;
        }
        
        .admin-ids-details {
            font-size: 12px;
            color: #666;
            font-family: monospace;
            line-height: 1.6;
        }
        


        /* Key Metrics Styles */
        .key-metrics-section {
            margin-bottom: 20px;
        }

        .key-metrics-title {
            font-size: 18px;
            font-weight: 600;
            color: #333;
            text-align: center;
            margin-bottom: 15px;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .metric-card {
            background: #f8f9fa;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 12px;
            text-align: center;
        }

        .metric-card.yield-card {
            grid-column: 1 / -1;
            background: #f0f0f0;
        }

        .metric-label {
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
            line-height: 1.2;
        }

        .metric-value {
            font-size: 16px;
            font-weight: 600;
            color: #333;
        }

        .yield-label {
            font-size: 17px;
        }

        .yield-value {
            font-size: 17px;
        }





        /* Data Card Styles */
        .data-content {
            margin-bottom: 20px;
        }

        .data-section {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            margin-bottom: 20px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .data-section-title {
            font-size: 18px;
            font-weight: 600;
            color: #333;
            margin: 0 0 15px 0;
            padding-bottom: 10px;
            border-bottom: 2px solid #667eea;
        }

        .data-section-content {
            padding: 0;
        }
        
        .data-item {
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 6px;
            border-left: 4px solid #667eea;
        }
        
        .data-item-title {
            font-size: 16px;
            font-weight: 600;
            color: #333;
            margin: 0 0 12px 0;
        }
        
        .data-available {
            padding: 15px;
            background: #e8f5e8;
            border: 1px solid #4caf50;
            border-radius: 6px;
            color: #2e7d32;
            font-size: 14px;
            text-align: center;
            font-weight: 500;
        }
        
        .summary-table-title {
            font-size: 20px;
            font-weight: 700;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 20px;
            text-align: center;
            position: relative;
            padding-bottom: 12px;
        }
        
        .summary-table-title::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 3px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 2px;
        }
        
        .summary-table {
            margin-top: 0;
        }
        
        .summary-table-container {
            overflow-x: hidden;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .summary-table th {
            background: #28a745;
            color: white;
            padding: 8px 6px;
            text-align: center;
            font-weight: 600;
            line-height: 1.2;
            word-wrap: break-word;
        }
        
        .summary-table td {
            padding: 6px 4px;
            text-align: center;
            border-bottom: 1px solid #dee2e6;
            word-wrap: break-word;
        }
        
        .summary-table tr:nth-child(even) {
            background: #f8f9fa;
        }
        
        .summary-table tr:hover {
            background: #e9ecef;
        }
        
        .section-header {
            background: #f0f8ff !important;
            color: #495057;
            font-weight: 600;
            text-align: center;
            border: 1px solid #dee2e6;
            font-size: 14px;
        }
        
        .sale-header {
            background: #f0f8ff !important;
            color: #495057;
            border: 1px solid #dee2e6;
            font-weight: 600;
        }
        
        .rent-header {
            background: #f0f8ff !important;
            color: #495057;
            border: 1px solid #dee2e6;
            font-weight: 600;
        }
        
        .yield-header {
            background: #f0f8ff !important;
            color: #495057;
            font-weight: 600;
            font-size: 14px;
            border: 1px solid #dee2e6;
        }
        
        .yield-data {
            background: #f8f9fa !important;
            border: 1px solid #dee2e6;
        }
        
        .yield-label {
            font-weight: 600;
            color: #495057;
        }
        
        .yield-value {
            font-weight: 600;
            color: #495057;
        }
        
        /* Стили для таблицы показателей рынка */
        .market-indicators-table {
            margin-top: 20px;
        }
        
        .market-data-table {
            width: 100%;
            background: #f8f9fa;
            border-radius: 16px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            border: 1px solid rgba(0, 0, 0, 0.05);
            border-collapse: collapse;
        }
        
        .market-data-table thead {
            background: linear-gradient(90deg, #4CAF50, #45a049);
        }
        
        .category-header {
            padding: 20px 25px;
            color: white;
            font-size: 18px;
            font-weight: 700;
            text-align: center;
            border: none;
            width: 50%;
        }
        
        .data-cell {
            padding: 20px 25px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.08);
            vertical-align: top;
        }
        
        .market-data-table tbody tr:last-child .data-cell {
            border-bottom: none;
        }
        
        .cell-label {
            color: #333333;
            font-weight: 500;
            font-size: 15px;
            margin-bottom: 8px;
        }
        
        .cell-value {
            color: #4CAF50;
            font-weight: 600;
            font-size: 16px;
        }
        
        /* Мобильные устройства для таблицы показателей рынка */
        @media (max-width: 768px) {
            .market-indicators-table {
                margin-top: 16px;
            }
            
            .market-data-table {
                border-radius: 12px;
            }
            
            .category-header {
                padding: 16px 20px;
                font-size: 16px;
            }
            
            .data-cell {
                padding: 16px 20px;
            }
            
            .cell-label {
                font-size: 14px;
                margin-bottom: 6px;
            }
            
            .cell-value {
                font-size: 14px;
            }
            
            /* Мобильные стили для блока "Анализ рынка" */
            .market-analysis-text-block {
                margin: 24px 0;
                padding: 22px;
                border-radius: 14px;
            }
            
            .market-analysis-text-title {
                font-size: 17px;
                margin-bottom: 18px;
            }
            
            .market-analysis-text-content {
                font-size: 13px;
            }
            
            /* Мобильные стили для блока с ID для админов */
            .admin-ids-block {
                padding: 14px;
                border-radius: 7px;
                margin-bottom: 18px;
            }
            
            .admin-ids-title {
                font-size: 15px;
                margin-bottom: 9px;
            }
            
            .admin-ids-details {
                font-size: 11px;
            }
            
            /* Мобильные стили для блока "Вывод по объекту" */
            .object-summary-section {
                margin: 24px 0;
                padding: 22px;
                border-radius: 14px;
            }
            
            .object-summary-title {
                font-size: 17px;
                margin-bottom: 18px;
            }
            
            .object-summary-content {
                font-size: 13px;
            }
        }
        
        @media (max-width: 480px) {
            .market-indicators-table {
                margin-top: 14px;
            }
            
            .market-data-table {
                border-radius: 10px;
            }
            
            .category-header {
                padding: 14px 16px;
                font-size: 14px;
            }
            
            .data-cell {
                padding: 14px 16px;
            }
            
            .cell-label {
                font-size: 12px;
                margin-bottom: 4px;
            }
            
            .cell-value {
                font-size: 12px;
            }
            
            /* Price Forecast Extra Small Screens */
            .price-forecast-market-table {
                border-radius: 10px;
            }
            
            .forecast-category-header {
                padding: 14px 16px;
                font-size: 14px;
            }
            
            .forecast-data-cell {
                padding: 14px 16px;
            }
            
            .forecast-cell-label {
                font-size: 12px;
                margin-bottom: 4px;
            }
            
            .forecast-cell-value {
                font-size: 12px;
            }
            
            .forecast-cell-growth {
                font-size: 10px;
                margin-top: 2px;
                padding: 1px 3px;
            }
            
            .forecast-metrics-compact-section {
                margin-top: 12px;
                padding: 10px 12px;
            }
            
            .forecast-metrics-compact-title {
                font-size: 12px;
                margin-bottom: 10px;
            }
            
            .forecast-metrics-compact-grid {
                gap: 8px;
                grid-template-columns: 1fr; /* На очень маленьких экранах в одну колонку */
            }
            
            .metric-compact-label,
            .metric-compact-value {
                font-size: 11px;
            }
            
            .price-forecast-date {
                font-size: 11px;
                margin-top: 10px;
            }
            
            .price-forecast-currency-info {
                font-size: 9px;
            }
            
            .price-forecast-disclaimer {
                font-size: 9px;
                padding: 6px;
                margin-top: 6px;
            }
            
            /* Мобильные стили для блока "Анализ рынка" */
            .market-analysis-text-block {
                margin: 20px 0;
                padding: 20px;
                border-radius: 12px;
            }
            
            .market-analysis-text-title {
                font-size: 16px;
                margin-bottom: 16px;
            }
            
            .market-analysis-text-content {
                font-size: 13px;
            }
            
            /* Мобильные стили для блока с ID для админов */
            .admin-ids-block {
                padding: 10px;
                border-radius: 5px;
                margin-bottom: 14px;
            }
            
            .admin-ids-title {
                font-size: 13px;
                margin-bottom: 6px;
            }
            
            .admin-ids-details {
                font-size: 10px;
            }
            
            /* Мобильные стили для блока "Вывод по объекту" */
            .object-summary-section {
                margin: 20px 0;
                padding: 20px;
                border-radius: 12px;
            }
            
            .object-summary-title {
                font-size: 16px;
                margin-bottom: 16px;
            }
            
            .object-summary-content {
                font-size: 13px;
            }
            
            .comparison-label,
            .comparison-value {
                font-size: 12px;
                padding: 2px 0;
            }
            
            .object-analysis-text {
                font-size: 12px;
                padding: 8px;
                margin-top: 10px;
            }
        }
        
        /* Пустое место между блоками */
        .block-spacing {
            height: 40px;
            margin: 0;
            padding: 0;
        }
        
        /* Стили для блока "Вывод по объекту" в стиле "Вывод по тренду" */
        .object-summary-section {
            margin: 30px 0;
            padding: 25px;
            background: white;
            border-radius: 16px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(0, 0, 0, 0.05);
        }
        
        .object-summary-title {
            font-size: 18px;
            font-weight: 700;
            color: #333333;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .object-summary-content {
            line-height: 1.6;
            color: #333333;
            font-size: 14px;
        }
        
        .object-summary-content p {
            margin: 0 0 15px 0;
            padding: 0;
        }
        
        .object-summary-content p:last-child {
            margin-bottom: 0;
        }
        
        .object-summary-content strong {
            color: #1a202c;
            font-weight: 700;
        }
        
        /* Стили для компактной таблицы сравнения объекта */
        .object-comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 0;
        }
        
        .comparison-label {
            padding: 4px 0;
            font-weight: 500;
            color: #333333;
            font-size: 14px;
            width: 60%;
        }
        
        .comparison-value {
            padding: 4px 0;
            text-align: right;
            font-size: 14px;
            color: #333333;
        }
        
        .comparison-higher {
            color: #28a745 !important;
            font-weight: 600;
        }
        
        .comparison-lower {
            color: #dc3545 !important;
            font-weight: 600;
        }
        
        /* Новые классы для цены (дешевле = хорошо) */
        .comparison-cheaper {
            color: #28a745 !important;
            font-weight: 600;
        }
        
        .comparison-expensive {
            color: #dc3545 !important;
            font-weight: 600;
        }
        
        /* Новые классы для площади (больше = хорошо) */
        .comparison-larger {
            color: #28a745 !important;
            font-weight: 600;
        }
        
        .comparison-smaller {
            color: #dc3545 !important;
            font-weight: 600;
        }
        
        .rental-estimate .comparison-label {
            border-top: 1px solid #dee2e6;
            padding-top: 12px;
            font-weight: 600;
        }
        
        .rental-estimate .comparison-value {
            border-top: 1px solid #dee2e6;
            padding-top: 12px;
            color: #4CAF50 !important;
        }
        
        /* Стили для текстового анализа */
        .object-analysis-text {
            margin-top: 15px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #007bff;
            color: #495057;
            font-size: 14px;
            line-height: 1.5;
            font-style: italic;
        }
        
        /* Стили для блока "Анализ рынка" в стиле "Вывод по тренду" */
        .market-analysis-text-block {
            margin: 30px 0;
            padding: 25px;
            background: white;
            border-radius: 16px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(0, 0, 0, 0.05);
        }
        
        .market-analysis-text-title {
            font-size: 18px;
            font-weight: 700;
            color: #333333;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .market-analysis-text-content {
            line-height: 1.6;
            color: #333333;
            font-size: 14px;
        }
        
        .market-analysis-text-content p {
            margin: 0 0 15px 0;
            padding: 0;
        }
        
        .market-analysis-text-content p:last-child {
            margin-bottom: 0;
        }
        
        .market-analysis-text-content strong {
            color: #1a202c;
            font-weight: 700;
        }
        
        /* Стили для объединенного анализа рынка в стиле "Вывод прогноза" */
        .market-analysis-unified {
            margin: 30px 0;
            padding: 25px;
            background: #f8f9fa;
            border-radius: 16px;
            border: 1px solid rgba(0, 0, 0, 0.05);
        }
        
        .analysis-title {
            font-size: 18px;
            font-weight: 700;
            color: #333333;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .analysis-content {
            line-height: 1.6;
        }
        
        .analysis-section {
            margin: 0 0 20px 0;
            padding: 0;
            color: #333333;
            font-size: 14px;
        }
        
        .analysis-section:last-child {
            margin-bottom: 0;
        }
        
        .analysis-section strong {
            color: #1a202c;
            font-weight: 700;
        }
        
        /* Разделитель между секциями анализа */
        .section-spacing {
            height: 20px;
            margin: 0;
            padding: 0;
        }
        
        /* Стили для аккордеона администратора */
        .admin-data-accordion {
            margin: 30px 0;
            padding: 25px;
            background: #f8f9fa;
            border-radius: 16px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(0, 0, 0, 0.05);
        }
        
        .accordion-title {
            font-size: 18px;
            font-weight: 700;
            color: #2d3748;
            margin-bottom: 20px;
            text-align: center;
            position: relative;
            padding-bottom: 12px;
        }
        
        .accordion-title::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 50px;
            height: 2px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 1px;
        }
        
        .accordion-container {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }
        
        .accordion-item {
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
            border: 1px solid rgba(0, 0, 0, 0.08);
            overflow: hidden;
        }
        
        .accordion-header {
            padding: 18px 22px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
            transition: all 0.2s ease;
        }
        
        .accordion-header:hover {
            background: linear-gradient(135deg, #5a67d8 0%, #6b46c1 100%);
        }
        
        .accordion-header.active {
            background: linear-gradient(135deg, #5a67d8 0%, #6b46c1 100%);
        }
        
        .accordion-title {
            font-size: 16px;
            font-weight: 600;
            margin: 0;
            padding: 0;
        }
        
        .accordion-icon {
            font-size: 14px;
            transition: transform 0.2s ease;
        }
        
        .accordion-content {
            display: none;
            padding: 0;
        }
        
        .accordion-table-container {
            padding: 20px;
            overflow-x: auto;
        }
        
        .accordion-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }
        
        .accordion-table th,
        .accordion-table td {
            padding: 12px 16px;
            text-align: left;
            border-bottom: 1px solid rgba(0, 0, 0, 0.08);
        }
        
        .accordion-table th {
            background: #f8f9fa;
            font-weight: 600;
            color: #2d3748;
        }
        
        .accordion-table td.field-name {
            font-weight: 500;
            color: #4a5568;
        }
        
        .accordion-table td.field-value {
            color: #2d3748;
        }
        
        /* Мобильные устройства для объединенного анализа рынка */
        @media (max-width: 768px) {
            .market-analysis-unified {
                margin: 25px 0;
                padding: 20px;
                border-radius: 12px;
            }
            
            .analysis-title {
                font-size: 16px;
                margin-bottom: 16px;
            }
            
            .analysis-section {
                margin-bottom: 14px;
                font-size: 13px;
            }
            
            .block-spacing {
                height: 30px;
            }
            
            .section-spacing {
                height: 16px;
            }
        }
        
        @media (max-width: 480px) {
            .market-analysis-unified {
                margin: 20px 0;
                padding: 16px;
                border-radius: 10px;
            }
            
            .analysis-title {
                font-size: 15px;
                margin-bottom: 14px;
            }
            
            .analysis-section {
                margin-bottom: 12px;
                font-size: 12px;
            }
            
            .block-spacing {
                height: 25px;
            }
            
            .section-spacing {
                height: 14px;
            }
        }
        
        /* Мобильные устройства для аккордеона */
        @media (max-width: 768px) {
            .admin-data-accordion {
                margin: 25px 0;
                padding: 20px;
                border-radius: 12px;
            }
            
            .accordion-title {
                font-size: 16px;
                margin-bottom: 16px;
            }
            
            .accordion-header {
                padding: 16px 20px;
            }
            
            .accordion-table-container {
                padding: 16px;
            }
            
            .accordion-table th,
            .accordion-table td {
                padding: 10px 12px;
                font-size: 13px;
            }
        }
        
        @media (max-width: 480px) {
            .admin-data-accordion {
                margin: 20px 0;
                padding: 16px;
                border-radius: 10px;
            }
            
            .accordion-title {
                font-size: 15px;
                margin-bottom: 14px;
            }
            
            .accordion-header {
                padding: 14px 18px;
            }
            
            .accordion-table-container {
                padding: 14px;
            }
            
            .accordion-table th,
            .accordion-table td {
                padding: 8px 10px;
                font-size: 12px;
            }
        }
        
        /* Мобильные устройства для таблицы показателей рынка */
        @media (max-width: 768px) {
            .summary-table-title {
                font-size: 15px;
                margin-bottom: 12px;
            }
            
            .summary-table {
                font-size: 10px;
            }
            
            .summary-table th,
            .summary-table td {
                padding: 4px 2px;
            }
        }
        
        /* Detailed Data Tables Styles */
        .detailed-data-section {
            margin-top: 25px;
            margin-bottom: 20px;
        }
        
        .detailed-data-title {
            font-size: 16px;
            font-weight: 600;
            color: #495057;
            margin-bottom: 15px;
            text-align: center;
            padding-bottom: 8px;
            border-bottom: 2px solid #667eea;
        }
        
        .detailed-data-container {
            overflow-x: auto;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            background: white;
        }
        
        .detailed-data-table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            font-size: 12px;
            min-width: 600px;
        }
        
        .detailed-data-table th {
            background: #28a745;
            color: white;
            padding: 10px 8px;
            text-align: center;
            font-weight: 600;
            line-height: 1.2;
            word-wrap: break-word;
            border: 1px solid #dee2e6;
        }
        
        .detailed-data-table td {
            padding: 8px 6px;
            text-align: center;
            border: 1px solid #dee2e6;
            word-wrap: break-word;
            vertical-align: middle;
        }
        
        .detailed-data-table .field-name {
            background: #f8f9fa;
            font-weight: 600;
            color: #495057;
            text-align: left;
            padding-left: 12px;
            min-width: 150px;
        }
        
        .detailed-data-table .field-value {
            background: white;
            color: #333;
        }
        
        .detailed-data-table tr:nth-child(even) .field-value {
            background: #f8f9fa;
        }
        
        .detailed-data-table tr:hover .field-value {
            background: #e9ecef;
        }
        
        /* Mobile responsive for detailed data tables */
        @media (max-width: 768px) {
            .detailed-data-section {
                margin-top: 20px;
                margin-bottom: 15px;
            }
            
            .detailed-data-title {
                font-size: 15px;
                margin-bottom: 12px;
            }
            
            .detailed-data-table {
                font-size: 11px;
                min-width: 500px;
            }
            
            .detailed-data-table th,
            .detailed-data-table td {
                padding: 6px 4px;
            }
            
            .detailed-data-table .field-name {
                min-width: 120px;
                padding-left: 8px;
            }
        }
        
        @media (max-width: 480px) {
            .detailed-data-table {
                font-size: 10px;
                min-width: 400px;
            }
            
            .detailed-data-table th,
            .detailed-data-table td {
                padding: 4px 2px;
            }
            
            .detailed-data-table .field-name {
                min-width: 100px;
                padding-left: 6px;
            }
        }
        
        /* Consolidated Assessment Styles */
        .consolidated-assessment-section {
            margin-top: 25px;
            margin-bottom: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            border: 1px solid #e9ecef;
            overflow: hidden;
        }
        
        .consolidated-assessment-title {
            font-size: 18px;
            font-weight: 600;
            color: #495057;
            margin: 0;
            padding: 20px 20px 15px 20px;
            text-align: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .consolidated-assessment-content {
            padding: 20px;
        }
        
        .assessment-category {
            margin-bottom: 25px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }
        
        .assessment-category:last-child {
            margin-bottom: 0;
        }
        
        .assessment-category-title {
            font-size: 16px;
            font-weight: 600;
            color: #495057;
            margin: 0 0 15px 0;
            padding-bottom: 8px;
            border-bottom: 1px solid #dee2e6;
        }
        
        .assessment-items {
            margin-bottom: 15px;
        }
        
        .assessment-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #e9ecef;
        }
        
        .assessment-item:last-child {
            border-bottom: none;
        }
        
        .assessment-label {
            font-weight: 500;
            color: #495057;
            font-size: 14px;
        }
        
        .assessment-value {
            font-weight: 600;
            color: #28a745;
            font-size: 14px;
        }
        
        .assessment-consolidated {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            background: #e8f5e8;
            border-radius: 6px;
            border: 1px solid #4caf50;
        }
        
        .assessment-consolidated-label {
            font-weight: 600;
            color: #2e7d32;
            font-size: 14px;
        }
        
        .assessment-consolidated-value {
            font-weight: 700;
            color: #2e7d32;
            font-size: 16px;
        }
        
        /* Mobile responsive for consolidated assessment */
        @media (max-width: 768px) {
            .consolidated-assessment-section {
                margin-top: 20px;
                margin-bottom: 15px;
            }
            
            .consolidated-assessment-title {
                font-size: 16px;
                padding: 15px 15px 12px 15px;
            }
            
            .consolidated-assessment-content {
                padding: 15px;
            }
            
            .assessment-category {
                padding: 12px;
                margin-bottom: 20px;
            }
            
            .assessment-category-title {
                font-size: 15px;
                margin-bottom: 12px;
            }
            
            .assessment-item {
                padding: 6px 0;
            }
            
            .assessment-label,
            .assessment-value {
                font-size: 13px;
            }
            
            .assessment-consolidated {
                padding: 10px 12px;
            }
            
            .assessment-consolidated-label,
            .assessment-consolidated-value {
                font-size: 13px;
            }
        }
        
        @media (max-width: 480px) {
            .consolidated-assessment-title {
                font-size: 15px;
                padding: 12px 12px 10px 12px;
            }
            
            .consolidated-assessment-content {
                padding: 12px;
            }
            
            .assessment-category {
                padding: 10px;
                margin-bottom: 15px;
            }
            
            .assessment-category-title {
                font-size: 14px;
                margin-bottom: 10px;
            }
            
            .assessment-item {
                padding: 5px 0;
            }
            
            .assessment-label,
            .assessment-value {
                font-size: 12px;
            }
            
            .assessment-consolidated {
                padding: 8px 10px;
            }
            
            .assessment-consolidated-label,
            .assessment-consolidated-value {
                font-size: 12px;
            }
        }
        
        /* Market Comparison Block Styles */
        .market-comparison-block {
            margin-top: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            border: 1px solid #e9ecef;
            overflow: hidden;
        }
        
        .market-comparison-content {
            padding: 20px;
            text-align: center;
            position: relative;
        }
        
        .market-comparison-content::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 4px;
            background: #28a745;
        }
        
        .market-comparison-title {
            font-size: 16px;
            font-weight: 600;
            color: #495057;
            margin-bottom: 15px;
        }
        
        .market-comparison-value {
            font-size: 24px;
            font-weight: bold;
            color: #28a745;
            margin-bottom: 15px;
        }
        
        .market-comparison-details {
            margin-bottom: 15px;
        }
        
        .market-comparison-price,
        .market-comparison-area {
            font-size: 14px;
            color: #666;
            margin-bottom: 5px;
        }
        
        .market-comparison-analysis {
            text-align: left;
        }
        
        .market-comparison-analysis p {
            font-size: 14px;
            line-height: 1.6;
            color: #333;
            margin-bottom: 8px;
        }
        
        .market-comparison-analysis p:last-child {
            margin-bottom: 0;
        }
        
        .market-comparison-analysis strong {
            color: #495057;
            font-weight: 600;
        }
        
        /* Мобильные устройства для блока сравнения с рынком */
        @media (max-width: 768px) {
            .market-comparison-block {
                margin-top: 15px;
            }
            
            .market-comparison-content {
                padding: 15px;
            }
            
            .market-comparison-title {
                font-size: 15px;
                margin-bottom: 12px;
            }
            
            .market-comparison-value {
                font-size: 20px;
                margin-bottom: 12px;
            }
            
            .market-comparison-price,
            .market-comparison-area {
                font-size: 13px;
            }
            
            .market-comparison-analysis p {
                font-size: 13px;
                line-height: 1.5;
            }
        }
        
        /* Analytical Summary Styles */
        .analytical-summary {
            margin-top: 25px;
            padding: 20px;
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
        }
        
        .summary-title {
            font-size: 18px;
            font-weight: 700;
            color: #333;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .analytical-summary p {
            font-size: 14px;
            line-height: 1.6;
            color: #495057;
            margin-bottom: 12px;
        }
        
        .analytical-summary strong {
            color: #333;
            font-weight: 600;
        }
        
        /* Property Trends Styles */
        .trends-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .trend-card {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            transition: all 0.3s ease;
        }
        
        .trend-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        
        .trend-title {
            font-size: 14px;
            font-weight: 600;
            color: #495057;
            margin-bottom: 8px;
        }
        
        .trend-value {
            font-size: 18px;
            font-weight: 700;
            color: #28a745;
            margin-bottom: 5px;
        }
        
        .trend-period {
            font-size: 12px;
            color: #6c757d;
            font-style: italic;
        }
        
        .trend-details {
            margin-top: 8px;
        }
        
        .trend-change {
            font-size: 11px;
            color: #495057;
            margin-bottom: 4px;
            line-height: 1.3;
            font-weight: bold;
        }
        
        /* .trend-date removed - now part of .trend-change */
        
        .trend-card-price_trend {
            border-left: 4px solid #28a745;
        }
        
        .trend-card-yield_trend {
            border-left: 4px solid #ffc107;
        }
        
        .trend-card-count_trend {
            border-left: 4px solid #17a2b8;
        }
        
        /* Trends Table Styles */
        .trends-table-section {
            margin-top: 25px;
        }
        
        .trends-table-title {
            font-size: 16px;
            font-weight: 600;
            color: #495057;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .trends-table-container {
            overflow-x: hidden;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .trends-table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            font-size: 11px;
            table-layout: fixed;
        }
        
        .trends-table th {
            background: #28a745;
            color: white;
            padding: 8px 6px;
            text-align: center;
            font-weight: 600;
            line-height: 1.2;
            word-wrap: break-word;
        }
        
        .trends-table td {
            padding: 6px 4px;
            text-align: center;
            border-bottom: 1px solid #dee2e6;
            word-wrap: break-word;
        }
        
        .trends-table tr:nth-child(even) {
            background: #f8f9fa;
        }
        
        .trends-table tr:hover {
            background: #e9ecef;
        }
        
        /* Специальные стили для ширины столбцов трендов */
        .trends-table th:nth-child(1) { width: 15%; } /* Дата */
        .trends-table th:nth-child(2) { width: 18%; } /* Продажа */
        .trends-table th:nth-child(3) { width: 18%; } /* Изм-ие цены продажи */
        .trends-table th:nth-child(4) { width: 18%; } /* Аренда */
        .trends-table th:nth-child(5) { width: 18%; } /* Изм-ие цены аренды */
        .trends-table th:nth-child(6) { width: 13%; } /* Доходность */
        
        /* Стили для информационной строки о фильтрации */
        .trends-table .filter-info td {
            border: none;
            font-style: italic;
        }
        
        /* Стили для графика трендов */
        .trends-chart-section {
            margin-top: 20px;
            margin-bottom: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            padding: 15px;
        }
        
        .trends-chart-title {
            font-size: 14px;
            font-weight: 600;
            color: #495057;
            margin-bottom: 12px;
            text-align: center;
        }
        
        .chart-controls {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-bottom: 15px;
        }
        
        .chart-button {
            padding: 6px 12px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            background: white;
            color: #495057;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 11px;
            font-weight: 500;
        }
        
        .chart-button:hover {
            border-color: #667eea;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.2);
        }
        
        .chart-button.active {
            border-color: #667eea;
            background: #667eea;
            color: white;
        }
        
        .chart-container {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 180px;
        }
        
        #trendsChart {
            max-width: 100%;
            height: auto;
        }
        
        .chart-info {
            margin-top: 10px;
            text-align: center;
        }
        
        .chart-info small {
            color: #6c757d;
            font-style: italic;
            font-size: 11px;
        }
        
        /* Стили для графика прогноза */
        .forecast-chart-section {
            margin-top: 20px;
            margin-bottom: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            padding: 15px;
        }
        
        .forecast-chart-title {
            font-size: 14px;
            font-weight: 600;
            color: #495057;
            margin-bottom: 12px;
            text-align: center;
        }
        
        /* Стили для выделения текущего месяца */
        .trends-table .current-month-row {
            background-color: #e8f4fd !important;
            font-weight: 500;
        }
        
        .trends-table .current-month-row td {
            border-top: 2px solid #007bff;
            border-bottom: 2px solid #007bff;
        }
        
        /* Стили для строк прогноза в таблице трендов */
        .trends-table .forecast-row {
            background-color: #f0f8ff;
        }
        
        /* Стили для исторических строк в таблице трендов */
        .trends-table .historical-row {
            background-color: transparent;
        }
        
        .trends-table .historical-row td {
            color: #333;
        }
        
        /* Мобильные устройства */
        @media (max-width: 768px) {
            .trends-table {
                font-size: 10px;
            }
            
            .trends-table th,
            .trends-table td {
                padding: 4px 2px;
            }
            
            .trends-table th:nth-child(1) { width: 18%; }
            .trends-table th:nth-child(2) { width: 17%; }
            .trends-table th:nth-child(3) { width: 17%; }
            .trends-table th:nth-child(4) { width: 17%; }
            .trends-table th:nth-child(5) { width: 17%; }
            .trends-table th:nth-child(6) { width: 14%; }
                }
        
        /* Trends Analysis Styles */
        .trends-analysis-section {
            margin-top: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            border: 1px solid #e9ecef;
        }
        
        /* Forecast Table Styles */
        .forecast-table-section {
            margin-top: 20px;
        }
        
        .forecast-table-title {
            font-size: 16px;
            font-weight: 600;
            color: #495057;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .forecast-table-container {
            overflow-x: hidden;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .forecast-table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            font-size: 11px;
            table-layout: fixed;
        }
        
        .forecast-table th {
            background: #28a745;
            color: white;
            padding: 8px 6px;
            text-align: center;
            font-weight: 600;
            line-height: 1.2;
            word-wrap: break-word;
        }
        
        .forecast-table td {
            padding: 6px 4px;
            text-align: center;
            border-bottom: 1px solid #dee2e6;
            word-wrap: break-word;
        }
        
        .forecast-table tr:nth-child(even) {
            background: #f8f9fa;
        }
        
        .forecast-table tr:hover {
            background: #e9ecef;
        }
        
        /* Специальные стили для ширины столбцов прогноза */
        .forecast-table th:nth-child(1) { width: 20%; } /* Дата */
        .forecast-table th:nth-child(2) { width: 30%; } /* Прогноз продажи */
        .forecast-table th:nth-child(3) { width: 30%; } /* Прогноз аренды */
        .forecast-table th:nth-child(4) { width: 20%; } /* Прогноз доходности */
        
        /* Стили для информационной строки о прогнозе */
        .forecast-table .forecast-info td {
            border: none;
            font-style: italic;
        }
        
        /* Стили для выделения текущего месяца в прогнозе */
        .forecast-table .current-month-row {
            background-color: #e8f4fd !important;
            font-weight: 500;
        }
        
        .forecast-table .current-month-row td {
            border-top: 2px solid #007bff;
            border-bottom: 2px solid #007bff;
        }
        
        /* Стили для строк прогноза */
        .forecast-table .forecast-row {
            background-color: #f0f8ff;
        }
        
        /* Мобильные устройства для таблицы прогноза */
        @media (max-width: 768px) {
            .forecast-table {
                font-size: 10px;
            }
            
            .forecast-table th,
            .forecast-table td {
                padding: 4px 2px;
            }
            
            .forecast-table th:nth-child(1) { width: 22%; }
            .forecast-table th:nth-child(2) { width: 28%; }
            .forecast-table th:nth-child(3) { width: 28%; }
            .forecast-table th:nth-child(4) { width: 22%; }
        }
        
        .trends-analysis-title {
            font-size: 16px;
            font-weight: 600;
            color: #495057;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .trends-analysis-content {
            font-size: 14px;
            line-height: 1.6;
            color: #333;
            text-align: justify;
        }
        
        /* Мобильные устройства для блока анализа */
        @media (max-width: 768px) {
            .trends-analysis-section {
                padding: 15px;
                margin-top: 15px;
            }
            
            .trends-analysis-title {
                font-size: 15px;
                margin-bottom: 12px;
            }
            
            .trends-analysis-content {
                font-size: 13px;
                line-height: 1.5;
            }
        }
        
        /* Forecast Analysis Styles */
        .forecast-analysis-section {
            margin-top: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            border: 1px solid #e9ecef;
        }
        
        .forecast-analysis-title {
            font-size: 16px;
            font-weight: 600;
            color: #495057;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .forecast-analysis-content {
            font-size: 14px;
            line-height: 1.6;
            color: #333;
            text-align: justify;
        }
        
        .forecast-analysis-content p {
            margin-bottom: 12px;
        }
        
        .forecast-analysis-content p:last-child {
            margin-bottom: 0;
        }
        
        /* Мобильные устройства для блока анализа прогноза */
        @media (max-width: 768px) {
            .forecast-analysis-section {
                padding: 15px;
                margin-top: 15px;
            }
            
            .forecast-analysis-title {
                font-size: 15px;
                margin-bottom: 12px;
            }
            
            .forecast-analysis-content {
                font-size: 13px;
                line-height: 1.5;
            }
        }
        
        /* Price Forecast Block Styles - в стиле "Тренд цен" */
        .price-forecast-block {
            margin-top: 20px;
            background: #f8f9fa;
            border-radius: 16px;
            border: 1px solid rgba(0, 0, 0, 0.05);
            overflow: hidden;
            position: relative;
        }
        
        .price-forecast-content {
            padding: 25px 30px;
            text-align: center;
            position: relative;
        }
        
        .price-forecast-content::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 6px;
            background: #28a745;
        }
        
        .price-forecast-title {
            font-size: 18px;
            font-weight: 700;
            color: #333333;
            margin-bottom: 20px;
        }
        
        .price-forecast-sale-section,
        .price-forecast-rent-section {
            margin-bottom: 16px;
        }
        
        .price-forecast-sale-label,
        .price-forecast-rent-label {
            font-size: 15px;
            color: #333333;
            font-weight: 500;
            margin-bottom: 8px;
        }
        
        .price-forecast-sale-value,
        .price-forecast-rent-value {
            font-size: 20px;
            font-weight: 700;
            color: #28a745;
            margin-bottom: 8px;
        }
        
        .price-forecast-date {
            font-size: 14px;
            color: #666666;
            margin-bottom: 8px;
            font-weight: 600;
        }
        
        .price-forecast-currency-info {
            font-size: 12px;
            color: #999999;
            font-style: italic;
        }
        
        .price-forecast-disclaimer {
            font-size: 11px;
            color: #cccccc;
            font-style: italic;
            margin-top: 8px;
            line-height: 1.3;
        }
        
        /* Enhanced Price Forecast Block Styles */
        .price-forecast-enhanced-block {
            margin-top: 20px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 16px;
            border: 1px solid rgba(0, 0, 0, 0.05);
            overflow: hidden;
            position: relative;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
        
        .price-forecast-enhanced-content {
            padding: 25px 30px;
            position: relative;
        }
        
        .price-forecast-enhanced-content::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 6px;
            background: linear-gradient(45deg, #28a745, #20c997);
        }
        
        .price-forecast-enhanced-title {
            font-size: 18px;
            font-weight: 700;
            color: #333333;
            margin-bottom: 25px;
            text-align: center;
        }
        
        .price-forecast-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 25px;
        }
        
        .price-forecast-column {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            position: relative;
        }
        
        .price-forecast-column.current {
            border-left: 4px solid #6c757d;
        }
        
        .price-forecast-column.future {
            border-left: 4px solid #28a745;
        }
        
        .price-column-title {
            font-size: 14px;
            font-weight: 600;
            color: #495057;
            margin-bottom: 15px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .price-forecast-value-section {
            margin-bottom: 15px;
        }
        
        .price-forecast-value-section:last-child {
            margin-bottom: 0;
        }
        
        .price-forecast-label {
            font-size: 12px;
            color: #6c757d;
            margin-bottom: 5px;
            font-weight: 500;
        }
        
        .price-forecast-value {
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 5px;
        }
        
        .price-forecast-value.current {
            color: #495057;
        }
        
        .price-forecast-value.future {
            color: #28a745;
        }
        
        .price-growth {
            font-size: 12px;
            font-weight: 600;
            padding: 2px 8px;
            border-radius: 12px;
            display: inline-block;
        }
        
        .price-growth.positive {
            background: rgba(40, 167, 69, 0.1);
            color: #28a745;
        }
        
        .price-growth.negative {
            background: rgba(220, 53, 69, 0.1);
            color: #dc3545;
        }
        
        .forecast-metrics-section {
            background: rgba(255, 255, 255, 0.7);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .forecast-metrics-title {
            font-size: 16px;
            font-weight: 600;
            color: #333333;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .forecast-metrics-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
        }
        
        .metric-item {
            text-align: center;
            padding: 12px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 1px 5px rgba(0, 0, 0, 0.05);
        }
        
        .metric-label {
            font-size: 11px;
            color: #6c757d;
            margin-bottom: 5px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        
        .metric-value {
            font-size: 16px;
            font-weight: 700;
            color: #333333;
        }
        
        .metric-value.positive {
            color: #28a745;
        }
        
        .metric-value.negative {
            color: #dc3545;
        }
        
        /* Compact Price Forecast Block Styles */
        .price-forecast-compact-block {
            margin-top: 20px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 16px;
            border: 1px solid rgba(0, 0, 0, 0.05);
            overflow: hidden;
            position: relative;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
        
        .price-forecast-compact-content {
            padding: 20px 25px;
            position: relative;
        }
        
        .price-forecast-compact-content::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 6px;
            background: linear-gradient(45deg, #28a745, #20c997);
        }
        
        .price-forecast-compact-title {
            font-size: 18px;
            font-weight: 700;
            color: #333333;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .price-forecast-compact-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .price-forecast-compact-column {
            background: white;
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            position: relative;
        }
        
        .price-forecast-compact-column.current {
            border-left: 4px solid #6c757d;
        }
        
        .price-forecast-compact-column.future {
            border-left: 4px solid #28a745;
        }
        
        .price-column-compact-title {
            font-size: 13px;
            font-weight: 600;
            color: #495057;
            margin-bottom: 12px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .price-forecast-compact-section {
            margin-bottom: 10px;
        }
        
        .price-forecast-compact-section:last-child {
            margin-bottom: 0;
        }
        
        .price-forecast-compact-label {
            font-size: 11px;
            color: #6c757d;
            margin-bottom: 3px;
            font-weight: 500;
        }
        
        .price-forecast-compact-value {
            font-size: 16px;
            font-weight: 700;
            margin-bottom: 3px;
        }
        
        .price-forecast-compact-value.user {
            color: #007bff;
        }
        
        .price-forecast-compact-value.market {
            color: #495057;
        }
        
        .price-forecast-compact-value.rent {
            color: #6f42c1;
        }
        
        .price-forecast-compact-value.future {
            color: #28a745;
        }
        
        .price-comparison {
            font-size: 11px;
            font-weight: 600;
            padding: 2px 6px;
            border-radius: 8px;
            display: inline-block;
        }
        
        .price-comparison.market-higher {
            background: rgba(40, 167, 69, 0.1);
            color: #28a745;
        }
        
        .price-comparison.market-lower {
            background: rgba(220, 53, 69, 0.1);
            color: #dc3545;
        }
        
        .price-growth-dual {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        
        .price-growth-dual .price-growth {
            font-size: 10px;
            font-weight: 600;
            padding: 2px 6px;
            border-radius: 8px;
        }
        
        .forecast-metrics-compact-section {
            background: rgba(255, 255, 255, 0.7);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 15px;
        }
        
        .forecast-metrics-compact-title {
            font-size: 15px;
            font-weight: 600;
            color: #333333;
            margin-bottom: 12px;
            text-align: center;
        }
        
        .forecast-metrics-compact-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        
        .metric-compact-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 10px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 1px 5px rgba(0, 0, 0, 0.05);
        }
        
        .metric-compact-label {
            font-size: 11px;
            color: #6c757d;
            font-weight: 500;
        }
        
        .metric-compact-value {
            font-size: 13px;
            font-weight: 700;
            color: #333333;
        }
        
        .metric-compact-value.positive {
            color: #28a745;
        }
        
        .metric-compact-value.negative {
            color: #dc3545;
        }
        
        /* Price Forecast Block Styles - Market Indicators Style */
        .price-forecast-table-block {
            margin-top: 20px;
        }
        
        .price-forecast-market-table {
            width: 100%;
            background: #f8f9fa;
            border-radius: 16px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            border: 1px solid rgba(0, 0, 0, 0.05);
            border-collapse: collapse;
        }
        
        .price-forecast-market-table thead {
            background: linear-gradient(90deg, #4CAF50, #45a049);
        }
        
        .forecast-category-header {
            padding: 20px 25px;
            color: white;
            font-size: 18px;
            font-weight: 700;
            text-align: center;
            border: none;
            width: 50%;
        }
        
        .forecast-data-cell {
            padding: 20px 25px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.08);
            background: white;
        }
        
        .forecast-data-cell:last-child {
            border-bottom: none;
        }
        
        .forecast-cell-label {
            font-size: 14px;
            color: #666;
            margin-bottom: 8px;
            font-weight: 500;
        }
        
        .forecast-cell-value {
            font-size: 16px;
            font-weight: 700;
            color: #333;
            line-height: 1.2;
        }
        
        .forecast-cell-value.positive {
            color: #28a745;
        }
        
        .forecast-cell-value.negative {
            color: #dc3545;
        }
        
        .forecast-cell-value.user-price {
            color: #007bff;
        }
        
        .forecast-cell-value.market-price {
            color: #6f42c1;
        }
        
        .forecast-cell-growth {
            font-size: 12px;
            margin-top: 4px;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 600;
            display: inline-block;
        }
        
        .forecast-cell-growth.positive {
            background: #d4edda;
            color: #155724;
        }
        
        .forecast-cell-growth.negative {
            background: #f8d7da;
            color: #721c24;
        }
        
        /* Metrics block for price forecast */
        .forecast-metrics-compact-section {
            margin-top: 20px;
            padding: 15px 25px;
            background: #f8f9fa;
            border-radius: 12px;
            border: 1px solid rgba(0, 0, 0, 0.05);
        }
        
        .forecast-metrics-compact-title {
            font-size: 16px;
            font-weight: 700;
            color: #333;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .forecast-metrics-compact-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        
        .metric-compact-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
        }
        
        .metric-compact-label {
            font-size: 14px;
            color: #666;
            font-weight: 500;
        }
        
        .metric-compact-value {
            font-size: 14px;
            font-weight: 700;
            color: #333;
        }
        
        .metric-compact-value.positive {
            color: #28a745;
        }
        
        .metric-compact-value.negative {
            color: #dc3545;
        }
        
        /* Footer info styles */
        .price-forecast-date {
            margin-top: 15px;
            text-align: center;
            font-size: 14px;
            color: #666;
            font-weight: 600;
        }
        
        .price-forecast-currency-info {
            margin-top: 5px;
            text-align: center;
            font-size: 12px;
            color: #888;
        }
        
        .price-forecast-disclaimer {
            margin-top: 10px;
            padding: 10px;
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            font-size: 11px;
            color: #856404;
            text-align: center;
            font-style: italic;
        }

        
        .price-forecast-growth {
            text-align: center;
            font-size: 13px;
            font-weight: 700;
        }
        
        .price-forecast-growth.positive {
            color: #28a745;
        }
        
        .price-forecast-growth.negative {
            color: #dc3545;
        }
        
        .price-comparison-inline {
            font-size: 10px;
            font-weight: 600;
            padding: 1px 4px;
            border-radius: 6px;
            display: inline-block;
            margin-top: 2px;
        }
        
        .price-comparison-inline.market-higher {
            background: rgba(40, 167, 69, 0.1);
            color: #28a745;
        }
        
        .price-comparison-inline.market-lower {
            background: rgba(220, 53, 69, 0.1);
            color: #dc3545;
        }
        
        /* Row specific styles */
        .price-forecast-user-row {
            background: rgba(0, 123, 255, 0.02);
        }
        
        .price-forecast-market-row {
            background: rgba(73, 80, 87, 0.02);
        }
        
        .price-forecast-rent-row {
            background: rgba(111, 66, 193, 0.02);
        }
        
        /* Мобильные устройства для блока прогноза цен */
        @media (max-width: 768px) {
            .price-forecast-block {
                margin-top: 15px;
            }
            
            .price-forecast-content {
                padding: 20px 24px;
            }
            
            .price-forecast-title {
                font-size: 16px;
                margin-bottom: 16px;
            }
            
            .price-forecast-sale-value,
            .price-forecast-rent-value {
                font-size: 18px;
                margin-bottom: 6px;
            }
            
            .price-forecast-sale-label,
            .price-forecast-rent-label {
                font-size: 14px;
                margin-bottom: 6px;
            }
            
            .price-forecast-date {
                font-size: 13px;
                margin-bottom: 6px;
                font-weight: 600;
            }
            
            .price-forecast-currency-info {
                font-size: 11px;
            }
            
            .price-forecast-disclaimer {
                font-size: 10px;
                margin-top: 6px;
            }
            
            /* Enhanced Price Forecast Mobile Styles */
            .price-forecast-enhanced-block {
                margin-top: 15px;
            }
            
            .price-forecast-enhanced-content {
                padding: 20px 24px;
            }
            
            .price-forecast-enhanced-title {
                font-size: 16px;
                margin-bottom: 20px;
            }
            
            .price-forecast-grid {
                grid-template-columns: 1fr;
                gap: 15px;
                margin-bottom: 20px;
            }
            
            .price-forecast-column {
                padding: 15px;
            }
            
            .price-column-title {
                font-size: 13px;
                margin-bottom: 12px;
            }
            
            .price-forecast-value {
                font-size: 16px;
            }
            
            .price-forecast-label {
                font-size: 11px;
            }
            
            .forecast-metrics-section {
                padding: 15px;
                margin-bottom: 15px;
            }
            
            .forecast-metrics-title {
                font-size: 15px;
                margin-bottom: 12px;
            }
            
            .forecast-metrics-grid {
                grid-template-columns: 1fr;
                gap: 10px;
            }
            
            .metric-item {
                padding: 10px;
            }
            
            .metric-value {
                font-size: 14px;
            }
            
            .metric-label {
                font-size: 10px;
            }
            
            /* Compact Price Forecast Mobile Styles */
            .price-forecast-compact-block {
                margin-top: 15px;
            }
            
            .price-forecast-compact-content {
                padding: 15px 20px;
            }
            
            .price-forecast-compact-title {
                font-size: 16px;
                margin-bottom: 15px;
            }
            
            .price-forecast-compact-grid {
                grid-template-columns: 1fr;
                gap: 12px;
                margin-bottom: 15px;
            }
            
            .price-forecast-compact-column {
                padding: 12px;
            }
            
            .price-column-compact-title {
                font-size: 12px;
                margin-bottom: 10px;
            }
            
            .price-forecast-compact-value {
                font-size: 14px;
            }
            
            .price-forecast-compact-label {
                font-size: 10px;
            }
            
            .forecast-metrics-compact-section {
                padding: 12px;
                margin-bottom: 12px;
            }
            
            .forecast-metrics-compact-title {
                font-size: 14px;
                margin-bottom: 10px;
            }
            
            .forecast-metrics-compact-grid {
                grid-template-columns: 1fr;
                gap: 6px;
            }
            
            .metric-compact-item {
                padding: 6px 8px;
            }
            
            .metric-compact-value {
                font-size: 12px;
            }
            
            .metric-compact-label {
                font-size: 10px;
            }
            
            .price-growth-dual .price-growth {
                font-size: 9px;
                padding: 1px 4px;
            }
            
            /* Price Forecast Mobile Styles - Market Style */
            .price-forecast-table-block {
                margin-top: 16px;
            }
            
            .price-forecast-market-table {
                border-radius: 12px;
            }
            
            .forecast-category-header {
                padding: 16px 20px;
                font-size: 16px;
            }
            
            .forecast-data-cell {
                padding: 16px 20px;
            }
            
            .forecast-cell-label {
                font-size: 14px;
                margin-bottom: 6px;
            }
            
            .forecast-cell-value {
                font-size: 14px;
            }
            
            .forecast-cell-growth {
                font-size: 11px;
                margin-top: 3px;
                padding: 1px 4px;
            }
            
            .forecast-metrics-compact-section {
                margin-top: 15px;
                padding: 12px 16px;
            }
            
            .forecast-metrics-compact-title {
                font-size: 14px;
                margin-bottom: 12px;
            }
            
            .forecast-metrics-compact-grid {
                gap: 10px;
            }
            
            .metric-compact-label,
            .metric-compact-value {
                font-size: 12px;
            }
            
            .price-forecast-date {
                font-size: 12px;
                margin-top: 12px;
            }
            
            .price-forecast-currency-info {
                font-size: 10px;
            }
            
            .price-forecast-disclaimer {
                font-size: 10px;
                padding: 8px;
                margin-top: 8px;
            }
            
            .forecast-metrics-compact-section {
                padding: 12px;
                margin-bottom: 12px;
            }
            
            .forecast-metrics-compact-title {
                font-size: 14px;
                margin-bottom: 10px;
            }
            
            .forecast-metrics-compact-grid {
                grid-template-columns: 1fr;
                gap: 6px;
            }
            
            .metric-compact-item {
                padding: 6px 8px;
            }
            
            .metric-compact-value {
                font-size: 12px;
            }
            
            .metric-compact-label {
                font-size: 10px;
            }
        }
        
        /* Table Styles */
        .data-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
            margin-top: 10px;
            table-layout: fixed;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .data-table td {
            padding: 6px 8px;
            border-bottom: 1px solid #f0f0f0;
            vertical-align: top;
            word-wrap: break-word;
            overflow-wrap: break-word;
            max-width: 0;
        }

        .data-table td:first-child {
            font-weight: 500;
            color: #555;
            width: 60%;
            text-align: left;
        }

        .data-table td:last-child {
            text-align: right;
            font-weight: 600;
            color: #333;
            width: 40%;
        }

        /* Sub-card Styles */
        .sub-card {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 8px;
            word-wrap: break-word;
            overflow-wrap: break-word;
            overflow: hidden;
        }

        .sub-card h3 {
            font-size: 15px;
            font-weight: 600;
            color: #333;
            margin: 0 0 8px 0;
            padding-bottom: 5px;
            border-bottom: 1px solid #f0f0f0;
        }

        .sub-card h4 {
            font-size: 14px;
            font-weight: 600;
            color: #555;
            margin: 8px 0 6px 0;
        }

        /* Error State Styles */
        .error-state {
            text-align: center;
            padding: 20px 15px;
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            border-radius: 6px;
            margin: 15px 0;
        }

        .error-icon {
            font-size: 32px;
            margin-bottom: 12px;
        }

        .error-text {
            font-size: 14px;
            color: #721c24;
        }

        /* Report Options Styles */
        .report-options {
            display: none;
            margin: 20px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 12px;
            border: 1px solid #e9ecef;
        }

        .report-options-title {
            font-size: 16px;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 15px;
        }

        .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            padding: 8px;
            border-radius: 8px;
            transition: background-color 0.2s ease;
        }

        .checkbox-item:hover {
            background-color: rgba(102, 126, 234, 0.1);
        }

        .checkbox-input {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: #667eea;
        }

        .checkbox-label {
            font-size: 14px;
            color: #495057;
            cursor: pointer;
            user-select: none;
        }

        /* Save and Share Button Styles */
        .save-share-button {
            display: none;
            width: 100%;
            padding: 15px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            text-align: center;
            margin-top: 20px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.2);
        }

        .save-share-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.3);
            background: linear-gradient(135deg, #5a67d8 0%, #6b46c1 100%);
        }

        .save-share-button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Property Info Modal Styles */
        .property-info-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }

        .property-info-modal-content {
            background: white;
            border-radius: 12px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
        }

        .property-info-modal-close {
            position: absolute;
            top: 15px;
            right: 20px;
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #6c757d;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .property-info-modal-title {
            font-size: 20px;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 20px;
        }

        .property-info-form {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .form-label {
            font-size: 14px;
            font-weight: 500;
            color: #495057;
        }

        .form-input {
            padding: 10px 12px;
            border: 1px solid #ced4da;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.2s ease;
        }

        .form-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .photo-upload-area {
            border: 2px dashed #ced4da;
            border-radius: 8px;
            padding: 30px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .photo-upload-area:hover {
            border-color: #667eea;
            background-color: rgba(102, 126, 234, 0.05);
        }

        .photo-upload-area.dragover {
            border-color: #667eea;
            background-color: rgba(102, 126, 234, 0.1);
        }

        .photo-upload-text {
            color: #6c757d;
            font-size: 14px;
            margin-bottom: 10px;
        }

        .photo-upload-button {
            background: #667eea;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
        }

        .photo-preview-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
        }

        .photo-preview {
            position: relative;
            width: 80px;
            height: 80px;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid #e9ecef;
        }

        .photo-preview img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .photo-preview-remove {
            position: absolute;
            top: 2px;
            right: 2px;
            background: rgba(220, 53, 69, 0.9);
            color: white;
            border: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
        }

        .modal-button {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .modal-button-primary {
            background: #667eea;
            color: white;
        }

        .modal-button-primary:hover {
            background: #5a67d8;
        }

        .modal-button-secondary {
            background: #e9ecef;
            color: #495057;
        }

        .modal-button-secondary:hover {
            background: #dee2e6;
        }

        /* Modal Styles */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: white;
            border-radius: 12px;
            padding: 30px;
            width: 90%;
            max-width: 450px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            position: relative;
        }

        .modal-close {
            position: absolute;
            top: 15px;
            right: 20px;
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #666;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-close:hover {
            color: #333;
        }

        .modal-title {
            font-size: 20px;
            font-weight: 600;
            color: #333;
            margin-bottom: 15px;
        }

        .modal-description {
            font-size: 14px;
            color: #666;
            margin-bottom: 20px;
            line-height: 1.5;
        }

        .modal-link-container {
            background: #f8f9fa;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            word-break: break-all;
        }

        .modal-link {
            color: #667eea;
            text-decoration: none;
            font-size: 14px;
            font-weight: 500;
        }

        .modal-link:hover {
            text-decoration: underline;
        }

        .modal-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .modal-button {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .modal-button-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .modal-button-primary:hover {
            background: linear-gradient(135deg, #5a67d8 0%, #6b46c1 100%);
            transform: translateY(-1px);
        }

        .modal-button-secondary {
            background: #f8f9fa;
            color: #666;
            border: 1px solid #e0e0e0;
        }

        .modal-button-secondary:hover {
            background: #e9ecef;
            color: #333;
        }

        /* Back Button Styles */
        .back-button {
            display: block;
            width: 100%;
            padding: 15px 20px;
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            margin: 20px 0;
            transition: all 0.3s ease;
            text-decoration: none;
            text-align: center;
        }

        .back-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(40, 167, 69, 0.3);
        }

        /* Animations */
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Mobile responsive styles */
        @media (max-width: 480px) {
            
            /* Мобильные стили для секций данных */
            .data-section {
                padding: 15px;
                margin-bottom: 15px;
            }
            
            .data-section-title {
                font-size: 16px;
                margin-bottom: 12px;
                padding-bottom: 8px;
            }
            
            .data-item {
                padding: 12px;
                margin-bottom: 15px;
            }
            
            .data-item-title {
                font-size: 14px;
                margin-bottom: 10px;
            }
            
            .summary-table th,
            .summary-table td {
                padding: 8px 6px;
                font-size: 12px;
            }
            
            .section-header td {
                font-size: 13px;
                padding: 10px 6px;
            }
            
            .yield-header {
                font-size: 16px;
            }
            
            .trends-grid {
                grid-template-columns: 1fr;
                gap: 10px;
            }
            
            .trend-card {
                padding: 12px;
            }
            
            .trend-title {
                font-size: 13px;
            }
            
            .trend-value {
                font-size: 16px;
            }
            
            .trend-period {
                font-size: 11px;
            }
            
            .trend-details {
                margin-top: 6px;
            }
            
            .trend-change {
                font-size: 10px;
                margin-bottom: 3px;
                font-weight: bold;
            }
            
            /* .trend-date removed - now part of .trend-change */
            
            .trends-table-title {
                font-size: 14px;
                margin-bottom: 12px;
            }
            
            .trends-table {
                font-size: 11px;
            }
            
            .trends-table th,
            .trends-table td {
                padding: 6px 4px;
            }
            
            .trends-chart-section {
                padding: 12px;
                margin-top: 15px;
                margin-bottom: 15px;
            }
            
            .trends-chart-title {
                font-size: 13px;
                margin-bottom: 10px;
            }
            
            .chart-controls {
                gap: 6px;
                margin-bottom: 12px;
            }
            
            .chart-button {
                padding: 5px 10px;
                font-size: 10px;
            }
            
            .chart-container {
                min-height: 140px;
            }
            
            .chart-info small {
                font-size: 10px;
            }
            
            .forecast-chart-section {
                padding: 12px;
                margin-top: 15px;
                margin-bottom: 15px;
            }
            
            .forecast-chart-title {
                font-size: 13px;
                margin-bottom: 10px;
            }
            
            .data-available {
                padding: 12px;
                font-size: 13px;
            }
        }

        /* Price and Area Input Styles */
        .listing-type-input {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            background: white;
            color: #333;
            margin-bottom: 10px;
        }

        .listing-type-input:focus {
            outline: none !important;
            border-color: #667eea !important;
            box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.1) !important;
            background: #fff !important;
        }
        
        .listing-type-input:not(:disabled):not(:read-only) {
            cursor: text !important;
            user-select: text !important;
            pointer-events: auto !important;
        }

        /* Currency Buttons Styles */
        .currency-buttons-container {
            margin-bottom: 15px;
        }

        .currency-buttons-title {
            font-size: 12px;
            color: #666;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .currency-buttons {
            display: flex;
            gap: 8px;
            justify-content: center;
        }

        .currency-button {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 50px;
            height: 40px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            transition: all 0.3s ease;
            padding: 4px;
        }

        .currency-button:hover {
            border-color: #667eea;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.2);
        }

        .currency-button.active {
            border-color: #667eea;
            background: #667eea;
            color: white;
        }

        .currency-button.active .currency-symbol {
            color: white;
        }

        .currency-symbol {
            font-size: 18px;
            font-weight: 600;
            color: #333;
        }

        /* Mobile responsive for listing type selection */
        @media (max-width: 480px) {
            .listing-type-section {
                padding: 12px;
                margin: 12px 0;
            }
            
            .listing-type-title {
                font-size: 13px;
                margin-bottom: 10px;
            }
            
            .listing-type-subtitle {
                font-size: 11px;
                margin-bottom: 6px;
            }
            
            .listing-type-select {
                padding: 8px 10px;
                font-size: 13px;
            }
            
            .listing-type-input {
                padding: 8px 10px;
                font-size: 13px;
                margin-bottom: 8px;
            }
            
            .currency-buttons {
                gap: 4px;
            }
            
            .currency-button {
                width: 45px;
                height: 35px;
                padding: 3px;
            }
            
            .currency-symbol {
                font-size: 16px;
            }
            
            .selected-property-types {
                margin-top: 12px;
                padding-top: 12px;
            }
            
            .property-types-title {
                font-size: 13px;
                margin-bottom: 6px;
            }
            
            .property-types-details {
                font-size: 12px;
            }
            
            .property-type-item {
                padding: 3px 0;
            }
        }
        
        /* Subscription required message styles */
        .subscription-required-section {
            background: #f8f9fa;
            border-radius: 16px;
            padding: 20px;
            margin: 20px 0;
            border-left: 6px solid #dc3545;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .subscription-required-title {
            color: #dc3545;
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .subscription-required-content {
            color: #495057;
            line-height: 1.6;
        }
        
        .subscription-benefits-title {
            font-weight: 600;
            color: #212529;
            margin-bottom: 10px;
            font-size: 16px;
        }
        
        .subscription-benefits-list {
            list-style: none;
            padding: 0;
            margin: 10px 0 15px 0;
        }
        
        .subscription-benefits-list li {
            padding: 5px 0;
            position: relative;
            padding-left: 20px;
        }
        
        .subscription-benefits-list li:before {
            content: "✓";
            color: #28a745;
            font-weight: bold;
            position: absolute;
            left: 0;
        }
        
        .subscription-how-title {
            font-weight: 600;
            color: #212529;
            margin: 20px 0 10px 0;
            font-size: 16px;
        }
        
        .subscription-instructions {
            margin: 10px 0;
            padding: 10px;
            background: #e9ecef;
            border-radius: 8px;
            border-left: 4px solid #007bff;
        }
        
        .subscription-follow {
            margin: 10px 0;
            font-style: italic;
            color: #6c757d;
        }
        
        .subscription-help {
            font-weight: 600;
            color: #212529;
            margin: 20px 0 10px 0;
        }
        
        .subscription-support {
            margin: 10px 0;
            padding: 10px;
            background: #e9ecef;
            border-radius: 8px;
            border-left: 4px solid #17a2b8;
        }
        
        .subscription-support a {
            color: #007bff;
            text-decoration: none;
            font-weight: 500;
        }
        
        .subscription-support a:hover {
            text-decoration: underline;
        }
        
        /* Mobile responsiveness for subscription message */
        @media (max-width: 768px) {
            .subscription-required-section {
                margin: 15px 0;
                padding: 15px;
            }
            
            .subscription-required-title {
                font-size: 16px;
                margin-bottom: 12px;
            }
            
            .subscription-benefits-title,
            .subscription-how-title,
            .subscription-help {
                font-size: 14px;
            }
            
            .subscription-benefits-list li {
                font-size: 13px;
                padding: 4px 0;
                padding-left: 18px;
            }
            
            .subscription-instructions,
            .subscription-support {
                padding: 8px;
                font-size: 13px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Логотип -->
        <div style="display:flex;flex-direction:column;align-items:center;margin-top:18px;margin-bottom:10px;">
            <img src="logo-flt.png" alt="Aaadviser Logo" style="width:110px;height:auto;display:block;margin-bottom:8px;cursor:pointer;" onclick="goToMainMenu()" />
            <div style="font-size:15px;color:#888;font-style:italic;" id="slogan" data-i18n="slogan">Инсайты рынка недвижимости</div>
        </div>

        <!-- Заголовок страницы -->
        <div class="page-title" id="pageTitle" data-i18n="pageTitle">Оценка объекта</div>
        <div class="page-description" id="pageDescription" data-i18n="pageDescription">Получите профессиональную оценку стоимости недвижимости в выбранном регионе</div>

        <!-- Форма выбора локации -->
        <div class="location-form" id="locationForm">
            <div class="form-group">
                <label for="countrySelect" id="countryLabel" data-i18n="countryLabel">Страна:</label>
                <select id="countrySelect" onchange="onCountryChange()">
                    <option value="" id="countryPlaceholder" data-i18n="countryPlaceholder">Выберите страну</option>
                </select>
            </div>

            <div class="form-group">
                <label for="citySelect" id="cityLabel" data-i18n="cityLabel">Город:</label>
                <select id="citySelect" disabled onchange="onCityChange()">
                    <option value="" id="cityPlaceholder" data-i18n="cityPlaceholder">Сначала выберите страну</option>
                </select>
            </div>

            <div class="form-group">
                <label for="countySelect" id="countyLabel" data-i18n="countyLabel">Область/Регион:</label>
                <select id="countySelect" disabled onchange="onCountyChange()">
                    <option value="" id="countyPlaceholder" data-i18n="countyPlaceholder">Сначала выберите город</option>
                </select>
            </div>

            <div class="form-group">
                <label for="districtSelect" id="districtLabel" data-i18n="districtLabel">Район:</label>
                <select id="districtSelect" disabled onchange="onDistrictChange()">
                    <option value="" id="districtPlaceholder" data-i18n="districtPlaceholder">Сначала выберите область</option>
                </select>
            </div>

                            <!-- Listing Type Selection -->
                <div class="listing-type-section" id="listingTypeSection" style="display: none;">
                    <div class="listing-type-title" id="listingTypeTitle" data-i18n="listingTypeTitle">Выберите тип недвижимости для анализа:</div>
                    
                    <!-- House Type Listing Types -->
                    <div class="listing-type-group">
                        <div class="listing-type-subtitle" id="houseTypeSubtitle" data-i18n="houseTypeSubtitle">Количество спален:</div>
                        <select class="listing-type-select" id="houseTypeSelect">
                            <option value="" id="houseTypePlaceholder" data-i18n="selectBedrooms">Выберите количество спален</option>
                        </select>
                    </div>

                    <!-- Floor Segment Listing Types -->
                    <div class="listing-type-group">
                        <div class="listing-type-subtitle" id="floorSegmentSubtitle" data-i18n="floorSegmentSubtitle">Этаж:</div>
                        <select class="listing-type-select" id="floorSegmentSelect">
                            <option value="" id="floorSegmentPlaceholder" data-i18n="selectFloor">Выберите этаж</option>
                        </select>
                    </div>

                    <!-- Age Data Listing Types -->
                    <div class="listing-type-group">
                        <div class="listing-type-subtitle" id="ageDataSubtitle" data-i18n="ageDataSubtitle">Возраст объекта:</div>
                        <select class="listing-type-select" id="ageDataSelect">
                            <option value="" id="ageDataPlaceholder" data-i18n="selectAge">Выберите возраст объекта</option>
                        </select>
                    </div>

                    <!-- Heating Data Listing Types -->
                    <div class="listing-type-group">
                        <div class="listing-type-subtitle" id="heatingDataSubtitle" data-i18n="heatingDataSubtitle">Тип отопления:</div>
                        <select class="listing-type-select" id="heatingDataSelect">
                            <option value="" id="heatingDataPlaceholder" data-i18n="selectHeating">Выберите тип отопления</option>
                        </select>
                    </div>

                    <!-- Price Object -->
                    <div class="listing-type-group">
                        <div class="listing-type-subtitle" id="priceObjectSubtitle" data-i18n="priceObjectSubtitle">Цена объекта:</div>
                        <input type="number" id="priceObjectInput" class="listing-type-input" placeholder="Введите цену" data-i18n-placeholder="pricePlaceholder">
                        
                        <!-- Currency Selection -->
                        <div class="currency-buttons-container">
                            <div class="currency-buttons-title" id="currencyTitle" data-i18n="currencyTitle">Выберите валюту:</div>
                            <div class="currency-buttons">
                                <button type="button" class="currency-button" data-currency="TRY">
                                    <span class="currency-symbol">₺</span>
                                </button>
                                <button type="button" class="currency-button" data-currency="EUR">
                                    <span class="currency-symbol">€</span>
                                </button>
                                <button type="button" class="currency-button" data-currency="USD">
                                    <span class="currency-symbol">$</span>
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Area Object -->
                    <div class="listing-type-group">
                        <div class="listing-type-subtitle" id="areaObjectSubtitle" data-i18n="areaObjectSubtitle">Площадь объекта (м²):</div>
                        <input type="number" id="areaObjectInput" class="listing-type-input" placeholder="Введите площадь" min="10" max="1000" data-i18n-placeholder="areaPlaceholder">
                    </div>
                </div>

            <button class="confirm-button" id="confirmButton" onclick="confirmLocation()" disabled>
                <span id="confirmButtonText" data-i18n="confirmButtonText">Подтвердить выбор</span>
            </button>
        </div>

        <!-- Выбранная локация -->
        <div class="selected-location" id="selectedLocation" style="display: none;">
            <div class="location-title" id="selectedLocationTitle" data-i18n="selectedLocationTitle">Выбранная локация:</div>
            <div class="location-details" id="locationDetails"></div>
            
            <!-- Выбранные характеристики недвижимости -->
            <div class="selected-property-types" id="selectedPropertyTypes" style="display: none;">
                <div class="property-types-title" id="propertyTypesTitle" data-i18n="propertyTypesTitle">Выбранные характеристики недвижимости:</div>
                <div class="property-types-details" id="propertyTypesDetails"></div>
            </div>
            
            </div>
        
        <!-- Блок с ID для админов (отдельный) -->
        <div class="admin-ids-block" id="adminIdsBlock" style="display: none;">
            <div class="admin-ids-title" id="adminIdsTitle">ID для админов:</div>
            <div class="admin-ids-details" id="adminIdsDetails"></div>
        </div>

        <!-- Ключевые метрики - скрыты -->
        <div class="key-metrics-section" id="keyMetricsSection" style="display: none;">
            <!-- Ключевые метрики скрыты, показывается только таблица "Средние значения" -->
        </div>



        <!-- Data Content -->
        <div class="data-content" id="dataContent" style="display: none;">
            <!-- Market Indicators Table -->
            <div class="data-section" id="summaryDataSection">
                <h3 class="data-section-title" id="summaryDataTitle"></h3>
                <div class="data-section-content" id="summaryDataContent">
                    <!-- Market indicators data will be populated here -->
                </div>
            </div>
        </div>

        <!-- Report Options -->
        <div class="report-options" id="reportOptions">
            <div class="report-options-title" data-i18n="reportOptionsTitle">Дополнительные опции отчета</div>
            <div class="checkbox-group">
                <label class="checkbox-item">
                    <input type="checkbox" class="checkbox-input" id="includeRealtorInfo">
                    <span class="checkbox-label" data-i18n="includeRealtorInfo">Добавить информацию риэлтора</span>
                </label>
                <label class="checkbox-item">
                    <input type="checkbox" class="checkbox-input" id="includePropertyInfo">
                    <span class="checkbox-label" data-i18n="includePropertyInfo">Добавить информацию объекта</span>
                </label>
            </div>
        </div>

        <!-- Save and Share Button -->
        <button class="save-share-button" id="saveShareButton" onclick="saveAndShareReport()">
            <span id="saveShareButtonText" data-i18n="saveShareButtonText">Сохранить и поделиться отчетом</span>
        </button>

        <!-- Error State -->
        <div class="error-state" id="errorState" style="display: none;">
            <div class="error-icon">❌</div>
            <div class="error-text" id="errorText" data-i18n="errorText">Ошибка загрузки данных</div>
        </div>

        <!-- Back Button -->
        <a href="/webapp_main" class="back-button" id="backButton">← Вернуться в главное меню</a>

        <!-- Modal for sharing report -->
        <div class="modal-overlay" id="shareModal">
            <div class="modal-content">
                <button class="modal-close" onclick="closeShareModal()">×</button>
                <div class="modal-title" id="modalTitle" data-i18n="reports.report_saved">Отчет сохранен</div>
                <div class="modal-description" id="modalDescription">
                    Ваш отчет успешно сохранен. Вы можете скопировать ссылку и поделиться ею с другими.
                </div>
                <div class="modal-link-container">
                    <a id="modalLink" href="#" target="_blank" class="modal-link">Ссылка на отчет</a>
                </div>
                <div class="modal-actions">
                    <button class="modal-button modal-button-primary" onclick="copyReportLink()">
                        <span id="copyButtonText">Копировать ссылку</span>
                    </button>
                    <button class="modal-button modal-button-secondary" onclick="closeShareModal()">
                        <span id="closeButtonText" data-i18n="common.close">Закрыть</span>
                    </button>
                </div>
            </div>
        </div>

        <!-- Property Info Modal -->
        <div class="property-info-modal" id="propertyInfoModal">
            <div class="property-info-modal-content">
                <button class="property-info-modal-close" onclick="closePropertyInfoModal()">×</button>
                <div class="property-info-modal-title" data-i18n="propertyInfoModalTitle">Информация об объекте</div>
                
                <div class="property-info-form">
                    <div class="form-group">
                        <label class="form-label" data-i18n="propertyUrlLabel">Ссылка на объявление:</label>
                        <input type="url" class="form-input" id="propertyUrl" placeholder="https://example.com/property">
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label" data-i18n="propertyPhotosLabel">Фотографии объекта:</label>
                        <div class="photo-upload-area" id="photoUploadArea">
                            <div class="photo-upload-text" data-i18n="photoUploadText">Нажмите или перетащите фотографии сюда</div>
                            <button type="button" class="photo-upload-button" onclick="document.getElementById('photoInput').click()">
                                <span data-i18n="selectPhotos">Выбрать фото</span>
                            </button>
                            <input type="file" id="photoInput" accept="image/*" multiple style="display: none;">
                        </div>
                        <div class="photo-preview-container" id="photoPreviewContainer"></div>
                    </div>
                </div>
                
                <div class="modal-actions">
                    <button class="modal-button modal-button-primary" onclick="savePropertyInfo()">
                        <span data-i18n="save">Сохранить</span>
                    </button>
                    <button class="modal-button modal-button-secondary" onclick="closePropertyInfoModal()">
                        <span data-i18n="cancel">Отмена</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Telegram WebApp initialization
        let tg = window.Telegram.WebApp;
        tg.ready();
        tg.expand();

        // Current language
        let currentLanguage = 'ru';

        // Property info storage
        let propertyInfo = {
            photos: [],
            url: ''
        };

        // Selected location data
        let selectedLocation = {
            country_id: null,
            city_id: null,
            county_id: null,
            district_id: null,
            country_name: '',
            city_name: '',
            county_name: '',
            district_name: ''
        };
        
        // Global variable for market summary data
        let marketSummaryData = null;

        // User language
        let userLanguage = 'en';

        // Selected listing types
        let selectedListingTypes = {
            house_type: null,
            floor_segment: null,
            age: null,
            heating: null,
            currency: 'EUR'  // По умолчанию EUR
        };

        // Localization data
        const locales = {
            'ru': {
                'slogan': 'Инсайты рынка недвижимости',
                'pageTitle': 'Оценка объекта',
                'pageDescription': 'Получите профессиональную оценку стоимости недвижимости в выбранном регионе',
                'countryLabel': 'Страна:',
                'cityLabel': 'Город:',
                'countyLabel': 'Область/Регион:',
                'districtLabel': 'Район:',
                'countryPlaceholder': 'Выберите страну',
                'cityPlaceholder': 'Сначала выберите страну',
                'countyPlaceholder': 'Сначала выберите город',
                'districtPlaceholder': 'Сначала выберите область',
                'confirmButtonText': 'Подтвердить выбор',
                'backButton': '← Вернуться в главное меню',
                'selectedLocationTitle': 'Выбранная локация:',
                'adminIdsTitle': 'ID для админов:',
                'loading': 'Загрузка...',
                'errorLoading': 'Ошибка загрузки данных',
                'dataSectionTitle': 'Анализ данных региона',
                'loadingText': 'Загрузка данных...',
                'errorText': 'Ошибка загрузки данных',
                'totalProperties': 'Всего объектов:',
                'averagePrice': 'Средняя цена:',
                'priceRange': 'Диапазон цен:',
                'noDataAvailable': 'Данные недоступны',
                'keyMetricsTitle': 'Ключевые показатели',
                'avgSalePriceLabel': 'Средняя цена продажи за м²',
                'avgRentPriceLabel': 'Средняя цена аренды за м²',
                'listingPeriodSaleLabel': 'Период размещения (продажа)',
                'listingPeriodRentLabel': 'Период размещения (аренда)',
                'yieldLabel': 'Доходность',

                'listingTypeTitle': 'Выберите тип недвижимости для анализа:',
                'houseTypeSubtitle': 'Количество спален:',
                'floorSegmentSubtitle': 'Этаж:',
                'ageDataSubtitle': 'Возраст объекта:',
                'heatingDataSubtitle': 'Тип отопления:',
                'priceObjectSubtitle': 'Цена объекта:',
                'areaObjectSubtitle': 'Площадь объекта (м²):',
                'selectBedrooms': 'количество спален',
                'selectFloor': 'этаж',
                'selectAge': 'возраст объекта',
                'selectHeating': 'тип отопления',
                'propertyTypesTitle': 'Выбранные характеристики недвижимости:',
                'bedroomsLabel': 'Количество спален',
                'floorLabel': 'Этаж',
                'ageLabel': 'Возраст объекта',
                'heatingLabel': 'Тип отопления',
                'marketIndicatorsTitle': 'Показатели рынка',
                'marketTrendsTitle': 'Тренды рынка',
                'saleHeader': 'Продажа',
                'rentHeader': 'Аренда',
                'currencyTitle': 'Выберите валюту:',
                'saveShareButtonText': 'Сохранить и поделиться отчетом',
                'modalTitle': 'Отчет сохранен',
                'modalDescription': 'Ваш отчет успешно сохранен. Вы можете скопировать ссылку и поделиться ею с другими.',
                'copyButtonText': 'Копировать ссылку',
                'closeButtonText': 'Закрыть',
                'linkCopied': 'Ссылка скопирована!',
                'savingReport': 'Сохранение отчета...',
                'errorSaving': 'Ошибка сохранения отчета',
                'pricePlaceholder': 'Введите цену',
                'areaPlaceholder': 'Введите площадь',
                'trendsFilterInfo': 'Показано ${filteredCount} из ${totalCount} трендов',
                'marketComparisonTitle': 'Сравнение с рынком',
                'pricePerM2Label': 'Цена за м²',
                'areaLabel': 'Площадь',
                'priceComparisonLabel': 'Цена за м²:',
                'areaComparisonLabel': 'Площадь:',
                'priceCloseToMarket': 'Ваш объект (${userPrice}) близок к рыночной (${marketMin} – ${marketMax}).',
                'priceAboveMarket': 'Ваш объект (${userPrice}) выше рынка на ${percent}%.',
                'priceBelowMarket': 'Ваш объект (${userPrice}) ниже рынка на ${percent}%.',
                'areaMatchesMarket': 'Ваш объект (${userArea} м²) соответствует рыночному спросу (${marketMin}–${marketMax} м²).',
                'areaBelowMarket': 'Ваш объект (${userArea} м²) меньше востребованной на рынке (${marketMin}–${marketMax} м²).',
                'areaAboveMarket': 'Ваш объект (${userArea} м²) больше востребованной на рынке (${marketMin}–${marketMax} м²).',
                'houseTypeDataTitle': 'Данные по количеству спален',
                'floorSegmentDataTitle': 'Данные по этажу',
                'ageDataTitle': 'Данные по возрасту объектов',
                'heatingDataTitle': 'Данные по типу отопления',
                'consolidatedAssessmentTitle': 'Консолидированная оценка',
                'salePriceTitle': 'Цена за м² (Unit Price For Sale):',
                'rentPriceTitle': 'Цена аренды за м² (Unit Price For Rent):',
                'yieldTitle': 'Доходность (Yield):',
                'consolidatedAverageLabel': 'Консолидированная средняя:',
                'bedroomsLabel': 'Спальни',
                'floorLabel': 'Этаж',
                'ageLabel': 'Возраст',
                'heatingLabel': 'Отопление',
                
                // Ключи локализации для таблицы "Показатели рынка"
                'indicatorLabel': 'Показатель',
                'minValueLabel': 'Минимальное значение',
                'maxValueLabel': 'Максимальное значение',
                'comparableAreaForSaleLabel': 'Сопоставимая площадь',
                'countForSaleLabel': 'Количество для продажи',
                'listingPeriodForSaleLabel': 'Срок до продажи',
                'unitPriceForSaleLabel': 'Цена за м²',
                'comparableAreaForRentLabel': 'Сопоставимая площадь',
                'countForRentLabel': 'Количество для аренды',
                'listingPeriodForRentLabel': 'Срок до аренды',
                'unitPriceForRentLabel': 'Цена за м²',
                
                // Ключи для текстового анализа рынка
                'marketAnalysisTitle': 'Анализ рынка',
                'saleAnalysisText': 'Продажа: при площади {area} м² (среднее значение по проданным объектам) и минимальной цене {minPrice}/м² срок продажи составляет ~{minDays} дней; при максимальной цене {maxPrice}/м² - срок продажи до {maxDays} дней.',
                'rentAnalysisText': 'Аренда: при площади {area} м² (среднее значение по сданным в аренду объектам) минимальная цена {minPrice}/м² срок сдачи ~{minDays} дней; при максимальной цене {maxPrice}/м² срок до {maxDays} дней.',
                
                // Ключи для графика трендов
                'chart_title': 'График трендов',
                'sale_button': 'Цена м² продажи',
                'rent_button': 'Цена м² аренды',
                'chart_info': 'Показаны данные до текущего месяца и один месяц вперед',
                
                // Ключи для графика прогноза
                'forecast_chart_title': 'График прогноза цен и аренды',
                'forecast_chart_info': 'Прогноз на основе текущего и будущих месяцев',
                
                // Ключи для блока "Вывод по объекту"
                'objectSummaryTitle': 'Вывод по объекту',
                'objectPricePerM2Label': 'Цена за м² вашего объекта:',
                'objectCurrencyLabel': 'Валюта объекта:',
                'objectAreaLabel': 'Площадь объекта:',
                'exchangeRateLabel': 'Курс конвертации:',
                
                // Ключи для подписей свойств
                'propertyPriceLabel': 'Цена объекта:',
                'propertyAreaLabel': 'Площадь объекта:',
                
                // Ключи для продажи и аренды
                'saleLabel': 'Продажа:',
                'rentLabel': 'Аренда:',
                
                // Ключи для сообщения о подписке
                'subscriptionRequiredTitle': 'Функция долгосрочного прогноза стоимости объекта доступна только для пользователей с активной подпиской.',
                'subscriptionBenefits': 'Что даёт подписка:',
                'subscriptionBenefit1': 'Прогноз цены объекта на 12 месяцев вперёд',
                'subscriptionBenefit2': 'Дополнительные аналитические данные',
                'subscriptionBenefit3': 'Дополнительные возможности сервиса',
                'howToSubscribe': 'Как оформить подписку:',
                'subscribeInstructions': 'Перейдите к боту @Aaadviser_pay_bot',
                'followInstructions': 'Следуйте инструкциям для подключения',
                'needHelp': 'Нужна помощь?',
                'contactSupport': 'Свяжитесь с нашей поддержкой: @Aaadviser_support_bot',
                'selectPropertyType': 'Выберите тип недвижимости',
                'detailedDataTitle': 'Детальные данные (только для администраторов)',
                'detailedTrendsDataTitle': 'Детальные данные трендов',
                
                // Units of measurement
                'unit_years': 'лет',
                'unit_days': 'дней',
                'unit_square_meters': 'м²',
                
                // Trends analysis
                'trendsAnalysisTitle': 'Вывод по тренду',
                
                // Table headers for trends
                'priceChangeLabel': 'Изм-ие цены',
                'yieldLabel': 'Доходность',
                'forecastSaleLabel': 'Прогноз продажи',
                'forecastRentLabel': 'Прогноз аренды',
                'forecastYieldLabel': 'Прогноз доходности',
                'dateLabel': 'Дата',
                
                // Chart labels
                'saleForecastTooltip': 'Прогноз продажи',
                'rentForecastTooltip': 'Прогноз аренды',
                'saleForecastYAxis': 'Прогноз продажи',
                'rentForecastYAxis': 'Прогноз аренды',
                
                // Price forecast block labels
                'priceForecastTitle': 'Прогноз цен',
                'currentPriceLabel': 'Текущая стоимость',
                'futurePriceLabel': 'Прогнозная стоимость',
                'userSalePriceLabel': 'Цена продажи',
                'marketSalePriceLabel': 'Расчетная цена текущего рынка',
                'rentRateLabel': 'Ставка аренды',
                'keyMetricsLabel': 'Ключевые показатели',
                'priceGrowthLabel': 'Рост цены',
                'rentGrowthLabel': 'Рост аренды',
                'avgYieldLabel': 'Средняя доходность',
                'totalROILabel': 'ROI за период',
                'paybackPeriodLabel': 'Срок окупаемости',
                'forecastPeriodLabel': 'Период прогноза',
                'yearsUnit': 'лет',
                'monthsUnit': 'мес.',
                'toYourPriceLabel': 'к вашей цене',
                
                // Object comparison labels
                'vsMinMarketPriceLabel': 'vs. мин. цена рынка',
                'vsMaxMarketPriceLabel': 'vs. макс. цена рынка',
                'vsAvgAreaLabel': 'vs. средняя площадь',
                'estimatedRentLabel': 'Примерная аренда',
                
                // Analysis texts
                'marketStabilityText': 'Рынок недвижимости демонстрирует стабильность',
                'marketGrowthText': 'Рынок недвижимости демонстрирует устойчивый рост как в продажах, так и в аренде',
                'cheaperThanBothText': 'дешевле как минимальной, так и максимальной цены рынка',
                'expensiveThanBothText': 'дороже как минимальной, так и максимальной цены рынка',
                'betweenMinMaxText': 'дороже минимальной, но дешевле максимальной цены рынка',
                'largerAreaText': 'имеет большую площадь чем большинство объектов на рынке',
                'smallerAreaText': 'имеет меньшую площадь чем большинство объектов на рынке',
                'forecastBasedOnText': 'Прогноз на основе',
                'forecastMonthsInfo': '${months} месяцев (предыдущий + текущий + будущие)',
                
                // Currency and additional analysis texts
                'exchangeRateText': 'Курс',
                'fromToText': 'С',
                'byToText': 'по',
                'yearText': 'года',
                'salesPricesGrewText': 'цены на продажу выросли примерно на',
                'rentGrewText': 'аренда — на',
                'showingInvestmentAttractivenessText': 'показывая привлекательность инвестиций',
                'currentTrendIndicatesText': 'Текущий тренд указывает на',
                'stabilityText': 'стабильность',
                'gradualIncreaseText': 'постепенное увеличение',
                'gradualDecreaseText': 'постепенное снижение',
                'yieldStabilityText': 'доходности, но сохраняется положительная динамика',
                'mixedDynamicsText': 'Рынок недвижимости показывает смешанную динамику',
                'salesPricesGrewByText': 'Цены на продажу выросли на',
                'rentGrewByText': 'аренда выросла на',
                'maintainsAttractivenessText': 'сохраняет привлекательность для инвесторов',
                'yieldRangeText': 'держится в диапазоне',
                'investmentPotentialText': 'показывает устойчивость инвестиционного потенциала',
                
                // Chart axis labels
                'monthAxisLabel': 'Месяц',
                
                // Trend types
                'priceTrendLabel': 'Тренд цен',
                'yieldTrendLabel': 'Тренд доходности',
                'countTrendLabel': 'Тренд количества',
                'generalTrendLabel': 'Общий тренд',
                
                // Chart axis and tooltip labels
                'salePriceAxisLabel': 'Цена продажи (₺/м²)',
                'rentPriceAxisLabel': 'Цена аренды (₺/м²)',
                'salePriceTooltip': 'Цена продажи',
                'rentPriceTooltip': 'Цена аренды',
                'yourObjectLabel': 'Ваш объект',
                'andText': 'и'
            },
            'en': {
                'slogan': 'Real Estate Market Insights',
                'pageTitle': 'Object Evaluation',
                'pageDescription': 'Get a professional property valuation in the selected region',
                'countryLabel': 'Country:',
                'cityLabel': 'City:',
                'countyLabel': 'Region/Area:',
                'districtLabel': 'District:',
                'countryPlaceholder': 'Select country',
                'cityPlaceholder': 'First select country',
                'countyPlaceholder': 'First select city',
                'districtPlaceholder': 'First select region',
                'confirmButtonText': 'Confirm selection',
                'backButton': '← Back to main menu',
                'selectedLocationTitle': 'Selected location:',
                'adminIdsTitle': 'IDs for admins:',
                'loading': 'Loading...',
                'errorLoading': 'Error loading data',
                'dataSectionTitle': 'Regional Data Analysis',
                'loadingText': 'Loading data...',
                'errorText': 'Error loading data',
                'totalProperties': 'Total properties:',
                'averagePrice': 'Average price:',
                'priceRange': 'Price range:',
                'noDataAvailable': 'Data not available',
                'keyMetricsTitle': 'Key Metrics',
                'avgSalePriceLabel': 'Average Sale Price per m²',
                'avgRentPriceLabel': 'Average Rent Price per m²',
                'listingPeriodSaleLabel': 'Listing Period (Sale)',
                'listingPeriodRentLabel': 'Listing Period (Rent)',
                'yieldLabel': 'Yield',

                'listingTypeTitle': 'Select property type for analysis:',
                'houseTypeSubtitle': 'Bedroom count:',
                'floorSegmentSubtitle': 'Floor:',
                'ageDataSubtitle': 'Property age:',
                'heatingDataSubtitle': 'Heating type:',
                'priceObjectSubtitle': 'Property price:',
                'areaObjectSubtitle': 'Property area (m²):',
                'selectBedrooms': 'bedroom count',
                'selectFloor': 'floor',
                'selectAge': 'property age',
                'selectHeating': 'heating type',
                'propertyTypesTitle': 'Selected property characteristics:',
                'bedroomsLabel': 'Bedroom count',
                'floorLabel': 'Floor',
                'ageLabel': 'Property age',
                'heatingLabel': 'Heating type',
                'marketIndicatorsTitle': 'Market Indicators',
                'marketTrendsTitle': 'Market Trends',
                'saleHeader': 'Sale',
                'rentHeader': 'Rent',
                'currencyTitle': 'Select currency:',
                'saveShareButtonText': 'Save and share report',
                'modalTitle': 'Report saved',
                'modalDescription': 'Your report has been successfully saved. You can copy the link and share it with others.',
                'copyButtonText': 'Copy link',
                'closeButtonText': 'Close',
                'linkCopied': 'Link copied!',
                'savingReport': 'Saving report...',
                'errorSaving': 'Error saving report',
                'pricePlaceholder': 'Enter price',
                'areaPlaceholder': 'Enter area',
                'trendsFilterInfo': 'Showing ${filteredCount} of ${totalCount} trends',
                'marketComparisonTitle': 'Market Comparison',
                'pricePerM2Label': 'Price per m²',
                'areaLabel': 'Area',
                'priceComparisonLabel': 'Price per m²:',
                'areaComparisonLabel': 'Area:',
                'priceCloseToMarket': 'Your object (${userPrice}) is close to market (${marketMin} – ${marketMax}).',
                'priceAboveMarket': 'Your object (${userPrice}) is above market by ${percent}%.',
                'priceBelowMarket': 'Your object (${userPrice}) is below market by ${percent}%.',
                'areaMatchesMarket': 'Your object (${userArea} m²) matches market demand (${marketMin}–${marketMax} m²).',
                'areaBelowMarket': 'Your object (${userArea} m²) is smaller than market demand (${marketMin}–${marketMax} m²).',
                'areaAboveMarket': 'Your object (${userArea} m²) is larger than market demand (${marketMin}–${marketMax} m²).',
                'houseTypeDataTitle': 'Bedroom Count Data',
                'floorSegmentDataTitle': 'Floor Data',
                'ageDataTitle': 'Property Age Data',
                'heatingDataTitle': 'Heating Type Data',
                'consolidatedAssessmentTitle': 'Consolidated Assessment',
                'salePriceTitle': 'Price per m² (Unit Price For Sale):',
                'rentPriceTitle': 'Rent Price per m² (Unit Price For Rent):',
                'yieldTitle': 'Yield:',
                'consolidatedAverageLabel': 'Consolidated Average:',
                'bedroomsLabel': 'Bedrooms',
                
                // Market analysis text localization keys
                'marketAnalysisTitle': 'Market Analysis',
                'saleAnalysisText': 'Sale: with an area of {area} m² (average value for sold properties) and a minimum price of {minPrice}/m², the sale period is ~{minDays} days; with a maximum price of {maxPrice}/m² - the sale period is up to {maxDays} days.',
                'rentAnalysisText': 'Rent: with an area of {area} m² (average value for rented properties) minimum price {minPrice}/m², rental period ~{minDays} days; with a maximum price of {maxPrice}/m² period up to {maxDays} days.',
                
                // Object summary localization keys
                'objectSummaryTitle': 'Object Summary',
                'objectPricePerM2Label': 'Price per m² of your object:',
                'objectCurrencyLabel': 'Object currency:',
                'objectAreaLabel': 'Object area:',
                'exchangeRateLabel': 'Exchange rate:',
                'floorLabel': 'Floor',
                'ageLabel': 'Age',
                'heatingLabel': 'Heating',
                
                // Keys for "Market Indicators" table
                'indicatorLabel': 'Indicator',
                'minValueLabel': 'Minimum Value',
                'maxValueLabel': 'Maximum Value',
                'comparableAreaForSaleLabel': 'Comparable Area',
                'countForSaleLabel': 'Count for Sale',
                'listingPeriodForSaleLabel': 'Time to Sale',
                'unitPriceForSaleLabel': 'Unit Price',
                'comparableAreaForRentLabel': 'Comparable Area',
                'countForRentLabel': 'Count for Rent',
                'listingPeriodForRentLabel': 'Time to Rent',
                'unitPriceForRentLabel': 'Unit Price',
                
                // Keys for market analysis text
                'marketAnalysisTitle': 'Market Analysis',
                'saleAnalysisText': 'Sale: with an area of {area} m² (average value for sold properties) and minimum price {minPrice}/m², the sale period is ~{minDays} days; with maximum price {maxPrice}/m² - sale period up to {maxDays} days.',
                'rentAnalysisText': 'Rent: with an area of {area} m² (average value for rented properties) minimum price {minPrice}/m², rental period ~{minDays} days; with maximum price {maxPrice}/m², period up to {maxDays} days.',
                
                // Keys for trends chart
                'chart_title': 'Trends Chart',
                'sale_button': 'Sale Price per m²',
                'rent_button': 'Rent Price per m²',
                'chart_info': 'Data shown up to current month and one month ahead',
                
                // Keys for forecast chart
                'forecast_chart_title': 'Price and Rent Forecast Chart',
                'forecast_chart_info': 'Forecast based on current and future months',
                
                // Keys for property labels
                'propertyPriceLabel': 'Property price:',
                'propertyAreaLabel': 'Property area:',
                
                // Keys for sale and rent labels
                'saleLabel': 'Sale:',
                'rentLabel': 'Rent:',
                
                // Keys for subscription message
                'subscriptionRequiredTitle': 'Long-term property value forecasting is only available for users with an active subscription.',
                'subscriptionBenefits': 'What subscription gives you:',
                'subscriptionBenefit1': 'Property price forecast for 12 months ahead',
                'subscriptionBenefit2': 'Additional analytical data',
                'subscriptionBenefit3': 'Additional service capabilities',
                'howToSubscribe': 'How to subscribe:',
                'subscribeInstructions': 'Go to bot @Aaadviser_pay_bot',
                'followInstructions': 'Follow the connection instructions',
                'needHelp': 'Need help?',
                'contactSupport': 'Contact our support: @Aaadviser_support_bot',
                'selectPropertyType': 'Select property type',
                'detailedDataTitle': 'Detailed data (administrators only)',
                'detailedTrendsDataTitle': 'Detailed trends data',
                
                // Units of measurement
                'unit_years': 'years',
                'unit_days': 'days',
                'unit_square_meters': 'm²',
                
                // Trends analysis
                'trendsAnalysisTitle': 'Trend Analysis',
                
                // Table headers for trends
                'priceChangeLabel': 'Price Change',
                'yieldLabel': 'Yield',
                'forecastSaleLabel': 'Sale Forecast',
                'forecastRentLabel': 'Rent Forecast',
                'forecastYieldLabel': 'Yield Forecast',
                'dateLabel': 'Date',
                
                // Chart labels
                'saleForecastTooltip': 'Sale Forecast',
                'rentForecastTooltip': 'Rent Forecast',
                'saleForecastYAxis': 'Sale Forecast',
                'rentForecastYAxis': 'Rent Forecast',
                
                // Price forecast block labels
                'priceForecastTitle': 'Price Forecast',
                'currentPriceLabel': 'Current Value',
                'futurePriceLabel': 'Forecast Value',
                'userSalePriceLabel': 'Sale Price',
                'marketSalePriceLabel': 'Current Market Price',
                'rentRateLabel': 'Rent Rate',
                'keyMetricsLabel': 'Key Metrics',
                'priceGrowthLabel': 'Price Growth',
                'rentGrowthLabel': 'Rent Growth',
                'avgYieldLabel': 'Average Yield',
                'totalROILabel': 'ROI for Period',
                'paybackPeriodLabel': 'Payback Period',
                'forecastPeriodLabel': 'Forecast Period',
                'yearsUnit': 'years',
                'monthsUnit': 'months',
                'toYourPriceLabel': 'vs your price',
                
                // Object comparison labels
                'vsMinMarketPriceLabel': 'vs. min market price',
                'vsMaxMarketPriceLabel': 'vs. max market price',
                'vsAvgAreaLabel': 'vs. average area',
                'estimatedRentLabel': 'Estimated rent',
                
                // Analysis texts
                'marketStabilityText': 'Real estate market demonstrates stability',
                'marketGrowthText': 'Real estate market demonstrates steady growth in both sales and rentals',
                'cheaperThanBothText': 'cheaper than both minimum and maximum market prices',
                'expensiveThanBothText': 'more expensive than both minimum and maximum market prices',
                'betweenMinMaxText': 'more expensive than minimum but cheaper than maximum market price',
                'largerAreaText': 'has larger area than most properties on the market',
                'smallerAreaText': 'has smaller area than most properties on the market',
                'forecastBasedOnText': 'Forecast based on',
                'forecastMonthsInfo': '${months} months (previous + current + future)',
                
                // Currency and additional analysis texts
                'exchangeRateText': 'Rate',
                'fromToText': 'From',
                'byToText': 'to',
                'yearText': 'year',
                'salesPricesGrewText': 'sales prices grew approximately by',
                'rentGrewText': 'rent — by',
                'showingInvestmentAttractivenessText': 'showing investment attractiveness',
                'currentTrendIndicatesText': 'Current trend indicates',
                'stabilityText': 'stability',
                'gradualIncreaseText': 'gradual increase',
                'gradualDecreaseText': 'gradual decrease',
                'yieldStabilityText': 'in yield, but positive dynamics remain',
                'mixedDynamicsText': 'Real estate market shows mixed dynamics',
                'salesPricesGrewByText': 'Sales prices grew by',
                'rentGrewByText': 'rent increased by',
                'maintainsAttractivenessText': 'maintains attractiveness for investors',
                'yieldRangeText': 'remains in the range of',
                'investmentPotentialText': 'shows stability of investment potential',
                
                // Chart axis labels
                'monthAxisLabel': 'Month',
                
                // Trend types
                'priceTrendLabel': 'Price Trend',
                'yieldTrendLabel': 'Yield Trend',
                'countTrendLabel': 'Count Trend',
                'generalTrendLabel': 'General Trend',
                
                // Chart axis and tooltip labels
                'salePriceAxisLabel': 'Sale Price (₺/m²)',
                'rentPriceAxisLabel': 'Rent Price (₺/m²)',
                'salePriceTooltip': 'Sale Price',
                'rentPriceTooltip': 'Rent Price',
                'yourObjectLabel': 'Your Object',
                'andText': 'and'
            },
            'de': {
                'slogan': 'Immobilienmarkt-Einblicke',
                'pageTitle': 'Objektbewertung',
                'pageDescription': 'Erhalten Sie eine professionelle Immobilienbewertung in der ausgewählten Region',
                'countryLabel': 'Land:',
                'cityLabel': 'Stadt:',
                'countyLabel': 'Region/Bereich:',
                'districtLabel': 'Bezirk:',
                'countryPlaceholder': 'Land auswählen',
                'cityPlaceholder': 'Zuerst Land auswählen',
                'countyPlaceholder': 'Zuerst Stadt auswählen',
                'districtPlaceholder': 'Zuerst Region auswählen',
                'confirmButtonText': 'Auswahl bestätigen',
                'backButton': '← Zurück zum Hauptmenü',
                'selectedLocationTitle': 'Ausgewählte Lage:',
                'adminIdsTitle': 'IDs für Administratoren:',
                'loading': 'Laden...',
                'errorLoading': 'Fehler beim Laden der Daten',
                'dataSectionTitle': 'Regionale Datenanalyse',
                'generalDataTitle': 'Allgemeine Daten',
                'houseTypeDataTitle': 'Schlafzimmer-Anzahl-Daten',
                'floorSegmentDataTitle': 'Etagen-Daten',
                'ageDataTitle': 'Altersdaten',
                'heatingDataTitle': 'Heizungstyp-Daten',
                'loadingText': 'Daten werden geladen...',
                'errorText': 'Fehler beim Laden der Daten',
                'totalProperties': 'Gesamtobjekte:',
                'averagePrice': 'Durchschnittspreis:',
                'priceRange': 'Preisbereich:',
                'noDataAvailable': 'Daten nicht verfügbar',
                'keyMetricsTitle': 'Wichtige Kennzahlen',
                'avgSalePriceLabel': 'Durchschnittlicher Verkaufspreis pro m²',
                'avgRentPriceLabel': 'Durchschnittlicher Mietpreis pro m²',
                'listingPeriodSaleLabel': 'Angebotsdauer (Verkauf)',
                'listingPeriodRentLabel': 'Angebotsdauer (Vermietung)',
                'yieldLabel': 'Rendite',
                'insightsTitle': 'Zusammenfassung',
                'insightsLoading': 'Daten werden analysiert...',
                'insightsError': 'Fehler bei der Datenanalyse',
                
                'listingTypeTitle': 'Immobilientyp für Analyse auswählen:',
                'houseTypeSubtitle': 'Anzahl der Schlafzimmer:',
                'floorSegmentSubtitle': 'Etage:',
                'ageDataSubtitle': 'Immobilienalter:',
                'heatingDataSubtitle': 'Heizungstyp:',
                'priceObjectSubtitle': 'Immobilienpreis:',
                'areaObjectSubtitle': 'Immobilienfläche (m²):',
                'currencyTitle': 'Währung auswählen:',
                'pricePlaceholder': 'Preis eingeben',
                'areaPlaceholder': 'Fläche eingeben',
                'selectBedrooms': 'Schlafzimmer auswählen',
                'selectFloor': 'Etage auswählen',
                'selectAge': 'Alter auswählen',
                'selectHeating': 'Heizungstyp auswählen',
                'propertyTypesTitle': 'Immobilientypen',
                'saveShareButtonText': 'Speichern und teilen',
                'modalTitle': 'Bericht teilen',
                'modalDescription': 'Kopieren Sie den Link, um den Bericht zu teilen',
                'copyButtonText': 'Kopieren',
                'closeButtonText': 'Schließen',
                'selectPropertyType': 'Immobilientyp auswählen',
                'detailedDataTitle': 'Detaillierte Daten (nur für Administratoren)',
                'detailedTrendsDataTitle': 'Detaillierte Trenddaten',
                
                // Market indicators
                'marketIndicatorsTitle': 'Marktindikatoren',
                'saleHeader': 'Verkauf',
                'rentHeader': 'Vermietung',
                'comparableAreaForSaleLabel': 'Vergleichbare Fläche',
                'comparableAreaForRentLabel': 'Vergleichbare Fläche',
                'listingPeriodForSaleLabel': 'Angebotsdauer',
                'listingPeriodForRentLabel': 'Angebotsdauer',
                'unitPriceForSaleLabel': 'Einheitspreis',
                'unitPriceForRentLabel': 'Einheitspreis',
                
                // Units of measurement
                'unit_years': 'Jahre',
                'unit_days': 'Tage',
                'unit_square_meters': 'm²',
                
                // Trends analysis
                'trendsAnalysisTitle': 'Trendanalyse',
                
                // Keys for market analysis text
                'marketAnalysisTitle': 'Marktanalyse',
                'saleAnalysisText': 'Verkauf: bei einer Fläche von {area} m² (Durchschnittswert für verkaufte Objekte) und einem Mindestpreis von {minPrice}/m² beträgt die Verkaufsdauer ~{minDays} Tage; bei einem Höchstpreis von {maxPrice}/m² - Verkaufsdauer bis zu {maxDays} Tage.',
                'rentAnalysisText': 'Vermietung: bei einer Fläche von {area} m² (Durchschnittswert für vermietete Objekte) Mindestpreis {minPrice}/m², Vermietungsdauer ~{minDays} Tage; bei einem Höchstpreis von {maxPrice}/m² Dauer bis zu {maxDays} Tage.',
                
                // Keys for trends chart
                'chart_title': 'Trend-Diagramm',
                'sale_button': 'Verkaufspreis pro m²',
                'rent_button': 'Mietpreis pro m²',
                'chart_info': 'Daten bis zum aktuellen Monat und einen Monat voraus angezeigt',
                
                // Keys for forecast chart
                'forecast_chart_title': 'Preis- und Miet-Prognosediagramm',
                'forecast_chart_info': 'Prognose basierend auf aktuellen und zukünftigen Monaten',
                
                // Keys for object summary
                'objectSummaryTitle': 'Objektzusammenfassung',
                'objectPricePerM2Label': 'Preis pro m² Ihres Objekts:',
                'objectCurrencyLabel': 'Objektwährung:',
                'objectAreaLabel': 'Objektfläche:',
                'exchangeRateLabel': 'Wechselkurs:',
                
                // Keys for property labels
                'propertyPriceLabel': 'Objektpreis:',
                'propertyAreaLabel': 'Objektfläche:',
                
                // Keys for sale and rent labels
                'saleLabel': 'Verkauf:',
                'rentLabel': 'Vermietung:',
                
                // Missing keys for German localization
                'bedroomsLabel': 'Schlafzimmer',
                'floorLabel': 'Etage',
                'ageLabel': 'Alter',
                'heatingLabel': 'Heizung',
                'consolidatedAverageLabel': 'Konsolidierter Durchschnitt:',
                'propertyTypesTitle': 'Ausgewählte Immobilienmerkmale:',
                'marketIndicatorsTitle': 'Marktindikatoren',
                'marketTrendsTitle': 'Markttrends',
                'saleHeader': 'Verkauf',
                'rentHeader': 'Vermietung',
                'yieldHeader': 'Rendite',
                'salePriceTitle': 'Preis pro m² (Verkaufseinheitspreis):',
                'rentPriceTitle': 'Mietpreis pro m² (Mieteinheitspreis):',
                'yieldTitle': 'Rendite:',
                'indicatorLabel': 'Indikator',
                'minValueLabel': 'Mindestwert',
                'maxValueLabel': 'Höchstwert',
                'comparableAreaForSaleLabel': 'Vergleichbare Fläche für Verkauf',
                'countForSaleLabel': 'Anzahl für Verkauf',
                'listingPeriodForSaleLabel': 'Inseratsdauer für Verkauf',
                'unitPriceForSaleLabel': 'Einheitspreis für Verkauf',
                'comparableAreaForRentLabel': 'Vergleichbare Fläche für Vermietung',
                'countForRentLabel': 'Anzahl für Vermietung',
                'listingPeriodForRentLabel': 'Inseratsdauer für Vermietung',
                'unitPriceForRentLabel': 'Einheitspreis für Vermietung',
                'insightsTitle': 'Zusammenfassung',
                'insightsLoading': 'Daten werden analysiert...',
                'insightsError': 'Fehler bei der Datenanalyse',
                'selectBedrooms': 'Anzahl der Schlafzimmer auswählen',
                'selectFloor': 'Etage auswählen',
                'selectAge': 'Alter auswählen',
                'selectHeating': 'Heizungstyp auswählen',
                'saveShareButtonText': 'Speichern und teilen',
                'modalTitle': 'Bericht teilen',
                'modalDescription': 'Link kopieren, um den Bericht zu teilen',
                'copyButtonText': 'Kopieren',
                'closeButtonText': 'Schließen',
                
                // Units of measurement
                'unit_years': 'Jahre',
                'unit_days': 'Tage',
                'unit_square_meters': 'm²',
                
                // Trends analysis
                'trendsAnalysisTitle': 'Trendanalyse',
                
                // Table headers for trends
                'priceChangeLabel': 'Preisänderung',
                'yieldLabel': 'Rendite',
                'forecastSaleLabel': 'Verkaufsprognose',
                'forecastRentLabel': 'Mietprognose', 
                'forecastYieldLabel': 'Renditeprognose',
                'dateLabel': 'Datum',
                
                // Chart labels
                'saleForecastTooltip': 'Verkaufsprognose',
                'rentForecastTooltip': 'Mietprognose',
                'saleForecastYAxis': 'Verkaufsprognose',
                'rentForecastYAxis': 'Mietprognose',
                
                // Price forecast block labels
                'priceForecastTitle': 'Preisprognose',
                'currentPriceLabel': 'Aktueller Wert',
                'futurePriceLabel': 'Prognostizierter Wert',
                'userSalePriceLabel': 'Verkaufspreis',
                'marketSalePriceLabel': 'Aktueller Marktpreis',
                'rentRateLabel': 'Mietrate',
                'keyMetricsLabel': 'Kennzahlen',
                'priceGrowthLabel': 'Preiswachstum',
                'rentGrowthLabel': 'Mietwachstum',
                'avgYieldLabel': 'Durchschnittliche Rendite',
                'totalROILabel': 'ROI für Zeitraum',
                'paybackPeriodLabel': 'Amortisationszeit',
                'forecastPeriodLabel': 'Prognosezeitraum',
                'yearsUnit': 'Jahre',
                'monthsUnit': 'Monate',
                'toYourPriceLabel': 'zu Ihrem Preis',
                
                // Object comparison labels
                'vsMinMarketPriceLabel': 'vs. min. Marktpreis',
                'vsMaxMarketPriceLabel': 'vs. max. Marktpreis',
                'vsAvgAreaLabel': 'vs. durchschn. Fläche',
                'estimatedRentLabel': 'Geschätzte Miete',
                
                // Analysis texts
                'marketStabilityText': 'Immobilienmarkt zeigt Stabilität',
                'marketGrowthText': 'Immobilienmarkt zeigt stetiges Wachstum sowohl bei Verkäufen als auch Vermietungen',
                'cheaperThanBothText': 'günstiger als sowohl Mindest- als auch Höchstmarktpreis',
                'expensiveThanBothText': 'teurer als sowohl Mindest- als auch Höchstmarktpreis',
                'betweenMinMaxText': 'teurer als Mindest- aber günstiger als Höchstmarktpreis',
                'largerAreaText': 'hat größere Fläche als die meisten Objekte am Markt',
                'smallerAreaText': 'hat kleinere Fläche als die meisten Objekte am Markt',
                'forecastBasedOnText': 'Prognose basiert auf',
                'forecastMonthsInfo': '${months} Monate (vorherige + aktuelle + zukünftige)',
                
                // Currency and additional analysis texts
                'exchangeRateText': 'Kurs',
                'fromToText': 'Von',
                'byToText': 'bis',
                'yearText': 'Jahr',
                'salesPricesGrewText': 'Verkaufspreise stiegen um etwa',
                'rentGrewText': 'Mieten — um',
                'showingInvestmentAttractivenessText': 'zeigt Investitionsattraktivität',
                'currentTrendIndicatesText': 'Aktueller Trend zeigt',
                'stabilityText': 'Stabilität',
                'gradualIncreaseText': 'allmählicher Anstieg',
                'gradualDecreaseText': 'allmählicher Rückgang',
                'yieldStabilityText': 'der Rendite, aber positive Dynamik bleibt bestehen',
                'mixedDynamicsText': 'Immobilienmarkt zeigt gemischte Dynamik',
                'salesPricesGrewByText': 'Verkaufspreise stiegen um',
                'rentGrewByText': 'Mieten stiegen um',
                'maintainsAttractivenessText': 'behält Attraktivität für Investoren',
                'yieldRangeText': 'bleibt im Bereich von',
                'investmentPotentialText': 'zeigt Stabilität des Investitionspotenzials',
                
                // Chart axis labels
                'monthAxisLabel': 'Monat',
                
                // Trend types
                'priceTrendLabel': 'Preistrend',
                'yieldTrendLabel': 'Renditetrend',
                'countTrendLabel': 'Anzahltrend',
                'generalTrendLabel': 'Allgemeiner Trend',
                
                // Chart axis and tooltip labels
                'salePriceAxisLabel': 'Verkaufspreis (₺/m²)',
                'rentPriceAxisLabel': 'Mietpreis (₺/m²)',
                'salePriceTooltip': 'Verkaufspreis',
                'rentPriceTooltip': 'Mietpreis',
                'yourObjectLabel': 'Ihr Objekt',
                'andText': 'und'
            },
            'fr': {
                'slogan': 'Aperçus du marché immobilier',
                'pageTitle': 'Évaluation d\'objet',
                'pageDescription': 'Obtenez une évaluation professionnelle de propriété dans la région sélectionnée',
                'countryLabel': 'Pays :',
                'cityLabel': 'Ville :',
                'countyLabel': 'Région/Zone :',
                'districtLabel': 'District :',
                'countryPlaceholder': 'Sélectionner un pays',
                'cityPlaceholder': 'D\'abord sélectionner un pays',
                'countyPlaceholder': 'D\'abord sélectionner une ville',
                'districtPlaceholder': 'D\'abord sélectionner une région',
                'confirmButtonText': 'Confirmer la sélection',
                'backButton': '← Retour au menu principal',
                'selectedLocationTitle': 'Emplacement sélectionné :',
                'adminIdsTitle': 'IDs pour les administrateurs :',
                'loading': 'Chargement...',
                'errorLoading': 'Erreur de chargement des données',
                'dataSectionTitle': 'Analyse des données régionales',
                'generalDataTitle': 'Données générales',
                'houseTypeDataTitle': 'Données du nombre de chambres',
                'floorSegmentDataTitle': 'Données d\'étage',
                'ageDataTitle': 'Données d\'âge',
                'heatingDataTitle': 'Données du type de chauffage',
                'loadingText': 'Chargement des données...',
                'errorText': 'Erreur de chargement des données',
                'totalProperties': 'Total des propriétés :',
                'averagePrice': 'Prix moyen :',
                'priceRange': 'Fourchette de prix :',
                'noDataAvailable': 'Données non disponibles',
                'keyMetricsTitle': 'Métriques clés',
                'avgSalePriceLabel': 'Prix de vente moyen par m²',
                'avgRentPriceLabel': 'Prix de location moyen par m²',
                'listingPeriodSaleLabel': 'Période d\'inscription (vente)',
                'listingPeriodRentLabel': 'Période d\'inscription (location)',
                'yieldLabel': 'Rendement',
                'insightsTitle': 'Résumé',
                'insightsLoading': 'Analyse des données...',
                'insightsError': 'Erreur lors de l\'analyse des données',
                
                // Form elements that are missing
                'listingTypeTitle': 'Sélectionnez le type de propriété pour l\'analyse :',
                'houseTypeSubtitle': 'Nombre de chambres :',
                'floorSegmentSubtitle': 'Étage :',
                'ageDataSubtitle': 'Âge de la propriété :',
                'heatingDataSubtitle': 'Type de chauffage :',
                'priceObjectSubtitle': 'Prix de la propriété :',
                'areaObjectSubtitle': 'Surface de la propriété (m²) :',
                'currencyTitle': 'Sélectionnez la devise :',
                'pricePlaceholder': 'Entrer le prix',
                'areaPlaceholder': 'Entrer la surface',
                'selectBedrooms': 'Sélectionner le nombre de chambres',
                'selectFloor': 'Sélectionner l\'étage',
                'selectAge': 'Sélectionner l\'âge',
                'selectHeating': 'Sélectionner le type de chauffage',
                'selectPropertyType': 'Sélectionner le type de propriété',
                
                // Missing market analysis elements
                'marketAnalysisTitle': 'Analyse du marché',
                'saleAnalysisText': 'Vente : avec une surface de {area} m² (valeur moyenne pour les propriétés vendues) et un prix minimum de {minPrice}/m², la période de vente est de ~{minDays} jours ; avec un prix maximum de {maxPrice}/m² - la période de vente va jusqu\'à {maxDays} jours.',
                'rentAnalysisText': 'Location : avec une surface de {area} m² (valeur moyenne pour les propriétés louées) prix minimum {minPrice}/m², période de location ~{minDays} jours ; avec un prix maximum de {maxPrice}/m², période jusqu\'à {maxDays} jours.',
                'marketTrendsTitle': 'Tendances du marché',
                'objectSummaryTitle': 'Résumé de l\'objet',
                'propertyTypesTitle': 'Types de propriétés',
                'detailedDataTitle': 'Données détaillées (pour administrateurs uniquement)',
                'detailedTrendsDataTitle': 'Données détaillées des tendances',
                'chart_title': 'Graphique des tendances',
                'chart_info': 'Données jusqu\'au mois actuel et un mois en avance affichées',
                'forecast_chart_title': 'Graphique de prévision',
                'forecast_chart_info': 'Prévision basée sur la dynamique actuelle et est ajustée pour l\'inflation',
                
                // Chart buttons
                'sale_button': 'Prix de vente par m²',
                'rent_button': 'Prix de location par m²',
                
                // Missing property labels
                'propertyPriceLabel': 'Prix de la propriété',
                'propertyAreaLabel': 'Surface de la propriété',
                'saleLabel': 'Vente',
                'rentLabel': 'Location',
                'bedroomsLabel': 'Chambres',
                'floorLabel': 'Étage',
                'ageLabel': 'Âge',
                'heatingLabel': 'Chauffage',
                'consolidatedAverageLabel': 'Moyenne consolidée',
                
                // Missing buttons and UI elements
                'saveShareButtonText': 'Sauvegarder et partager le rapport',
                'modalTitle': 'Rapport sauvegardé',
                'modalDescription': 'Votre rapport a été sauvegardé avec succès. Vous pouvez copier le lien et le partager avec d\'autres.',
                'copyButtonText': 'Copier',
                'closeButtonText': 'Fermer',
                
                // Market indicators
                'marketIndicatorsTitle': 'Indicateurs de marché',
                'saleHeader': 'Vente',
                'rentHeader': 'Location',
                'comparableAreaForSaleLabel': 'Surface comparable',
                'comparableAreaForRentLabel': 'Surface comparable',
                'listingPeriodForSaleLabel': 'Durée d\'inscription',
                'listingPeriodForRentLabel': 'Durée d\'inscription',
                'unitPriceForSaleLabel': 'Prix unitaire',
                'unitPriceForRentLabel': 'Prix unitaire',
                
                // Units of measurement
                'unit_years': 'ans',
                'unit_days': 'jours',
                'unit_square_meters': 'm²',
                
                // Trends analysis
                'trendsAnalysisTitle': 'Analyse des tendances',
                
                // Table headers for trends
                'priceChangeLabel': 'Changement de prix',
                'yieldLabel': 'Rendement',
                'forecastSaleLabel': 'Prévision de vente',
                'forecastRentLabel': 'Prévision de location',
                'forecastYieldLabel': 'Prévision de rendement',
                'dateLabel': 'Date',
                
                // Chart labels
                'saleForecastTooltip': 'Prévision de vente',
                'rentForecastTooltip': 'Prévision de location',
                'saleForecastYAxis': 'Prévision de vente',
                'rentForecastYAxis': 'Prévision de location',
                
                // Price forecast block labels
                'priceForecastTitle': 'Prévision des prix',
                'currentPriceLabel': 'Valeur actuelle',
                'futurePriceLabel': 'Valeur prévue',
                'userSalePriceLabel': 'Prix de vente',
                'marketSalePriceLabel': 'Prix actuel du marché',
                'rentRateLabel': 'Taux de location',
                'keyMetricsLabel': 'Métriques clés',
                'priceGrowthLabel': 'Croissance des prix',
                'rentGrowthLabel': 'Croissance des loyers',
                'avgYieldLabel': 'Rendement moyen',
                'totalROILabel': 'ROI pour la période',
                'paybackPeriodLabel': 'Période de récupération',
                'forecastPeriodLabel': 'Période de prévision',
                'yearsUnit': 'ans',
                'monthsUnit': 'mois',
                'toYourPriceLabel': 'par rapport à votre prix',
                
                // Object comparison labels
                'vsMinMarketPriceLabel': 'vs. prix min. marché',
                'vsMaxMarketPriceLabel': 'vs. prix max. marché',
                'vsAvgAreaLabel': 'vs. superficie moy.',
                'estimatedRentLabel': 'Loyer estimé',
                
                // Analysis texts
                'marketStabilityText': 'Le marché immobilier démontre de la stabilité',
                'marketGrowthText': 'Le marché immobilier démontre une croissance stable dans les ventes et locations',
                'cheaperThanBothText': 'moins cher que les prix minimum et maximum du marché',
                'expensiveThanBothText': 'plus cher que les prix minimum et maximum du marché',
                'betweenMinMaxText': 'plus cher que le minimum mais moins cher que le maximum du marché',
                'largerAreaText': 'a une superficie plus grande que la plupart des propriétés sur le marché',
                'smallerAreaText': 'a une superficie plus petite que la plupart des propriétés sur le marché',
                'forecastBasedOnText': 'Prévision basée sur',
                'forecastMonthsInfo': '${months} mois (précédent + actuel + futurs)',
                
                // Currency and additional analysis texts
                'exchangeRateText': 'Taux',
                'fromToText': 'De',
                'byToText': 'à',
                'yearText': 'année',
                'salesPricesGrewText': 'les prix de vente ont augmenté d\'environ',
                'rentGrewText': 'loyers — de',
                'showingInvestmentAttractivenessText': 'montrant l\'attractivité des investissements',
                'currentTrendIndicatesText': 'La tendance actuelle indique',
                'stabilityText': 'stabilité',
                'gradualIncreaseText': 'augmentation graduelle',
                'gradualDecreaseText': 'diminution graduelle',
                'yieldStabilityText': 'du rendement, mais la dynamique positive persiste',
                'mixedDynamicsText': 'Le marché immobilier montre une dynamique mixte',
                'salesPricesGrewByText': 'Les prix de vente ont augmenté de',
                'rentGrewByText': 'les loyers ont augmenté de',
                'maintainsAttractivenessText': 'maintient l\'attractivité pour les investisseurs',
                'yieldRangeText': 'reste dans la fourchette de',
                'investmentPotentialText': 'montre la stabilité du potentiel d\'investissement',
                
                // Chart axis labels
                'monthAxisLabel': 'Mois',
                
                // Trend types
                'priceTrendLabel': 'Tendance des prix',
                'yieldTrendLabel': 'Tendance des rendements',
                'countTrendLabel': 'Tendance des quantités',
                'generalTrendLabel': 'Tendance générale',
                
                // Chart axis and tooltip labels
                'salePriceAxisLabel': 'Prix de vente (₺/m²)',
                'rentPriceAxisLabel': 'Prix de location (₺/m²)',
                'salePriceTooltip': 'Prix de vente',
                'rentPriceTooltip': 'Prix de location',
                'yourObjectLabel': 'Votre objet',
                'andText': 'et'
            },
            'tr': {
                'slogan': 'Gayrimenkul Piyasa İçgörüleri',
                'pageTitle': 'Nesne Değerlendirmesi',
                'pageDescription': 'Seçilen bölgede profesyonel gayrimenkul değerlendirmesi alın',
                'countryLabel': 'Ülke:',
                'cityLabel': 'Şehir:',
                'countyLabel': 'Bölge/Alan:',
                'districtLabel': 'İlçe:',
                'countryPlaceholder': 'Ülke seçin',
                'cityPlaceholder': 'Önce ülke seçin',
                'countyPlaceholder': 'Önce şehir seçin',
                'districtPlaceholder': 'Önce bölge seçin',
                'confirmButtonText': 'Seçimi onayla',
                'backButton': '← Ana menüye dön',
                'selectedLocationTitle': 'Seçilen konum:',
                'adminIdsTitle': 'Yöneticiler için ID\'ler:',
                'loading': 'Yükleniyor...',
                'errorLoading': 'Veri yükleme hatası',
                'dataSectionTitle': 'Bölgesel Veri Analizi',
                'generalDataTitle': 'Genel Veriler',
                'houseTypeDataTitle': 'Yatak Odası Sayısı Verileri',
                'floorSegmentDataTitle': 'Kat Verileri',
                'ageDataTitle': 'Yaş Verileri',
                'heatingDataTitle': 'Isıtma Tipi Verileri',
                'loadingText': 'Veriler yükleniyor...',
                'errorText': 'Veri yükleme hatası',
                'totalProperties': 'Toplam mülk:',
                'averagePrice': 'Ortalama fiyat:',
                'priceRange': 'Fiyat aralığı:',
                'noDataAvailable': 'Veri mevcut değil',
                'keyMetricsTitle': 'Ana Metrikler',
                'avgSalePriceLabel': 'm² başına ortalama satış fiyatı',
                'avgRentPriceLabel': 'm² başına ortalama kiralama fiyatı',
                'listingPeriodSaleLabel': 'İlan süresi (satış)',
                'listingPeriodRentLabel': 'İlan süresi (kiralama)',
                'yieldLabel': 'Getiri',

                'marketComparisonTitle': 'Piyasa Karşılaştırması',
                'pricePerM2Label': 'm² başına fiyat',
                'areaLabel': 'Alan',
                'priceComparisonLabel': 'm² başına fiyat:',
                'areaComparisonLabel': 'Alan:',
                'priceCloseToMarket': 'Nesneniz (${userPrice}) piyasaya yakın (${marketMin} – ${marketMax}).',
                'priceAboveMarket': 'Nesneniz (${userPrice}) piyasadan ${percent}% yüksek.',
                'priceBelowMarket': 'Nesneniz (${userPrice}) piyasadan ${percent}% düşük.',
                'areaMatchesMarket': 'Nesneniz (${userArea} m²) piyasa talebine uygun (${marketMin}–${marketMax} m²).',
                'areaBelowMarket': 'Nesneniz (${userArea} m²) piyasa talebinden küçük (${marketMin}–${marketMax} m²).',
                'areaAboveMarket': 'Nesneniz (${userArea} m²) piyasa talebinden büyük (${marketMin}–${marketMax} m²).',
                'consolidatedAssessmentTitle': 'Konsolide Değerlendirme',
                'salePriceTitle': 'm² başına fiyat (Satış Birim Fiyatı):',
                'rentPriceTitle': 'm² başına kiralama fiyatı (Kiralama Birim Fiyatı):',
                'yieldTitle': 'Getiri:',
                'consolidatedAverageLabel': 'Konsolide ortalama:',
                'bedroomsLabel': 'Yatak Odası',
                'floorLabel': 'Kat',
                'ageLabel': 'Yaş',
                'heatingLabel': 'Isıtma',
                
                // "Piyasa Analizi" metni için anahtarlar
                'marketAnalysisTitle': 'Piyasa Analizi',
                'saleAnalysisText': 'Satış: {area} m² alan (satılan mülklerin ortalama değeri) ve {minPrice}/m² minimum fiyat ile satış süresi ~{minDays} gün; {maxPrice}/m² maksimum fiyat ile satış süresi {maxDays} güne kadar.',
                'rentAnalysisText': 'Kiralama: {area} m² alan (kiralanan mülklerin ortalama değeri) {minPrice}/m² minimum fiyat, kiralama süresi ~{minDays} gün; {maxPrice}/m² maksimum fiyat ile süre {maxDays} güne kadar.',
                
                'listingTypeTitle': 'Analiz için gayrimenkul türü seçin:',
                'houseTypeSubtitle': 'Yatak odası sayısı:',
                'floorSegmentSubtitle': 'Kat:',
                'ageDataSubtitle': 'Mülk yaşı:',
                'heatingDataSubtitle': 'Isıtma tipi:',
                'priceObjectSubtitle': 'Mülk fiyatı:',
                'areaObjectSubtitle': 'Mülk alanı (m²):',
                'currencyTitle': 'Para birimi seçin:',
                'pricePlaceholder': 'Fiyat girin',
                'areaPlaceholder': 'Alan girin',
                'selectBedrooms': 'Yatak odası seçin',
                'selectFloor': 'Kat seçin',
                'selectAge': 'Yaş seçin',
                'selectHeating': 'Isıtma tipi seçin',
                'selectPropertyType': 'Gayrimenkul türü seçin',
                'detailedDataTitle': 'Detaylı veriler (sadece yöneticiler için)',
                'detailedTrendsDataTitle': 'Detaylı trend verileri',
                'propertyTypesTitle': 'Gayrimenkul Türleri',
                'saveShareButtonText': 'Kaydet ve paylaş',
                'modalTitle': 'Raporu paylaş',
                'modalDescription': 'Raporu paylaşmak için bağlantıyı kopyalayın',
                'copyButtonText': 'Kopyala',
                'closeButtonText': 'Kapat',
                
                // Missing chart and analysis keys
                'chart_title': 'Trend Grafiği',
                'chart_info': 'Mevcut ay ve bir ay ileriye kadar veriler gösterilir',
                'forecast_chart_title': 'Fiyat ve Kiralama Tahmin Grafiği',
                'forecast_chart_info': 'Mevcut ve gelecek aylara dayalı tahmin',
                'sale_button': 'm² Satış Fiyatı',
                'rent_button': 'm² Kiralama Fiyatı',
                'objectSummaryTitle': 'Nesne Özeti',
                
                // Missing market indicators
                'marketIndicatorsTitle': 'Piyasa Göstergeleri',
                'saleHeader': 'Satış',
                'rentHeader': 'Kiralama',
                'indicatorLabel': 'Gösterge',
                'minValueLabel': 'Minimum değer',
                'maxValueLabel': 'Maksimum değer',
                'comparableAreaForSaleLabel': 'Karşılaştırılabilir alan',
                'countForSaleLabel': 'Satış için sayı',
                'listingPeriodForSaleLabel': 'Satışa kadar süre',
                'unitPriceForSaleLabel': 'Birim fiyat',
                'comparableAreaForRentLabel': 'Karşılaştırılabilir alan',
                'countForRentLabel': 'Kiralama için sayı',
                'listingPeriodForRentLabel': 'Kiralamaya kadar süre',
                'unitPriceForRentLabel': 'Birim fiyat',
                
                // Units of measurement
                'unit_years': 'yıl',
                'unit_days': 'gün',
                'unit_square_meters': 'm²',
                
                // Trends analysis
                'trendsAnalysisTitle': 'Trend Analizi',
                
                // Table headers for trends
                'priceChangeLabel': 'Fiyat Değişimi',
                'forecastSaleLabel': 'Satış Tahmini',
                'forecastRentLabel': 'Kiralama Tahmini',
                'forecastYieldLabel': 'Getiri Tahmini',
                'dateLabel': 'Tarih',
                
                // Chart labels
                'saleForecastTooltip': 'Satış Tahmini',
                'rentForecastTooltip': 'Kiralama Tahmini',
                'saleForecastYAxis': 'Satış Tahmini',
                'rentForecastYAxis': 'Kiralama Tahmini',
                
                // Price forecast block labels
                'priceForecastTitle': 'Fiyat Tahmini',
                'currentPriceLabel': 'Mevcut Değer',
                'futurePriceLabel': 'Tahmin Edilen Değer',
                'userSalePriceLabel': 'Satış Fiyatı',
                'marketSalePriceLabel': 'Mevcut Pazar Fiyatı',
                'rentRateLabel': 'Kiralama Oranı',
                'keyMetricsLabel': 'Anahtar Göstergeler',
                'priceGrowthLabel': 'Fiyat Artışı',
                'rentGrowthLabel': 'Kira Artışı',
                'avgYieldLabel': 'Ortalama Getiri',
                'totalROILabel': 'Dönem için ROI',
                'paybackPeriodLabel': 'Geri Ödeme Süresi',
                'forecastPeriodLabel': 'Tahmin Süresi',
                'yearsUnit': 'yıl',
                'monthsUnit': 'ay',
                'toYourPriceLabel': 'fiyatınıza göre',
                
                // Object comparison labels
                'vsMinMarketPriceLabel': 'vs. min. pazar fiyatı',
                'vsMaxMarketPriceLabel': 'vs. maks. pazar fiyatı',
                'vsAvgAreaLabel': 'vs. ort. alan',
                'estimatedRentLabel': 'Tahmini kira',
                
                // Analysis texts
                'marketStabilityText': 'Emlak piyasası istikrar gösteriyor',
                'marketGrowthText': 'Emlak piyasası hem satışlarda hem de kiralamalarda istikrarlı büyüme gösteriyor',
                'cheaperThanBothText': 'hem minimum hem de maksimum pazar fiyatlarından daha ucuz',
                'expensiveThanBothText': 'hem minimum hem de maksimum pazar fiyatlarından daha pahalı',
                'betweenMinMaxText': 'minimumdan pahalı ama maksimum pazar fiyatından ucuz',
                'largerAreaText': 'pazardaki çoğu mülkten daha büyük alana sahip',
                'smallerAreaText': 'pazardaki çoğu mülkten daha küçük alana sahip',
                'forecastBasedOnText': 'Tahmin temeli',
                'forecastMonthsInfo': '${months} ay (önceki + mevcut + gelecek)',
                
                // Currency and additional analysis texts
                'exchangeRateText': 'Kur',
                'fromToText': 'İtibaren',
                'byToText': 'kadar',
                'yearText': 'yılı',
                'salesPricesGrewText': 'satış fiyatları yaklaşık olarak arttı',
                'rentGrewText': 'kira —',
                'showingInvestmentAttractivenessText': 'yatırım çekiciliği gösteriyor',
                'currentTrendIndicatesText': 'Mevcut trend gösteriyor',
                'stabilityText': 'istikrar',
                'gradualIncreaseText': 'kademeli artış',
                'gradualDecreaseText': 'kademeli azalma',
                'yieldStabilityText': 'getiri, ancak olumlu dinamik devam ediyor',
                'mixedDynamicsText': 'Emlak piyasası karışık dinamik gösteriyor',
                'salesPricesGrewByText': 'Satış fiyatları arttı',
                'rentGrewByText': 'kira arttı',
                'maintainsAttractivenessText': 'yatırımcılar için çekiciliği koruyor',
                'yieldRangeText': 'aralığında kalıyor',
                'investmentPotentialText': 'yatırım potansiyelinin istikrarını gösteriyor',
                
                // Chart axis and tooltip labels
                'salePriceAxisLabel': 'Satış Fiyatı (₺/m²)',
                'rentPriceAxisLabel': 'Kiralama Fiyatı (₺/m²)',
                'salePriceTooltip': 'Satış Fiyatı',
                'rentPriceTooltip': 'Kiralama Fiyatı',
                'yourObjectLabel': 'Nesneniz',
                'andText': 've',
                
                // Chart axis labels
                'monthAxisLabel': 'Ay',
                
                // Trend types
                'priceTrendLabel': 'Fiyat Trendi',
                'yieldTrendLabel': 'Getiri Trendi',
                'countTrendLabel': 'Sayı Trendi',
                'generalTrendLabel': 'Genel Trend',
                
                // Missing additional keys
                'marketTrendsTitle': 'Piyasa Trendleri',
                'trendsFilterInfo': '${totalCount} trendden ${filteredCount} gösteriliyor',
                'linkCopied': 'Bağlantı kopyalandı!',
                'savingReport': 'Rapor kaydediliyor...',
                'errorSaving': 'Rapor kaydetme hatası',
                'marketComparisonTitle': 'Piyasa Karşılaştırması',
                'priceComparisonLabel': 'm² başına fiyat:',
                'areaComparisonLabel': 'Alan:',
                'priceCloseToMarket': 'Nesneniz (${userPrice}) piyasaya yakın (${marketMin} – ${marketMax}).',
                'priceAboveMarket': 'Nesneniz (${userPrice}) piyasadan ${percent}% yüksek.',
                'priceBelowMarket': 'Nesneniz (${userPrice}) piyasadan ${percent}% düşük.',
                'areaMatchesMarket': 'Nesneniz (${userArea} m²) piyasa talebine uygun (${marketMin}–${marketMax} m²).',
                'areaBelowMarket': 'Nesneniz (${userArea} m²) piyasa talebinden küçük (${marketMin}–${marketMax} m²).',
                'areaAboveMarket': 'Nesneniz (${userArea} m²) piyasa talebinden büyük (${marketMin}–${marketMax} m²).',
                'consolidatedAssessmentTitle': 'Konsolide Değerlendirme',
                'salePriceTitle': 'm² başına fiyat (Satış Birim Fiyatı):',
                'rentPriceTitle': 'm² başına kiralama fiyatı (Kiralama Birim Fiyatı):',
                'yieldTitle': 'Getiri:',
                'consolidatedAverageLabel': 'Konsolide ortalama:',
                'bedroomsLabel': 'Yatak Odası',
                'floorLabel': 'Kat',
                'ageLabel': 'Yaş',
                'heatingLabel': 'Isıtma',
                
                // Additional keys from second section
                'insightsTitle': 'Özet',
                'insightsLoading': 'Veriler analiz ediliyor...',
                'insightsError': 'Veri analizi hatası',
                
                // Subscription keys
                'subscriptionRequiredTitle': 'Uzun vadeli mülk değeri tahmin fonksiyonu yalnızca aktif aboneliği olan kullanıcılar için kullanılabilir.',
                'subscriptionBenefits': 'Abonelik size ne verir:',
                'subscriptionBenefit1': '12 ay öncesine kadar mülk fiyat tahmini',
                'subscriptionBenefit2': 'Ek analitik veriler',
                'subscriptionBenefit3': 'Ek servis özellikleri',
                'howToSubscribe': 'Nasıl abone olunur:',
                'subscribeInstructions': '@Aaadviser_pay_bot botuna gidin',
                'followInstructions': 'Bağlantı talimatlarını takip edin',
                'needHelp': 'Yardıma mı ihtiyacınız var?',
                'contactSupport': 'Destek ekibimizle iletişime geçin: @Aaadviser_support_bot',
                
                // Market indicators
                'saleHeader': 'Satış',
                'rentHeader': 'Kiralama',
                'indicatorLabel': 'Gösterge',
                'minValueLabel': 'Minimum değer',
                'maxValueLabel': 'Maksimum değer',
                'comparableAreaForSaleLabel': 'Karşılaştırılabilir alan',
                'countForSaleLabel': 'Satış için sayı',
                'listingPeriodForSaleLabel': 'Satışa kadar süre',
                'unitPriceForSaleLabel': 'Birim fiyat',
                'comparableAreaForRentLabel': 'Karşılaştırılabilir alan',
                'countForRentLabel': 'Kiralama için sayı',
                'listingPeriodForRentLabel': 'Kiralamaya kadar süre',
                'unitPriceForRentLabel': 'Birim fiyat',
                
                // Object summary
                'objectPricePerM2Label': 'Nesnenizin m² fiyatı:',
                'objectCurrencyLabel': 'Nesne para birimi:',
                'objectAreaLabel': 'Nesne alanı:',
                'exchangeRateLabel': 'Döviz kuru:',
                'propertyPriceLabel': 'Nesne fiyatı:',
                'propertyAreaLabel': 'Nesne alanı:',
                'saleLabel': 'Satış:',
                'rentLabel': 'Kiralama:'
            },
            'fr': {
                'slogan': 'Aperçus du marché immobilier',
                'pageTitle': 'Évaluation d\'objet',
                'pageDescription': 'Obtenez une évaluation professionnelle de propriété dans la région sélectionnée',
                'countryLabel': 'Pays :',
                'cityLabel': 'Ville :',
                'countyLabel': 'Région/Zone :',
                'districtLabel': 'District :',
                'countryPlaceholder': 'Sélectionner un pays',
                'cityPlaceholder': 'D\'abord sélectionner un pays',
                'countyPlaceholder': 'D\'abord sélectionner une ville',
                'districtPlaceholder': 'D\'abord sélectionner une région',
                'confirmButtonText': 'Confirmer la sélection',
                'backButton': '← Retour au menu principal',
                'selectedLocationTitle': 'Emplacement sélectionné :',
                'adminIdsTitle': 'IDs pour les administrateurs :',
                'loading': 'Chargement...',
                'errorLoading': 'Erreur de chargement des données',
                'dataSectionTitle': 'Analyse des données régionales',
                'generalDataTitle': 'Données générales',
                'houseTypeDataTitle': 'Données du nombre de chambres',
                'floorSegmentDataTitle': 'Données d\'étage',
                'ageDataTitle': 'Données d\'âge',
                'heatingDataTitle': 'Données du type de chauffage',
                'loadingText': 'Chargement des données...',
                'errorText': 'Erreur de chargement des données',
                'totalProperties': 'Total des propriétés :',
                'averagePrice': 'Prix moyen :',
                'priceRange': 'Fourchette de prix :',
                'noDataAvailable': 'Données non disponibles',
                'keyMetricsTitle': 'Métriques clés',
                'avgSalePriceLabel': 'Prix de vente moyen par m²',
                'avgRentPriceLabel': 'Prix de location moyen par m²',
                'listingPeriodSaleLabel': 'Période d\'inscription (vente)',
                'listingPeriodRentLabel': 'Période d\'inscription (location)',
                'yieldLabel': 'Rendement',
                'insightsTitle': 'Résumé',
                'insightsLoading': 'Analyse des données...',
                'insightsError': 'Erreur lors de l\'analyse des données',
                
                // Form elements that are missing
                'listingTypeTitle': 'Sélectionnez le type de propriété pour l\'analyse :',
                'houseTypeSubtitle': 'Nombre de chambres :',
                'floorSegmentSubtitle': 'Étage :',
                'ageDataSubtitle': 'Âge de la propriété :',
                'heatingDataSubtitle': 'Type de chauffage :',
                'priceObjectSubtitle': 'Prix de la propriété :',
                'areaObjectSubtitle': 'Surface de la propriété (m²) :',
                'currencyTitle': 'Sélectionnez la devise :',
                'pricePlaceholder': 'Entrer le prix',
                'areaPlaceholder': 'Entrer la surface',
                'selectBedrooms': 'Sélectionner le nombre de chambres',
                'selectFloor': 'Sélectionner l\'étage',
                'selectAge': 'Sélectionner l\'âge',
                'selectHeating': 'Sélectionner le type de chauffage',
                'selectPropertyType': 'Sélectionner le type de propriété',
                
                // Missing market analysis elements
                'marketAnalysisTitle': 'Analyse du marché',
                'saleAnalysisText': 'Vente : avec une surface de {area} m² (valeur moyenne pour les propriétés vendues) et un prix minimum de {minPrice}/m², la période de vente est de ~{minDays} jours ; avec un prix maximum de {maxPrice}/m² - la période de vente va jusqu\'à {maxDays} jours.',
                'rentAnalysisText': 'Location : avec une surface de {area} m² (valeur moyenne pour les propriétés louées) prix minimum {minPrice}/m², période de location ~{minDays} jours ; avec un prix maximum de {maxPrice}/m², période jusqu\'à {maxDays} jours.',
                'marketTrendsTitle': 'Tendances du marché',
                'objectSummaryTitle': 'Résumé de l\'objet',
                'propertyTypesTitle': 'Types de propriétés',
                'detailedDataTitle': 'Données détaillées (pour administrateurs uniquement)',
                'detailedTrendsDataTitle': 'Données détaillées des tendances',
                'chart_title': 'Graphique des tendances',
                'chart_info': 'Données jusqu\'au mois actuel et un mois en avance affichées',
                'forecast_chart_title': 'Graphique de prévision',
                'forecast_chart_info': 'Prévision basée sur la dynamique actuelle et est ajustée pour l\'inflation',
                
                // Chart buttons
                'sale_button': 'Prix de vente par m²',
                'rent_button': 'Prix de location par m²',
                
                // Missing property labels
                'propertyPriceLabel': 'Prix de la propriété',
                'propertyAreaLabel': 'Surface de la propriété',
                'saleLabel': 'Vente',
                'rentLabel': 'Location',
                'bedroomsLabel': 'Chambres',
                'floorLabel': 'Étage',
                'ageLabel': 'Âge',
                'heatingLabel': 'Chauffage',
                'consolidatedAverageLabel': 'Moyenne consolidée',
                
                // Missing buttons and UI elements
                'saveShareButtonText': 'Sauvegarder et partager le rapport',
                'modalTitle': 'Rapport sauvegardé',
                'modalDescription': 'Votre rapport a été sauvegardé avec succès. Vous pouvez copier le lien et le partager avec d\'autres.',
                'copyButtonText': 'Copier',
                'closeButtonText': 'Fermer',
                
                // Market indicators
                'marketIndicatorsTitle': 'Indicateurs de marché',
                'saleHeader': 'Vente',
                'rentHeader': 'Location',
                'comparableAreaForSaleLabel': 'Surface comparable',
                'comparableAreaForRentLabel': 'Surface comparable',
                'listingPeriodForSaleLabel': 'Durée d\'inscription',
                'listingPeriodForRentLabel': 'Durée d\'inscription',
                'unitPriceForSaleLabel': 'Prix unitaire',
                'unitPriceForRentLabel': 'Prix unitaire',
                
                // Units of measurement
                'unit_years': 'ans',
                'unit_days': 'jours',
                'unit_square_meters': 'm²',
                
                // Trends analysis
                'trendsAnalysisTitle': 'Analyse des tendances',
                
                // Table headers for trends
                'priceChangeLabel': 'Changement de prix',
                'yieldLabel': 'Rendement',
                'forecastSaleLabel': 'Prévision de vente',
                'forecastRentLabel': 'Prévision de location',
                'forecastYieldLabel': 'Prévision de rendement',
                'dateLabel': 'Date',
                
                // Chart labels
                'saleForecastTooltip': 'Prévision de vente',
                'rentForecastTooltip': 'Prévision de location',
                'saleForecastYAxis': 'Prévision de vente',
                'rentForecastYAxis': 'Prévision de location',
                
                // Price forecast block labels
                'priceForecastTitle': 'Prévision des prix',
                'currentPriceLabel': 'Valeur actuelle',
                'futurePriceLabel': 'Valeur prévue',
                'userSalePriceLabel': 'Prix de vente',
                'marketSalePriceLabel': 'Prix actuel du marché',
                'rentRateLabel': 'Taux de location',
                'keyMetricsLabel': 'Métriques clés',
                'priceGrowthLabel': 'Croissance des prix',
                'rentGrowthLabel': 'Croissance des loyers',
                'avgYieldLabel': 'Rendement moyen',
                'totalROILabel': 'ROI pour la période',
                'paybackPeriodLabel': 'Période de récupération',
                'forecastPeriodLabel': 'Période de prévision',
                'yearsUnit': 'ans',
                'monthsUnit': 'mois',
                'toYourPriceLabel': 'par rapport à votre prix',
                
                // Object comparison labels
                'vsMinMarketPriceLabel': 'vs. prix min. marché',
                'vsMaxMarketPriceLabel': 'vs. prix max. marché',
                'vsAvgAreaLabel': 'vs. superficie moy.',
                'estimatedRentLabel': 'Loyer estimé',
                
                // Analysis texts
                'marketStabilityText': 'Le marché immobilier démontre de la stabilité',
                'marketGrowthText': 'Le marché immobilier démontre une croissance stable dans les ventes et locations',
                'cheaperThanBothText': 'moins cher que les prix minimum et maximum du marché',
                'expensiveThanBothText': 'plus cher que les prix minimum et maximum du marché',
                'betweenMinMaxText': 'plus cher que le minimum mais moins cher que le maximum du marché',
                'largerAreaText': 'a une superficie plus grande que la plupart des propriétés sur le marché',
                'smallerAreaText': 'a une superficie plus petite que la plupart des propriétés sur le marché',
                'forecastBasedOnText': 'Prévision basée sur',
                'forecastMonthsInfo': '${months} mois (précédent + actuel + futurs)',
                
                // Currency and additional analysis texts
                'exchangeRateText': 'Taux',
                'fromToText': 'De',
                'byToText': 'à',
                'yearText': 'année',
                'salesPricesGrewText': 'les prix de vente ont augmenté d\'environ',
                'rentGrewText': 'loyers — de',
                'showingInvestmentAttractivenessText': 'montrant l\'attractivité des investissements',
                'currentTrendIndicatesText': 'La tendance actuelle indique',
                'stabilityText': 'stabilité',
                'gradualIncreaseText': 'augmentation graduelle',
                'gradualDecreaseText': 'diminution graduelle',
                'yieldStabilityText': 'du rendement, mais la dynamique positive persiste',
                'mixedDynamicsText': 'Le marché immobilier montre une dynamique mixte',
                'salesPricesGrewByText': 'Les prix de vente ont augmenté de',
                'rentGrewByText': 'les loyers ont augmenté de',
                'maintainsAttractivenessText': 'maintient l\'attractivité pour les investisseurs',
                'yieldRangeText': 'reste dans la fourchette de',
                'investmentPotentialText': 'montre la stabilité du potentiel d\'investissement',
                
                // Chart axis labels
                'monthAxisLabel': 'Mois',
                
                // Trend types
                'priceTrendLabel': 'Tendance des prix',
                'yieldTrendLabel': 'Tendance des rendements',
                'countTrendLabel': 'Tendance des quantités',
                'generalTrendLabel': 'Tendance générale',
                
                // Chart axis and tooltip labels
                'salePriceAxisLabel': 'Prix de vente (₺/m²)',
                'rentPriceAxisLabel': 'Prix de location (₺/m²)',
                'salePriceTooltip': 'Prix de vente',
                'rentPriceTooltip': 'Prix de location',
                'yourObjectLabel': 'Votre objet',
                'andText': 'et'
            }
        };

        // Get localized text
        function getText(key) {
            return locales[currentLanguage][key] || key;
        }

        // Update page text based on current language
        function updatePageText() {
            document.getElementById('slogan').textContent = getText('slogan');
            document.getElementById('pageTitle').textContent = getText('pageTitle');
            document.getElementById('pageDescription').textContent = getText('pageDescription');
            document.getElementById('countryLabel').textContent = getText('countryLabel');
            document.getElementById('cityLabel').textContent = getText('cityLabel');
            document.getElementById('countyLabel').textContent = getText('countyLabel');
            document.getElementById('districtLabel').textContent = getText('districtLabel');
            document.getElementById('countryPlaceholder').textContent = getText('countryPlaceholder');
            document.getElementById('cityPlaceholder').textContent = getText('cityPlaceholder');
            document.getElementById('countyPlaceholder').textContent = getText('countyPlaceholder');
            document.getElementById('districtPlaceholder').textContent = getText('districtPlaceholder');
            document.getElementById('confirmButtonText').textContent = getText('confirmButtonText');
            document.getElementById('backButton').textContent = getText('backButton');
            document.getElementById('selectedLocationTitle').textContent = getText('selectedLocationTitle');
            document.getElementById('adminIdsTitle').textContent = getText('adminIdsTitle');
            
            // Update new data section elements
            const dataSectionTitle = document.getElementById('dataSectionTitle');
            if (dataSectionTitle) {
                dataSectionTitle.textContent = getText('dataSectionTitle');
            }
            
            const summaryDataTitle = document.getElementById('summaryDataTitle');
            if (summaryDataTitle) {
                summaryDataTitle.textContent = getText('marketIndicatorsTitle');
            }

            const loadingText = document.getElementById('loadingText');
            if (loadingText) {
                loadingText.textContent = getText('loadingText');
            }
            
            const errorText = document.getElementById('errorText');
            if (errorText) {
                errorText.textContent = getText('errorText');
            }
            
            // Update key metrics labels
            const keyMetricsTitle = document.getElementById('keyMetricsTitle');
            if (keyMetricsTitle) {
                keyMetricsTitle.textContent = getText('keyMetricsTitle');
            }
            
            const avgSalePriceLabel = document.getElementById('avgSalePriceLabel');
            if (avgSalePriceLabel) {
                avgSalePriceLabel.textContent = getText('avgSalePriceLabel');
            }
            
            const avgRentPriceLabel = document.getElementById('avgRentPriceLabel');
            if (avgRentPriceLabel) {
                avgRentPriceLabel.textContent = getText('avgRentPriceLabel');
            }
            
            const listingPeriodSaleLabel = document.getElementById('listingPeriodSaleLabel');
            if (listingPeriodSaleLabel) {
                listingPeriodSaleLabel.textContent = getText('listingPeriodSaleLabel');
            }
            
            const listingPeriodRentLabel = document.getElementById('listingPeriodRentLabel');
            if (listingPeriodRentLabel) {
                listingPeriodRentLabel.textContent = getText('listingPeriodRentLabel');
            }
            
            const yieldLabel = document.getElementById('yieldLabel');
            if (yieldLabel) {
                yieldLabel.textContent = getText('yieldLabel');
            }
            

            
            // Update listing type selection elements
            const listingTypeTitle = document.getElementById('listingTypeTitle');
            if (listingTypeTitle) { listingTypeTitle.textContent = getText('listingTypeTitle'); }
            const houseTypeSubtitle = document.getElementById('houseTypeSubtitle');
            if (houseTypeSubtitle) { houseTypeSubtitle.textContent = getText('houseTypeSubtitle'); }
            const floorSegmentSubtitle = document.getElementById('floorSegmentSubtitle');
            if (floorSegmentSubtitle) { floorSegmentSubtitle.textContent = getText('floorSegmentSubtitle'); }
            const ageDataSubtitle = document.getElementById('ageDataSubtitle');
            if (ageDataSubtitle) { ageDataSubtitle.textContent = getText('ageDataSubtitle'); }
            const heatingDataSubtitle = document.getElementById('heatingDataSubtitle');
            if (heatingDataSubtitle) { heatingDataSubtitle.textContent = getText('heatingDataSubtitle'); }
            
            // Update new fields
            const priceObjectSubtitle = document.getElementById('priceObjectSubtitle');
            if (priceObjectSubtitle) { priceObjectSubtitle.textContent = getText('priceObjectSubtitle'); }
            const areaObjectSubtitle = document.getElementById('areaObjectSubtitle');
            if (areaObjectSubtitle) { areaObjectSubtitle.textContent = getText('areaObjectSubtitle'); }
            
            // Update currency title
            const currencyTitle = document.getElementById('currencyTitle');
            if (currencyTitle) { currencyTitle.textContent = getText('currencyTitle'); }
            
            // Update placeholders
            const priceObjectInput = document.getElementById('priceObjectInput');
            if (priceObjectInput) { priceObjectInput.placeholder = getText('pricePlaceholder'); }
            const areaObjectInput = document.getElementById('areaObjectInput');
            if (areaObjectInput) { areaObjectInput.placeholder = getText('areaPlaceholder'); }
            
            // Update placeholder texts
            const houseTypePlaceholder = document.getElementById('houseTypePlaceholder');
            if (houseTypePlaceholder) { houseTypePlaceholder.textContent = getText('selectBedrooms'); }
            const floorSegmentPlaceholder = document.getElementById('floorSegmentPlaceholder');
            if (floorSegmentPlaceholder) { floorSegmentPlaceholder.textContent = getText('selectFloor'); }
            const ageDataPlaceholder = document.getElementById('ageDataPlaceholder');
            if (ageDataPlaceholder) { ageDataPlaceholder.textContent = getText('selectAge'); }
            const heatingDataPlaceholder = document.getElementById('heatingDataPlaceholder');
            if (heatingDataPlaceholder) { heatingDataPlaceholder.textContent = getText('selectHeating'); }
            
            // Update property types section
            const propertyTypesTitle = document.getElementById('propertyTypesTitle');
            if (propertyTypesTitle) { propertyTypesTitle.textContent = getText('propertyTypesTitle'); }
            
            // Update detailed data table titles
            const detailedDataTitles = document.querySelectorAll('.detailed-data-title');
            detailedDataTitles.forEach(titleElement => {
                const titleText = titleElement.textContent;
                if (titleText.includes('количество спален') || titleText.includes('Bedroom Count') || titleText.includes('Schlafzimmer') || titleText.includes('chambres') || titleText.includes('Yatak Odası')) {
                    titleElement.textContent = getText('houseTypeDataTitle');
                } else if (titleText.includes('этажу') || titleText.includes('Floor') || titleText.includes('Etagen') || titleText.includes('étage') || titleText.includes('Kat')) {
                    titleElement.textContent = getText('floorSegmentDataTitle');
                } else if (titleText.includes('возрасту') || titleText.includes('Age') || titleText.includes('Alters') || titleText.includes('âge') || titleText.includes('Yaş')) {
                    titleElement.textContent = getText('ageDataTitle');
                } else if (titleText.includes('отопления') || titleText.includes('Heating') || titleText.includes('Heizung') || titleText.includes('chauffage') || titleText.includes('Isıtma')) {
                    titleElement.textContent = getText('heatingDataTitle');
                }
            });
            
            // Update save and share elements
            const saveShareButtonText = document.getElementById('saveShareButtonText');
            if (saveShareButtonText) {
                saveShareButtonText.textContent = getText('saveShareButtonText');
            }
            
            const modalTitle = document.getElementById('modalTitle');
            if (modalTitle) {
                modalTitle.textContent = getText('modalTitle');
            }
            
            const modalDescription = document.getElementById('modalDescription');
            if (modalDescription) {
                modalDescription.textContent = getText('modalDescription');
            }
            
            const copyButtonText = document.getElementById('copyButtonText');
            if (copyButtonText) {
                copyButtonText.textContent = getText('copyButtonText');
            }
            
            const closeButtonText = document.getElementById('closeButtonText');
            if (closeButtonText) {
                closeButtonText.textContent = getText('closeButtonText');
            }
            
            // Update report options elements
            const reportOptionsTitle = document.getElementById('reportOptions');
            if (reportOptionsTitle) {
                const titleElement = reportOptionsTitle.querySelector('.report-options-title');
                if (titleElement) {
                    titleElement.textContent = getText('reportOptionsTitle');
                }
            }
            
            const includeRealtorInfo = document.querySelector('#includeRealtorInfo + .checkbox-label');
            if (includeRealtorInfo) {
                includeRealtorInfo.textContent = getText('includeRealtorInfo');
            }
            
            const includePropertyInfo = document.querySelector('#includePropertyInfo + .checkbox-label');
            if (includePropertyInfo) {
                includePropertyInfo.textContent = getText('includePropertyInfo');
            }
        }

        // Load countries from API
        async function loadCountries() {
            try {
                const response = await fetch('/api/locations/countries');
                const data = await response.json();
                
                if (data.success) {
                    const countrySelect = document.getElementById('countrySelect');
                    countrySelect.innerHTML = `<option value="">${getText('countryPlaceholder')}</option>`;
                    
                    data.countries.forEach(([id, name]) => {
                        const option = document.createElement('option');
                        option.value = id;
                        option.textContent = name;
                        countrySelect.appendChild(option);
                    });
                } else {
                    console.error('Failed to load countries:', data.error);
                }
            } catch (error) {
                console.error('Error loading countries:', error);
            }
        }

        // Load cities based on selected country
        async function loadCities(countryId) {
            try {
                const response = await fetch('/api/locations/cities', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ country_id: countryId })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    const citySelect = document.getElementById('citySelect');
                    citySelect.innerHTML = `<option value="">${getText('cityPlaceholder')}</option>`;
                    
                    data.cities.forEach(([id, name]) => {
                        const option = document.createElement('option');
                        option.value = id;
                        option.textContent = name;
                        citySelect.appendChild(option);
                    });
                    
                    citySelect.disabled = false;
                } else {
                    console.error('Failed to load cities:', data.error);
                }
            } catch (error) {
                console.error('Error loading cities:', error);
            }
        }

        // Load counties based on selected city
        async function loadCounties(cityId) {
            try {
                const response = await fetch('/api/locations/counties', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ city_id: cityId })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    const countySelect = document.getElementById('countySelect');
                    countySelect.innerHTML = `<option value="">${getText('countyPlaceholder')}</option>`;
                    
                    data.counties.forEach(([id, name]) => {
                        const option = document.createElement('option');
                        option.value = id;
                        option.textContent = name;
                        countySelect.appendChild(option);
                    });
                    
                    countySelect.disabled = false;
                } else {
                    console.error('Failed to load cities:', data.error);
                }
            } catch (error) {
                console.error('Error loading cities:', error);
            }
        }

        // Load available listing types for each data category
        async function loadListingTypes() {
            try {
                console.log('🔄 Loading available listing_type for selected location...');
                
                // Get current location values
                const countrySelect = document.getElementById('countrySelect');
                const citySelect = document.getElementById('citySelect');
                const countySelect = document.getElementById('countySelect');
                const districtSelect = document.getElementById('districtSelect');
                
                // Check if all required location fields are filled
                if (!countrySelect.value || !citySelect.value || !countySelect.value) {
                    console.log('❌ Not all required location fields are filled, skipping listing_type loading');
                    return;
                }
                
                const locationData = {
                    country_id: countrySelect.value,
                    city_id: citySelect.value,
                    county_id: countySelect.value,
                    district_id: districtSelect.value || 'none'
                };
                
                console.log('📍 Location data for listing types:', locationData);
                
                // Load house type listing types
                const houseTypeResponse = await fetch('/api/listing_types/house_type_data', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(locationData)
                });
                const houseTypeData = await houseTypeResponse.json();
                if (houseTypeData.success) {
                    console.log('✅ House type listing types loaded:', houseTypeData.listing_types);
                    populateListingTypeSelect('houseTypeSelect', houseTypeData.listing_types, 'house_type');
                } else {
                    console.error('❌ Failed to load house type listing types:', houseTypeData.error);
                }

                // Load floor segment listing types
                const floorSegmentResponse = await fetch('/api/listing_types/floor_segment_data', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(locationData)
                });
                const floorSegmentData = await floorSegmentResponse.json();
                if (floorSegmentData.success) {
                    console.log('✅ Floor segment listing types loaded:', floorSegmentData.listing_types);
                    populateListingTypeSelect('floorSegmentSelect', floorSegmentData.listing_types, 'floor_segment');
                } else {
                    console.error('❌ Failed to load floor segment listing types:', floorSegmentData.error);
                }

                // Load age data listing types
                const ageDataResponse = await fetch('/api/listing_types/age_data', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(locationData)
                });
                const ageDataData = await ageDataResponse.json();
                if (ageDataData.success) {
                    console.log('✅ Age data listing types loaded:', ageDataData.listing_types);
                    populateListingTypeSelect('ageDataSelect', ageDataData.listing_types, 'age');
                } else {
                    console.error('❌ Failed to load age data listing types:', ageDataData.error);
                }

                // Load heating data listing types
                const heatingDataResponse = await fetch('/api/listing_types/heating_data', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(locationData)
                });
                const heatingDataData = await heatingDataResponse.json();
                if (heatingDataData.success) {
                    console.log('✅ Heating data listing types loaded:', heatingDataData.listing_types);
                    populateListingTypeSelect('heatingDataSelect', heatingDataData.listing_types, 'heating');
                } else {
                    console.error('❌ Failed to load heating data listing types:', heatingDataData.error);
                }
                
                console.log('✅ All listing_type loaded for selected location');
                
                // Load property trends for the selected location
                const trendsLocationData = {
                    country_id: document.getElementById('countrySelect').value,
                    city_id: document.getElementById('citySelect').value,
                    county_id: document.getElementById('countySelect').value,
                    district_id: document.getElementById('districtSelect').value || 'none'
                };
                loadPropertyTrends(trendsLocationData);
            } catch (error) {
                console.error('❌ Error loading listing types:', error);
            }
        }

        // Populate listing type select with options
        function populateListingTypeSelect(selectId, listingTypes, category) {
            const select = document.getElementById(selectId);
            if (!select) {
                console.error(`❌ Select element not found: ${selectId}`);
                return;
            }

            console.log(`🔄 Populating select ${selectId} with ${listingTypes.length} types for category ${category}:`, listingTypes);
            
            // Clear existing options except the first placeholder
            select.innerHTML = '<option value="">' + getSelectPlaceholder(category) + '</option>';
            
            listingTypes.forEach(type => {
                const option = document.createElement('option');
                option.value = type;
                option.textContent = type;
                select.appendChild(option);
            });
            
            // Add change event listener
            select.onchange = () => selectListingType(category, select.value);
            
            console.log(`✅ Select ${selectId} populated with ${listingTypes.length} items`);
        }
        
        // Get placeholder text for select dropdowns
        function getSelectPlaceholder(category) {
            const placeholders = {
                'house_type': getText('selectBedrooms'),
                'floor_segment': getText('selectFloor'),
                'age': getText('selectAge'),
                'heating': getText('selectHeating')
            };
            return placeholders[category] || getText('selectPropertyType');
        }

        // Reset listing type selection
        function resetListingTypeSelection() {
            selectedListingTypes = {
                house_type: null,
                floor_segment: null,
                age: null,
                heating: null,
                price: null,
                currency: 'EUR',
                area: 50
            };
            
            // Hide listing type section
            const listingTypeSection = document.getElementById('listingTypeSection');
            if (listingTypeSection) {
                listingTypeSection.style.display = 'none';
            }
            
            // Reset all select dropdowns
            const selects = ['houseTypeSelect', 'floorSegmentSelect', 'ageDataSelect', 'heatingDataSelect'];
            selects.forEach(selectId => {
                const select = document.getElementById(selectId);
                if (select) {
                    select.value = '';
                }
            });
            
            // Reset price and area fields
            const priceInput = document.getElementById('priceObjectInput');
            const areaInput = document.getElementById('areaObjectInput');
            
            if (priceInput) priceInput.value = '';
            if (areaInput) areaInput.value = '';
            
            // Reset currency buttons
            const currencyButtons = document.querySelectorAll('.currency-button');
            currencyButtons.forEach(button => {
                button.classList.remove('active');
            });
            // Set EUR as default active
            const eurButton = document.querySelector('.currency-button[data-currency="EUR"]');
            if (eurButton) {
                eurButton.classList.add('active');
                selectedListingTypes.currency = 'EUR';
            }
            
            // Hide selected property types section
            const selectedPropertyTypes = document.getElementById('selectedPropertyTypes');
            if (selectedPropertyTypes) {
                selectedPropertyTypes.style.display = 'none';
            }
        }

        // Handle listing type selection
        function selectListingType(category, type) {
            console.log(`🎯 Selecting listing type: ${category} = ${type}`);
            
            if (type && type !== '') {
                selectedListingTypes[category] = type;
                console.log(`✅ Selected: ${category} = ${type}`);
            } else {
                selectedListingTypes[category] = null;
                console.log(`❌ Deselected: ${category}`);
            }
            
            // Update the display of selected property types
            updateSelectedPropertyTypesDisplay();
            
            // Очищаем кэш при изменении параметров объекта
            clearTrendsCalculationCache();
            
            updateConfirmButton();
            
            // Check if all listing types are selected
            const allTypesSelected = selectedListingTypes.house_type && 
                                   selectedListingTypes.floor_segment && 
                                   selectedListingTypes.age && 
                                   selectedListingTypes.heating &&
                                   selectedListingTypes.price &&
                                   selectedListingTypes.area;
            
            console.log('🔍 All listing types selected:', allTypesSelected, selectedListingTypes);
            
            // If all types are selected, automatically load region data
            if (allTypesSelected) {
                console.log('🚀 All listing types selected, automatically loading region data...');
                // Small delay to ensure UI updates are complete
                setTimeout(() => {
                    confirmLocation();
                }, 100);
            }
        }

        // Load districts based on selected county
        async function loadDistricts(countyId) {
            console.log('🔄 Loading districts for county_id:', countyId);
            
            try {
                const response = await fetch('/api/locations/districts', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ county_id: countyId })
                });
                
                const data = await response.json();
                console.log('📊 Districts API response:', data);
                
                if (data.success) {
                    const districtSelect = document.getElementById('districtSelect');
                    districtSelect.innerHTML = `<option value="">${getText('districtPlaceholder')}</option>`;
                    
                    // Add "не имеет значения" option
                    const noDistrictOption = document.createElement('option');
                    noDistrictOption.value = 'none';
                    noDistrictOption.textContent = 'Не имеет значения';
                    districtSelect.appendChild(noDistrictOption);
                    
                    console.log('📍 Adding districts:', data.districts);
                    data.districts.forEach(([id, name]) => {
                        const option = document.createElement('option');
                        option.value = id;
                        option.textContent = name;
                        districtSelect.appendChild(option);
                    });
                    
                    districtSelect.disabled = false;
                    console.log('✅ Districts loaded, district select enabled');
                } else {
                    console.error('❌ Failed to load districts:', data.error);
                }
            } catch (error) {
                console.error('❌ Error loading districts:', error);
            }
        }

        // Event handlers for location changes
        function onCountryChange() {
            const countrySelect = document.getElementById('countrySelect');
            const citySelect = document.getElementById('citySelect');
            const countySelect = document.getElementById('countySelect');
            const districtSelect = document.getElementById('districtSelect');
            
            const countryId = countrySelect.value;
            
            // Reset dependent selects
            citySelect.innerHTML = `<option value="">${getText('cityPlaceholder')}</option>`;
            citySelect.disabled = true;
            countySelect.innerHTML = `<option value="">${getText('countyPlaceholder')}</option>`;
            countySelect.disabled = true;
            districtSelect.innerHTML = `<option value="">${getText('districtPlaceholder')}</option>`;
            districtSelect.disabled = true;
            
            // Reset listing type selection and hide section
            resetListingTypeSelection();
            const listingTypeSection = document.getElementById('listingTypeSection');
            if (listingTypeSection) {
                listingTypeSection.style.display = 'none';
            }
            
            // Clear existing property trends
            clearPropertyTrends();
            
            if (countryId) {
                loadCities(countryId);
            }
            
            updateConfirmButton();
        }

        function onCityChange() {
            const citySelect = document.getElementById('citySelect');
            const countySelect = document.getElementById('countySelect');
            const districtSelect = document.getElementById('districtSelect');
            
            const cityId = citySelect.value;
            
            // Reset dependent selects
            countySelect.innerHTML = `<option value="">${getText('countyPlaceholder')}</option>`;
            countySelect.disabled = true;
            districtSelect.innerHTML = `<option value="">${getText('districtPlaceholder')}</option>`;
            districtSelect.disabled = true;
            
            // Reset listing type selection and hide section
            resetListingTypeSelection();
            const listingTypeSection = document.getElementById('listingTypeSection');
            if (listingTypeSection) {
                listingTypeSection.style.display = 'none';
            }
            
            // Clear existing property trends
            clearPropertyTrends();
            
            if (cityId) {
                loadCounties(cityId);
            }
            
            updateConfirmButton();
        }

        function onCountyChange() {
            console.log('🔄 County changed, starting onCountyChange function...');
            
            const countySelect = document.getElementById('countySelect');
            const districtSelect = document.getElementById('districtSelect');
            
            const countyId = countySelect.value;
            console.log('📍 Selected county_id:', countyId);
            
            // Reset dependent selects
            districtSelect.innerHTML = `<option value="">${getText('districtPlaceholder')}</option>`;
            districtSelect.disabled = true;
            console.log('🔄 Reset district select');
            
            // Reset listing type selection and hide section
            resetListingTypeSelection();
            const listingTypeSection = document.getElementById('listingTypeSection');
            if (listingTypeSection) {
                listingTypeSection.style.display = 'none';
            }
            
            // Clear existing property trends
            clearPropertyTrends();
            
            if (countyId) {
                console.log('✅ County selected, loading districts for county_id:', countyId);
                loadDistricts(countyId);
            } else {
                console.log('❌ No county selected');
            }
            
            updateConfirmButton();
        }

        function onDistrictChange() {
            console.log('🔄 District changed, updating confirm button...');
            updateConfirmButton();
            
            // Show listing type selection section when district is selected
            const districtSelect = document.getElementById('districtSelect');
            const listingTypeSection = document.getElementById('listingTypeSection');
            
            console.log('📍 District value:', districtSelect.value);
            
            if (districtSelect.value && districtSelect.value !== 'none') {
                console.log('✅ District selected, showing listing type section and loading types...');
                listingTypeSection.style.display = 'block';
                // Load available listing types for the selected location
                loadListingTypes();
                
                // Load property trends for the new location
                const districtLocationData = {
                    country_id: document.getElementById('countrySelect').value,
                    city_id: document.getElementById('citySelect').value,
                    county_id: document.getElementById('countySelect').value,
                    district_id: districtSelect.value
                };
                loadPropertyTrends(districtLocationData);
            } else {
                console.log('❌ No district selected, hiding listing type section...');
                listingTypeSection.style.display = 'none';
                // Reset listing type selection when district is cleared
                resetListingTypeSelection();
                // Clear existing property trends
                clearPropertyTrends();
            }
        }

        // Update selected property types display
        function updateSelectedPropertyTypesDisplay() {
            const selectedPropertyTypes = document.getElementById('selectedPropertyTypes');
            const propertyTypesDetails = document.getElementById('propertyTypesDetails');
            
            if (!selectedPropertyTypes || !propertyTypesDetails) return;
            
            // Check if any property types are selected
            const hasSelectedTypes = selectedListingTypes.house_type || 
                                   selectedListingTypes.floor_segment || 
                                   selectedListingTypes.age || 
                                   selectedListingTypes.heating ||
                                   selectedListingTypes.price ||
                                   selectedListingTypes.area;
            
            if (hasSelectedTypes) {
                selectedPropertyTypes.style.display = 'block';
                
                let html = '';
                
                if (selectedListingTypes.house_type) {
                    html += `
                        <div class="property-type-item">
                            <span class="property-type-label">${getText('bedroomsLabel')}:</span>
                            <span class="property-type-value">${selectedListingTypes.house_type}</span>
                        </div>
                    `;
                }
                
                if (selectedListingTypes.floor_segment) {
                    html += `
                        <div class="property-type-item">
                            <span class="property-type-label">${getText('floorLabel')}:</span>
                            <span class="property-type-value">${selectedListingTypes.floor_segment}</span>
                        </div>
                    `;
                }
                
                if (selectedListingTypes.age) {
                    html += `
                        <div class="property-type-item">
                            <span class="property-type-label">${getText('ageLabel')}:</span>
                            <span class="property-type-value">${selectedListingTypes.age}</span>
                        </div>
                    `;
                }
                
                if (selectedListingTypes.heating) {
                    html += `
                        <div class="property-type-item">
                            <span class="property-type-label">${getText('heatingLabel')}:</span>
                            <span class="property-type-value">${selectedListingTypes.heating}</span>
                        </div>
                    `;
                }
                
                if (selectedListingTypes.price) {
                    const currencySymbols = {
                        'TRY': '₺',
                        'EUR': '€',
                        'USD': '$'
                    };
                    const currencySymbol = currencySymbols[selectedListingTypes.currency] || '';
                    html += `
                        <div class="property-type-item">
                            <span class="property-type-label">${getText('propertyPriceLabel')}</span>
                            <span class="property-type-value">${currencySymbol}${selectedListingTypes.price}</span>
                        </div>
                    `;
                }
                
                if (selectedListingTypes.area) {
                    html += `
                        <div class="property-type-item">
                            <span class="property-type-label">${getText('propertyAreaLabel')}</span>
                            <span class="property-type-value">${selectedListingTypes.area} ${getText('unit_square_meters')}</span>
                        </div>
                    `;
                }
                
                propertyTypesDetails.innerHTML = html;
            } else {
                selectedPropertyTypes.style.display = 'none';
            }
        }

        // Update confirm button state
        function updateConfirmButton() {
            const countrySelect = document.getElementById('countrySelect');
            const citySelect = document.getElementById('citySelect');
            const countySelect = document.getElementById('countySelect');
            const districtSelect = document.getElementById('districtSelect');
            const confirmButton = document.getElementById('confirmButton');
            
            const hasCountry = countrySelect.value;
            const hasCity = citySelect.value;
            const hasCounty = countySelect.value;
            const hasDistrict = districtSelect.value && districtSelect.value !== '';
            
            // Check if all listing types are selected (only if district is selected and not "none")
            let hasAllListingTypes = true;
            if (hasDistrict && districtSelect.value !== 'none') {
                hasAllListingTypes = selectedListingTypes.house_type && 
                                   selectedListingTypes.floor_segment && 
                                   selectedListingTypes.age && 
                                   selectedListingTypes.heating &&
                                   selectedListingTypes.price &&
                                   selectedListingTypes.area;
                
                console.log('🔍 Checking listing types:', {
                    house_type: selectedListingTypes.house_type,
                    floor_segment: selectedListingTypes.floor_segment,
                    age: selectedListingTypes.age,
                    heating: selectedListingTypes.heating,
                    price: selectedListingTypes.price,
                    area: selectedListingTypes.area,
                    hasAllListingTypes: hasAllListingTypes
                });
            }
            
            // Button is enabled if all location fields are filled
            // For listing types: if district is "none", no listing types required
            // If district is selected, all listing types are required
            const isDisabled = !(hasCountry && hasCity && hasCounty && hasDistrict) || 
                              (hasDistrict && districtSelect.value !== 'none' && !hasAllListingTypes);
            
            confirmButton.disabled = isDisabled;
            
            console.log('🔘 Confirm button state:', {
                hasCountry, hasCity, hasCounty, hasDistrict,
                districtValue: districtSelect.value,
                hasAllListingTypes,
                isDisabled
            });
        }

        // Confirm location selection
        async function confirmLocation() {
            console.log('🎯 confirmLocation function called');
            
            const countrySelect = document.getElementById('countrySelect');
            const citySelect = document.getElementById('citySelect');
            const countySelect = document.getElementById('countySelect');
            const districtSelect = document.getElementById('districtSelect');
            
            const countryId = countrySelect.value;
            const cityId = citySelect.value;
            const countyId = countySelect.value;
            const districtId = districtSelect.value === 'none' ? null : districtSelect.value;
            
            // Get names for display
            const countryName = countrySelect.options[countrySelect.selectedIndex].text;
            const cityName = citySelect.options[citySelect.selectedIndex].text;
            const countyName = countySelect.options[countySelect.selectedIndex].text;
            const districtName = districtSelect.value === 'none' ? 'Не имеет значения' : districtSelect.options[districtSelect.selectedIndex].text;
            
            // Convert price to EUR if needed
            let priceInEUR = null;
            if (selectedListingTypes.price && selectedListingTypes.currency !== 'EUR') {
                priceInEUR = await convertToEUR(selectedListingTypes.price, selectedListingTypes.currency);
                console.log(`💰 Price converted: ${selectedListingTypes.price} ${selectedListingTypes.currency} → ${priceInEUR} EUR`);
            } else if (selectedListingTypes.price) {
                priceInEUR = selectedListingTypes.price;
            }
            
            // Update selected location
            selectedLocation = {
                country_id: countryId,
                city_id: cityId,
                county_id: countyId,
                district_id: districtId,
                country_name: countryName,
                city_name: cityName,
                county_name: countyName,
                district_name: districtName,
                // Add property details
                property_price: selectedListingTypes.price,
                property_price_currency: selectedListingTypes.currency,
                property_price_eur: priceInEUR,
                property_area: selectedListingTypes.area
            };
            
            // Очищаем кэш расчетов при изменении локации
            clearTrendsCalculationCache();
            
            console.log('📍 Selected location for data loading:', {
                country_id: countryId,
                city_id: cityId,
                county_id: countyId,
                district_id: districtId,
                country_name: countryName,
                city_name: cityName,
                county_name: countyName,
                district_name: districtName,
                property_price: selectedListingTypes.price,
                property_price_currency: selectedListingTypes.currency,
                property_price_eur: priceInEUR,
                property_area: selectedListingTypes.area
            });
            
            // Display selected location
            displaySelectedLocation();
            
            // Get user language
            await getUserLanguage();
            
            // Load region data with selected listing types
            await loadRegionData();
        }

        // Display selected location
        // Check and display admin IDs if user is admin
        async function checkAndDisplayAdminIds(adminIdsBlock, adminIdsDetails) {
            try {
                if (window.Telegram && window.Telegram.WebApp && window.Telegram.WebApp.initDataUnsafe && window.Telegram.WebApp.initDataUnsafe.user) {
                    const user = window.Telegram.WebApp.initDataUnsafe.user;
                    if (user && user.id) {
                        // Check if user is admin via API
                        const response = await fetch('/api/check_admin_status', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({ telegram_id: user.id })
                        });
                        
                        if (response.ok) {
                            const data = await response.json();
                            if (data.success && data.is_admin) {
                                // User is admin, show admin IDs
                                adminIdsDetails.innerHTML = `
                                    country_id: ${selectedLocation.country_id}<br>
                                    city_id: ${selectedLocation.city_id}<br>
                                    county_id: ${selectedLocation.county_id}<br>
                                    district_id: ${selectedLocation.district_id || 'null'}
                                `;
                                adminIdsBlock.style.display = 'block';
                                return;
                            }
                        }
                    }
                }
                
                // Hide admin IDs block if user is not admin
                adminIdsBlock.style.display = 'none';
            } catch (error) {
                console.error('Error checking admin status:', error);
                // Hide admin IDs block on error
                adminIdsBlock.style.display = 'none';
            }
        }

        // Display selected location
        async function displaySelectedLocation() {
            const selectedLocationDiv = document.getElementById('selectedLocation');
            const locationDetails = document.getElementById('locationDetails');
            const adminIdsBlock = document.getElementById('adminIdsBlock');
            const adminIdsDetails = document.getElementById('adminIdsDetails');
            
            // Build location string
            let locationString = selectedLocation.country_name;
            if (selectedLocation.city_name) {
                locationString += `, ${selectedLocation.city_name}`;
            }
            if (selectedLocation.county_name) {
                locationString += `, ${selectedLocation.county_name}`;
            }
            if (selectedLocation.district_name && selectedLocation.district_name !== 'Не имеет значения') {
                locationString += `, ${selectedLocation.district_name}`;
            }
            
            locationDetails.textContent = locationString;
            
            // Update selected property types display
            updateSelectedPropertyTypesDisplay();
            
            // Check if user is admin and show admin IDs block
            await checkAndDisplayAdminIds(adminIdsBlock, adminIdsDetails);
            
            selectedLocationDiv.style.display = 'block';
        }

        // Get user language
        async function getUserLanguage() {
            try {
                if (window.Telegram && window.Telegram.WebApp && window.Telegram.WebApp.initDataUnsafe && window.Telegram.WebApp.initDataUnsafe.user) {
                    const user = window.Telegram.WebApp.initDataUnsafe.user;
                    if (user && user.id) {
                        const response = await fetch('/api/user/language', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({ 
                                telegram_id: user.id,
                                language_code: user.language_code
                            })
                        });
                        
                        const data = await response.json();
                        if (data.success) {
                            userLanguage = data.language;
                            currentLanguage = data.language;
                            console.log(`🌐 User language loaded: ${userLanguage} (status: ${data.user_status})`);
                            updatePageText();
                        }
                    }
                }
            } catch (error) {
                console.error('Error getting user language:', error);
            }
        }

        // Load region data
        async function loadRegionData() {
            console.log('🚀 loadRegionData function called');
            
            try {
                const requestBody = {
                    country_id: selectedLocation.country_id,
                    city_id: selectedLocation.city_id,
                    county_id: selectedLocation.county_id,
                    district_id: selectedLocation.district_id,
                    listing_types: selectedListingTypes
                };
                
                console.log('🔄 Loading region data with request:', requestBody);
                
                const response = await fetch('/api/region_data', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestBody)
                });
                
                const data = await response.json();
                
                console.log('📊 API response:', data);
                
                if (data.success) {
                    displayRegionData(data);
                } else {
                    throw new Error(data.error || 'Failed to load region data');
                }
            } catch (error) {
                console.error('Error loading region data:', error);
                showError('Ошибка загрузки данных региона');
            }
        }

        // Display region data
        function displayRegionData(data) {
            console.log('📊 Processing received data:', data);
            console.log('🔍 Data structure:', {
                hasGeneralData: !!data.general_data,
                hasHouseTypeData: !!data.house_type_data,
                hasFloorSegmentData: !!data.floor_segment_data,
                hasAgeData: !!data.age_data,
                hasHeatingData: !!data.heating_data
            });
            
            // Try different possible key names for data
            const generalData = data.general_data || data.generalData || data.general || [];
            const houseTypeData = data.house_type_data || data.houseTypeData || data.house_types || data.houseTypes || [];
            const floorSegmentData = data.floor_segment_data || data.floorSegmentData || data.floor_segments || data.floorSegments || [];
            const ageData = data.age_data || data.ageData || data.ages || [];
            const heatingData = data.heating_data || data.heatingData || data.heating || [];
            
            console.log('🔍 Extracted data arrays:', {
                general: generalData.length,
                houseType: houseTypeData.length,
                floorSegment: floorSegmentData.length,
                age: ageData.length,
                heating: heatingData.length
            });
            
            // Data sections removed - only market indicators table is shown
            
            // Generate and display summary table
            generateSummaryTable(data);
            
            // Show data content
            document.getElementById('dataContent').style.display = 'block';
            
            // Show save button after data is loaded
            await showSaveButton();
        }









        // Format field name
        function formatFieldName(field) {
            // Convert snake_case to readable text
            return field.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
        }

        // Get localized field label
        function getFieldLabel(field, type) {
            const fieldLabels = {
                'comparable_area_for_sale': 'comparableAreaForSaleLabel',
                'listing_period_for_sale': 'listingPeriodForSaleLabel',
                'unit_price_for_sale': 'unitPriceForSaleLabel',
                'comparable_area_for_rent': 'comparableAreaForRentLabel',
                'listing_period_for_rent': 'listingPeriodForRentLabel',
                'unit_price_for_rent': 'unitPriceForRentLabel'
            };
            
            const labelKey = fieldLabels[field];
            return labelKey ? getText(labelKey) : formatFieldName(field);
        }

        // Format field value
        function formatFieldValue(value, field) {
            if (value === null || value === undefined) return '-';
            
            // Format based on field type
            if (typeof value === 'number') {
                if (field.includes('price') || field.includes('Price')) {
                    return formatValue(value, 'price');
                } else if (field.includes('yield') || field.includes('Yield')) {
                    // For yield, don't multiply by 100, just add % symbol
                    return `${parseFloat(value).toFixed(2)}%`;
                } else if (field.includes('rate')) {
                    return formatValue(value, 'percentage');
                } else if (field.includes('period') || field.includes('Period')) {
                    return formatValue(value, 'days');
                } else if (field.includes('area') || field.includes('Area')) {
                    return `${value} м²`;
                } else {
                    return value.toLocaleString();
                }
            }
            
            return value.toString();
        }

        // Format value based on type
        function formatValue(value, type) {
            if (value === null || value === undefined || value === '-') return '-';
            
            switch (type) {
                case 'price':
                    return `₺${parseFloat(value).toLocaleString('tr-TR', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
                case 'percentage':
                    return `${parseFloat(value).toFixed(2)}%`;
                case 'days':
                    return `${value} дней`;
                default:
                    return value.toString();
            }
        }

        // Generate market comparison block
        function generateMarketComparison(summary) {
            // Get user's object data
            const userPrice = selectedListingTypes.price || 0;
            const userArea = selectedListingTypes.area || 0;
            const userCurrency = selectedListingTypes.currency || 'EUR';
            
            if (!userPrice || !userArea) {
                return '';
            }
            
            // Calculate user's price per m²
            const userPricePerM2 = userPrice / userArea;
            
            // Get market data for comparison
            const marketPricePerM2 = summary.min_unit_price_for_sale;
            const marketArea = summary.comparable_area_for_sale;
            
            if (!marketPricePerM2 || !marketArea) {
                return '';
            }
            
            // Determine target currency based on country
            const targetCurrency = getCurrentCountry() === 'Turkey' ? 'TRY' : 'EUR';
            
            // Convert user's price to target currency for comparison
            let userPriceInTargetCurrency = userPricePerM2;
            if (userCurrency !== targetCurrency) {
                // Use the same conversion logic as in price forecast
                const conversionRate = getCurrencyRate(userCurrency, targetCurrency);
                userPriceInTargetCurrency = userPricePerM2 * conversionRate;
            }
            
            // Calculate price comparison
            const priceDifference = userPriceInTargetCurrency - marketPricePerM2.min;
            const priceDifferencePercent = marketPricePerM2.min > 0 ? (priceDifference / marketPricePerM2.min * 100) : 0;
            
            // Calculate area comparison
            const areaDifference = userArea - marketArea.min;
            const areaDifferencePercent = marketArea.min > 0 ? (areaDifference / marketArea.min * 100) : 0;
            
            // Generate comparison text
            let comparisonText = '';
            
            // Price comparison
            if (Math.abs(priceDifferencePercent) < 5) {
                comparisonText += `<p><strong>${getText('priceComparisonLabel')}</strong> ${getText('priceCloseToMarket').replace('${userPrice}', formatValue(userPriceInTargetCurrency, 'price')).replace('${marketMin}', formatValue(marketPricePerM2.min, 'price')).replace('${marketMax}', formatValue(marketPricePerM2.max, 'price'))}</p>`;
            } else if (priceDifferencePercent > 0) {
                comparisonText += `<p><strong>${getText('priceComparisonLabel')}</strong> ${getText('priceAboveMarket').replace('${userPrice}', formatValue(userPriceInTargetCurrency, 'price')).replace('${percent}', Math.abs(priceDifferencePercent).toFixed(1))}</p>`;
            } else {
                comparisonText += `<p><strong>${getText('priceComparisonLabel')}</strong> ${getText('priceBelowMarket').replace('${userPrice}', formatValue(userPriceInTargetCurrency, 'price')).replace('${percent}', Math.abs(priceDifferencePercent).toFixed(1))}</p>`;
            }
            
            // Area comparison
            if (userArea >= marketArea.min && userArea <= marketArea.max) {
                comparisonText += `<p><strong>${getText('areaLabel')}:</strong> ${getText('areaMatchesMarket').replace('${userArea}', userArea).replace('${marketMin}', marketArea.min).replace('${marketMax}', marketArea.max)}</p>`;
            } else if (userArea < marketArea.min) {
                comparisonText += `<p><strong>${getText('areaLabel')}:</strong> ${getText('areaBelowMarket').replace('${userArea}', userArea).replace('${marketMin}', marketArea.min).replace('${marketMax}', marketArea.max)}</p>`;
            } else {
                comparisonText += `<p><strong>${getText('areaLabel')}:</strong> ${getText('areaAboveMarket').replace('${userArea}', userArea).replace('${marketMin}', marketArea.min).replace('${marketMax}', marketArea.max)}</p>`;
            }
            
            // Generate HTML
            let html = '<div class="market-comparison-block">';
            html += '<div class="market-comparison-content">';
            html += `<h4 class="market-comparison-title">${getText('marketComparisonTitle')}</h4>`;
            html += `<div class="market-comparison-value">${formatValue(userPricePerM2, 'price')}/${getText('unit_square_meters')}</div>`;
            html += '<div class="market-comparison-details">';
            html += `<div class="market-comparison-price">${getText('priceComparisonLabel')} ${formatValue(userPriceInTargetCurrency, 'price')}</div>`;
            html += `<div class="market-comparison-area">${getText('areaLabel')}: ${userArea} ${getText('unit_square_meters')}</div>`;
            html += '</div>';
            html += '<div class="market-comparison-analysis">';
            html += comparisonText;
            html += '</div>';
            html += '</div></div>';
            
            return html;
        }
        
        // Helper function to get current country
        function getCurrentCountry() {
            // Get country from selected location
            if (selectedLocation && selectedLocation.country_name) {
                const countryName = selectedLocation.country_name.toLowerCase();
                if (countryName.includes('türkiye') || countryName.includes('turkey') || countryName.includes('турция')) {
                    return 'Turkey';
                }
            }
            return 'Other'; // Default to other countries
        }
        
        // Helper function to get currency conversion rate
        function getCurrencyRate(fromCurrency, toCurrency) {
            // This should get the actual rate from the currency table
            // For now, we'll use approximate rates
            const rates = {
                'EUR': { 'TRY': 30, 'USD': 1.18 },
                'USD': { 'TRY': 25.4, 'EUR': 0.85 },
                'TRY': { 'EUR': 0.033, 'USD': 0.039 }
            };
            
            if (fromCurrency === toCurrency) return 1;
            return rates[fromCurrency]?.[toCurrency] || 1;
        }
        
        // Generate analytical summary based on market data (только для админов)
                async function generateAnalyticalSummary(summary) {
            // Check if user is admin
            try {
                const userAccess = await checkUserAccess();
                if (!userAccess.hasAccess || userAccess.reason !== 'admin') {
                    // User is not admin, return empty string to hide the block
                    return '';
                }
            } catch (error) {
                console.error('Error checking user access:', error);
                // On error, hide the block
                return '';
            }
            
            let analysis = '<div class="analytical-summary">';
            analysis += '<h4 class="summary-title" data-i18n="reports.market_analysis">Анализ рынка</h4>';
            

            
            // Sale analysis
            if (summary.comparable_area_for_sale && summary.listing_period_for_sale && summary.min_unit_price_for_sale) {
                const area = summary.comparable_area_for_sale;
                const period = summary.listing_period_for_sale;
                const price = summary.min_unit_price_for_sale;
                
                analysis += `<p><strong>${getText('saleLabel')}</strong> востребованная площадь ${area.min}–${area.max} ${getText('unit_square_meters')}, `;
                analysis += `срок экспозиции ${period.min}–${period.max} дней, `;
                analysis += `цена за м² ${formatValue(price.min, 'price')} – ${formatValue(price.max, 'price')}.</p>`;
            }
            
            // Rent analysis
            if (summary.comparable_area_for_rent && summary.listing_period_for_rent && summary.min_unit_price_for_rent) {
                const area = summary.comparable_area_for_rent;
                const period = summary.listing_period_for_rent;
                const price = summary.min_unit_price_for_rent;
                
                analysis += `<p><strong>${getText('rentLabel')}</strong> самая востребованная площадь ${area.min}–${area.max} ${getText('unit_square_meters')}, `;
                analysis += `срок экспозиции ${period.min}–${period.max} дней, `;
                analysis += `ставка ${formatValue(price.min, 'price')} – ${formatValue(price.max, 'price')} за ${getText('unit_square_meters')}.</p>`;
            }
            
            // Yield analysis
            if (summary.yield) {
                const yieldMin = summary.yield.min;
                const yieldMax = summary.yield.max;
                
                analysis += `<p><strong>${getText('yieldLabel')}</strong> составляет ${yieldMin.toFixed(2)}% – ${yieldMax.toFixed(2)}%.</p>`;
            }
            
            analysis += '</div>';
            return analysis;
        }
        
        // Calculate consolidated data for market analysis (для всех пользователей)
        function calculateConsolidatedDataForAnalysis(data) {
            if (!data) return null;
            
            // Define coefficients for each category
            const coefficients = {
                house_type: 0.40,      // 40% - спальни
                age: 0.30,             // 30% - возраст
                floor_segment: 0.20,   // 20% - этаж
                heating: 0.10          // 10% - отопление
            };
            
            const categories = ['house_type_data', 'floor_segment_data', 'age_data', 'heating_data'];
            const consolidatedResults = {
                salePrice: { calculated: false, value: 0 },
                rentPrice: { calculated: false, value: 0 },
                yield: { calculated: false, value: 0 }
            };
            
            // Calculate consolidated sale price
            const saleItems = [];
            const rentItems = [];
            const yieldItems = [];
            
            for (const categoryName of categories) {
                if (data[categoryName] && data[categoryName].length > 0) {
                    const categoryData = data[categoryName][0];
                    const coefficient = coefficients[categoryName.replace('_data', '')];
                    
                    if (categoryData.unit_price_for_sale && categoryData.unit_price_for_sale > 0) {
                        saleItems.push({
                            value: parseFloat(categoryData.unit_price_for_sale),
                            coefficient: coefficient
                        });
                    }
                    
                    if (categoryData.unit_price_for_rent && categoryData.unit_price_for_rent > 0) {
                        rentItems.push({
                            value: parseFloat(categoryData.unit_price_for_rent),
                            coefficient: coefficient
                        });
                    }
                    
                    if (categoryData.yield_percentage && categoryData.yield_percentage > 0) {
                        yieldItems.push({
                            value: parseFloat(categoryData.yield_percentage),
                            coefficient: coefficient
                        });
                    }
                }
            }
            
            // Calculate weighted averages
            if (saleItems.length > 0) {
                const result = calculateConsolidatedValue(saleItems);
                if (result.calculated) {
                    consolidatedResults.salePrice = result;
                }
            }
            
            if (rentItems.length > 0) {
                const result = calculateConsolidatedValue(rentItems);
                if (result.calculated) {
                    consolidatedResults.rentPrice = result;
                }
            }
            
            if (yieldItems.length > 0) {
                const result = calculateConsolidatedValue(yieldItems);
                if (result.calculated) {
                    consolidatedResults.yield = result;
                }
            }
            
            return consolidatedResults;
        }
        
        // Generate market analysis text in unified format (like "Вывод прогноза")
        function generateMarketAnalysisText(summary, consolidatedData = null) {
            let analysis = '<div class="market-analysis-content">';
            
            // Если есть данные консолидированной оценки, показываем их
            if (consolidatedData) {
                // Консолидированная средняя цена продажи
                if (consolidatedData.salePrice && consolidatedData.salePrice.calculated) {
                    analysis += `<div class="analysis-section">
                        <strong>Консолидированная средняя цена продажи:</strong> ≈ ${formatValue(consolidatedData.salePrice.value, 'price')}/${getText('unit_square_meters')}
                    </div>`;
                }
                
                // Консолидированная средняя цена аренды
                if (consolidatedData.rentPrice && consolidatedData.rentPrice.calculated) {
                    analysis += `<div class="analysis-section">
                        <strong>Консолидированная средняя цена аренды:</strong> ≈ ${formatValue(consolidatedData.rentPrice.value, 'price')}/${getText('unit_square_meters')}
                    </div>`;
                }
                
                // Консолидированная средняя доходность
                if (consolidatedData.yield && consolidatedData.yield.calculated) {
                    analysis += `<div class="analysis-section">
                        <strong>Консолидированная средняя доходность:</strong> ≈ ${formatValue(consolidatedData.yield.value, 'percentage')}
                    </div>`;
                }
            } else {
                // Sale analysis text (оригинальный код)
                if (summary.comparable_area_for_sale && summary.listing_period_for_sale && summary.unit_price_for_sale) {
                    const area = summary.comparable_area_for_sale;
                    const period = summary.listing_period_for_sale;
                    const price = summary.unit_price_for_sale;
                    
                    // Calculate average area
                    const avgArea = Math.round((area.min + area.max) / 2);
                    
                    const saleText = getText('saleAnalysisText')
                        .replace('{area}', avgArea)
                        .replace('{minPrice}', formatValue(price.min, 'price'))
                        .replace('{maxPrice}', formatValue(price.max, 'price'))
                        .replace('{minDays}', period.min)
                        .replace('{maxDays}', period.max);
                    
                    analysis += `<div class="analysis-section">
                        <strong>${getText('saleHeader')}:</strong> ${saleText}
                    </div>`;
                }
                
                // Add spacing between sections
                if ((summary.comparable_area_for_sale && summary.listing_period_for_sale && summary.unit_price_for_sale) &&
                    (summary.comparable_area_for_rent && summary.listing_period_for_rent && summary.unit_price_for_rent)) {
                    analysis += '<div class="section-spacing"></div>';
                }
                
                // Rent analysis text
                if (summary.comparable_area_for_rent && summary.listing_period_for_rent && summary.unit_price_for_rent) {
                    const area = summary.comparable_area_for_rent;
                    const period = summary.listing_period_for_rent;
                    const price = summary.unit_price_for_rent;
                    
                    // Calculate average area
                    const avgArea = Math.round((area.min + area.max) / 2);
                    
                    const rentTextFinal = getText('rentAnalysisText')
                        .replace('{area}', avgArea)
                        .replace('{minPrice}', formatValue(price.min, 'price'))
                        .replace('{maxPrice}', formatValue(price.max, 'price'))
                        .replace('{minDays}', period.min)
                        .replace('{maxDays}', period.max);
                    
                    analysis += `<div class="analysis-section">
                        <strong>${getText('rentHeader')}:</strong> ${rentTextFinal}
                    </div>`;
                }
            }
            
            analysis += '</div></div>';
            return analysis;
        }

        // Generate market analysis text block
        function generateMarketAnalysisText(summary) {
            if (!summary || Object.keys(summary).length === 0) {
                return '';
            }
            
            // Calculate average values for areas
            const avgSaleArea = summary.comparable_area_for_sale ? 
                Math.round((summary.comparable_area_for_sale.min + summary.comparable_area_for_sale.max) / 2) : 60;
            const avgRentArea = summary.comparable_area_for_rent ? 
                Math.round((summary.comparable_area_for_rent.min + summary.comparable_area_for_rent.max) / 2) : 65;
            
            // Get min/max prices and periods
            const saleMinPrice = summary.unit_price_for_sale ? summary.unit_price_for_sale.min : 31061;
            const saleMaxPrice = summary.unit_price_for_sale ? summary.unit_price_for_sale.max : 45385;
            const saleMinPeriod = summary.listing_period_for_sale ? summary.listing_period_for_sale.min : 62;
            const saleMaxPeriod = summary.listing_period_for_sale ? summary.listing_period_for_sale.max : 90;
            
            const rentMinPrice = summary.unit_price_for_rent ? summary.unit_price_for_rent.min : 196.24;
            const rentMaxPrice = summary.unit_price_for_rent ? summary.unit_price_for_rent.max : 250;
            const rentMinPeriod = summary.listing_period_for_rent ? summary.listing_period_for_rent.min : 65;
            const rentMaxPeriod = summary.listing_period_for_rent ? summary.listing_period_for_rent.max : 96;
            
            let html = '<div class="market-analysis-text-block">';
            html += `<h4 class="market-analysis-text-title">${getText('marketAnalysisTitle')}</h4>`;
            html += '<div class="market-analysis-text-content">';
            
            // Sale analysis in unified style (like "Вывод прогноза")
            // Используем локализованный текст для анализа продажи и аренды
            const saleAnalysisText = getText('saleAnalysisText')
                .replace('{area}', avgSaleArea)
                .replace('{minPrice}', formatValue(saleMinPrice, 'price'))
                .replace('{minDays}', saleMinPeriod)
                .replace('{maxPrice}', formatValue(saleMaxPrice, 'price'))
                .replace('{maxDays}', saleMaxPeriod);
            
            const rentAnalysisText = getText('rentAnalysisText')
                .replace('{area}', avgRentArea)
                .replace('{minPrice}', formatValue(rentMinPrice, 'price'))
                .replace('{minDays}', rentMinPeriod)
                .replace('{maxPrice}', formatValue(rentMaxPrice, 'price'))
                .replace('{maxDays}', rentMaxPeriod);
            
            html += `<p>${saleAnalysisText}</p>`;
            html += `<p>${rentAnalysisText}</p>`;
            
            html += '</div></div>';
            
            return html;
        }

        // Generate market indicators table with organized structure
        async function generateSummaryTable(data) {
            // Save data globally for recalculation
            window.currentSummaryData = data;
            
            const summaryContainer = document.getElementById('summaryDataContent');
            if (!summaryContainer) return;
            
            // Collect all data from all tables
            const allData = [];
            const tables = ['general_data', 'house_type_data', 'floor_segment_data', 'age_data', 'heating_data'];
            
            tables.forEach(tableName => {
                const tableData = data[tableName] || [];
                if (Array.isArray(tableData)) {
                    allData.push(...tableData);
                }
            });
            
            if (allData.length === 0) {
                summaryContainer.innerHTML = `<div class="no-data">${getText('noDataAvailable')}</div>`;
                return;
            }
            
            // Define fields for summary with new structure
            const saleFields = [
                'comparable_area_for_sale', 
                'listing_period_for_sale', 'unit_price_for_sale'
            ];
            
            const rentFields = [
                'comparable_area_for_rent', 
                'listing_period_for_rent', 'unit_price_for_rent'
            ];
            
            // Calculate min/max values for all fields
            const summary = {};
            const allFields = [...saleFields, ...rentFields, 'yield'];
            
            // Special handling for comparable_area fields - only use house_type_data
            const houseTypeData = data.house_type_data || [];
            
            allFields.forEach(field => {
                if (field === 'comparable_area_for_sale' || field === 'comparable_area_for_rent') {
                    // For area fields, only use house_type_data
                    const values = houseTypeData
                        .map(item => item[field])
                        .filter(val => val !== null && val !== undefined && !isNaN(parseFloat(val)));
                    
                    if (values.length > 0) {
                        summary[field] = {
                            min: Math.min(...values),
                            max: Math.max(...values)
                        };
                    }
                } else {
                    // For other fields, use all data
                const values = allData
                    .map(item => item[field])
                    .filter(val => val !== null && val !== undefined && !isNaN(parseFloat(val)));
                
                if (values.length > 0) {
                    summary[field] = {
                        min: Math.min(...values),
                        max: Math.max(...values)
                    };
                    }
                }
            });
            
            // Store summary data globally for use in object comparison
            marketSummaryData = summary;
            console.log('💾 Stored market summary data globally:', summary);
            
            // Generate market indicators in table format
            let html = '<div class="market-indicators-table">';
            
            // Create table with sale and rent data side by side
            html += '<table class="market-data-table">';
            html += '<thead>';
            html += '<tr>';
            html += `<th class="category-header">${getText('saleHeader')}</th>`;
            html += `<th class="category-header">${getText('rentHeader')}</th>`;
            html += '</tr>';
            html += '</thead>';
            html += '<tbody>';
            
            // Row 1: Comparable Area (single value - average)
            html += '<tr>';
            html += '<td class="data-cell">';
            html += `<div class="cell-label">${getText('comparableAreaForSaleLabel')}:</div>`;
                if (summary.comparable_area_for_sale) {
                    const area = summary.comparable_area_for_sale;
                const avgArea = Math.round((area.min + area.max) / 2);
                html += `<div class="cell-value">${avgArea} ${getText('unit_square_meters')}</div>`;
            } else {
                html += '<div class="cell-value">-</div>';
            }
            html += '</td>';
            html += '<td class="data-cell">';
            html += `<div class="cell-label">${getText('comparableAreaForRentLabel')}:</div>`;
                if (summary.comparable_area_for_rent) {
                    const area = summary.comparable_area_for_rent;
                const avgArea = Math.round((area.min + area.max) / 2);
                html += `<div class="cell-value">${avgArea} ${getText('unit_square_meters')}</div>`;
            } else {
                html += '<div class="cell-value">-</div>';
            }
            html += '</td>';
            html += '</tr>';
            
            // Row 2: Listing Period
            html += '<tr>';
            html += '<td class="data-cell">';
            html += `<div class="cell-label">${getText('listingPeriodForSaleLabel')}:</div>`;
            if (summary.listing_period_for_sale) {
                const period = summary.listing_period_for_sale;
                html += `<div class="cell-value">${period.min} – ${period.max} ${getText('unit_days')}</div>`;
            } else {
                html += '<div class="cell-value">-</div>';
            }
            html += '</td>';
            html += '<td class="data-cell">';
            html += `<div class="cell-label">${getText('listingPeriodForRentLabel')}:</div>`;
                if (summary.listing_period_for_rent) {
                    const period = summary.listing_period_for_rent;
                html += `<div class="cell-value">${period.min} – ${period.max} ${getText('unit_days')}</div>`;
            } else {
                html += '<div class="cell-value">-</div>';
            }
            html += '</td>';
            html += '</tr>';
            
            // Row 3: Unit Price
            html += '<tr>';
            html += '<td class="data-cell">';
            html += `<div class="cell-label">${getText('unitPriceForSaleLabel')}:</div>`;
            if (summary.unit_price_for_sale) {
                const price = summary.unit_price_for_sale;
                html += `<div class="cell-value">${formatValue(price.min, 'price')} – ${formatValue(price.max, 'price')}</div>`;
            } else {
                html += '<div class="cell-value">-</div>';
            }
            html += '</td>';
            html += '<td class="data-cell">';
            html += `<div class="cell-label">${getText('unitPriceForRentLabel')}:</div>`;
                if (summary.unit_price_for_rent) {
                    const price = summary.unit_price_for_rent;
                html += `<div class="cell-value">${formatValue(price.min, 'price')} – ${formatValue(price.max, 'price')}</div>`;
            } else {
                html += '<div class="cell-value">-</div>';
            }
            html += '</td>';
            html += '</tr>';
            
            html += '</tbody>';
            html += '</table>';
            html += '</div>';
            
            // Add spacing between blocks
            html += '<div class="block-spacing"></div>';
            
            // Add market analysis text block
            const marketAnalysisTextHtml = generateMarketAnalysisText(summary);
            html += marketAnalysisTextHtml;
            
            // Add spacing after market analysis
            html += '<div class="block-spacing"></div>';
            
            // Add detailed data tables for each category (admin only)
            const detailedTablesHtml = await generateDetailedDataTables(data);
            html += detailedTablesHtml;
            
            // Add consolidated assessment block
            const consolidatedAssessmentHtml = await generateConsolidatedAssessment(data);
            html += consolidatedAssessmentHtml;
            
            // Add market comparison block below the detailed tables
            if (Object.keys(summary).length > 0) {
                html += generateMarketComparison(summary);
            }
            
            // Add analytical summary below the comparison block
            if (Object.keys(summary).length > 0) {
                html += await generateAnalyticalSummary(summary);
            }
            
            summaryContainer.innerHTML = html;
            
            // Load property trends data
            loadPropertyTrends(data);
        }

        // Generate detailed data tables as accordion for admin users only
        async function generateDetailedDataTables(data) {
            // Check if user is admin
            const telegramId = getTelegramId();
            if (!telegramId) {
                console.log('⚠️ No telegram_id found');
                return '';
            }
            
            const isAdmin = await checkAdminStatus(telegramId);
            if (!isAdmin) {
                console.log('⚠️ User is not admin');
                return '';
            }
            
            let html = '<div class="admin-data-accordion">';
            html += '<h4 class="accordion-title">' + getText('detailedDataTitle') + '</h4>';
            html += '<div class="accordion-container">';
            
            // House Type Data Accordion
            if (data.house_type_data && data.house_type_data.length > 0) {
                html += generateCategoryAccordion('house_type_data', getText('houseTypeDataTitle'), data.house_type_data);
            }
            
            // Floor Segment Data Accordion
            if (data.floor_segment_data && data.floor_segment_data.length > 0) {
                html += generateCategoryAccordion('floor_segment_data', getText('floorSegmentDataTitle'), data.floor_segment_data);
            }
            
            // Age Data Accordion
            if (data.age_data && data.age_data.length > 0) {
                html += generateCategoryAccordion('age_data', getText('ageDataTitle'), data.age_data);
            }
            
            // Heating Data Accordion
            if (data.heating_data && data.heating_data.length > 0) {
                html += generateCategoryAccordion('heating_data', getText('heatingDataTitle'), data.heating_data);
            }
            
            html += '</div></div>';
            return html;
        }

                // Generate accordion for specific category
        function generateCategoryAccordion(category, title, tableData) {
            if (!tableData || tableData.length === 0) return '';
            
            // Get all unique fields from the data
            const allFields = new Set();
            tableData.forEach(item => {
                Object.keys(item).forEach(key => {
                    if (key !== 'id' && key !== 'created_at' && key !== 'updated_at' && 
                        key !== 'country_id' && key !== 'city_id' && key !== 'county_id' && key !== 'district_id') {
                        allFields.add(key);
                    }
                });
            });
            
            const fields = Array.from(allFields).sort();
            const accordionId = `accordion-${category}`;
            
            let html = '<div class="accordion-item">';
            html += `<div class="accordion-header" onclick="toggleAccordion('${accordionId}')">`;
            html += `<span class="accordion-title">${title}</span>`;
            html += '<span class="accordion-icon">▼</span>';
            html += '</div>';
            html += `<div class="accordion-content" id="${accordionId}">`;
            html += '<div class="accordion-table-container">';
            html += '<table class="accordion-table">';
            html += '<thead><tr>';
            
            // Add headers
            html += '<th>Параметр</th>';
            tableData.forEach((item, index) => {
                const listingType = item.listing_type || `Запись ${index + 1}`;
                html += `<th>${listingType}</th>`;
            });
            html += '</tr></thead><tbody>';
            
            // Add data rows
            fields.forEach(field => {
                if (field !== 'listing_type') {
                    html += '<tr>';
                    html += `<td class="field-name">${formatFieldName(field)}</td>`;
                    
                    tableData.forEach(item => {
                        const value = item[field];
                        html += `<td class="field-value">${formatFieldValue(value, field)}</td>`;
                    });
                    
                    html += '</tr>';
                }
            });
            
            html += '</tbody></table>';
            html += '</div></div></div>';
            
            return html;
        }
        
        // Get telegram_id from Telegram WebApp
        function getTelegramId() {
            if (window.Telegram && window.Telegram.WebApp && window.Telegram.WebApp.initDataUnsafe && window.Telegram.WebApp.initDataUnsafe.user) {
                return window.Telegram.WebApp.initDataUnsafe.user.id;
            }
            return null;
        }
        
        // Toggle accordion content
        function toggleAccordion(accordionId) {
            const content = document.getElementById(accordionId);
            const header = content.previousElementSibling;
            const icon = header.querySelector('.accordion-icon');
            
            if (content.style.display === 'none' || content.style.display === '') {
                content.style.display = 'block';
                icon.textContent = '▼';
                header.classList.add('active');
            } else {
                content.style.display = 'none';
                icon.textContent = '▶';
                header.classList.remove('active');
            }
        }
        
        // Check if user is admin by telegram_id
        async function checkAdminStatus(telegramId) {
            try {
                const response = await fetch('/api/check_admin_status', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ telegram_id: telegramId })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const result = await response.json();
                return result.is_admin === true;
                
            } catch (error) {
                console.error('❌ Error checking admin status:', error);
                return false;
            }
        }
        
        // Clear existing property trends section
        function clearPropertyTrends() {
            const existingTrendsSection = document.getElementById('propertyTrendsSection');
            if (existingTrendsSection) {
                existingTrendsSection.remove();
                console.log('🗑️ Property trends section cleared (including forecast)');
            }
        }

        // Load property trends data for selected location
        async function loadPropertyTrends(data) {
            try {
                // Use selected location data instead of searching through tables
                if (!selectedLocation.country_id || !selectedLocation.city_id || 
                    !selectedLocation.county_id || !selectedLocation.district_id) {
                    console.log('⚠️ No location selected for property trends');
                    return;
                }
                
                const locationIds = {
                    country_id: selectedLocation.country_id,
                    city_id: selectedLocation.city_id,
                    county_id: selectedLocation.county_id,
                    district_id: selectedLocation.district_id
                };
                
                console.log('🔄 Loading property trends for location:', locationIds);
                console.log('📍 Selected location object:', selectedLocation);
                
                // Make API request to get property trends
                const response = await fetch('/api/property_trends', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(locationIds)
                });
                
                const trendsData = await response.json();
                console.log('📊 Property trends response:', trendsData);
                console.log('🔍 API response details:');
                console.log('  - success:', trendsData.success);
                console.log('  - trends count:', trendsData.trends ? trendsData.trends.length : 'undefined');
                console.log('  - first trend:', trendsData.trends ? trendsData.trends[0] : 'undefined');
                
                if (trendsData.success && trendsData.trends && trendsData.trends.length > 0) {
                    console.log('✅ Property trends data received:', trendsData.trends);
                    console.log('🔍 First trend record:', trendsData.trends[0]);
                    
                    // Сохраняем данные глобально для переключения графиков
                    window.currentTrendsData = trendsData.trends;
                    
                    // Add property trends section below the summary table
                    addPropertyTrendsSection(trendsData.trends);
                } else {
                    console.log('⚠️ No property trends data available');
                    console.log('trendsData:', trendsData);
                }
                
            } catch (error) {
                console.error('❌ Error loading property trends:', error);
            }
        }
        
        // Find trend data for current month and year
        function findCurrentMonthTrend(typeTrends) {
            if (!typeTrends || typeTrends.length === 0) return null;
            
            const now = new Date();
            const currentYear = now.getFullYear();
            const currentMonth = now.getMonth() + 1; // getMonth() returns 0-11
            
            // Ищем тренд за текущий месяц и год
            const currentTrend = typeTrends.find(trend => {
                return trend.property_year === currentYear && trend.property_month === currentMonth;
            });
            
            // Если не нашли за текущий месяц, ищем за последний доступный месяц текущего года
            if (!currentTrend) {
                const currentYearTrends = typeTrends.filter(trend => trend.property_year === currentYear);
                if (currentYearTrends.length > 0) {
                    // Сортируем по месяцу и берем последний
                    currentYearTrends.sort((a, b) => b.property_month - a.property_month);
                    return currentYearTrends[0];
                }
            }
            
            // Если не нашли за текущий год, возвращаем последний доступный тренд
            return currentTrend || typeTrends[0];
        }

        // Format date for current month trends
        function formatCurrentMonthDate(trend) {
            if (trend.property_year && trend.property_month) {
                const monthNames = {
                    'ru': ['январь', 'февраль', 'март', 'апрель', 'май', 'июнь',
                           'июль', 'август', 'сентябрь', 'октябрь', 'ноябрь', 'декабрь'],
                    'en': ['January', 'February', 'March', 'April', 'May', 'June',
                           'July', 'August', 'September', 'October', 'November', 'December'],
                    'de': ['Januar', 'Februar', 'März', 'April', 'Mai', 'Juni',
                           'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'],
                    'fr': ['janvier', 'février', 'mars', 'avril', 'mai', 'juin',
                           'juillet', 'août', 'septembre', 'octobre', 'novembre', 'décembre'],
                    'tr': ['Ocak', 'Şubat', 'Mart', 'Nisan', 'Mayıs', 'Haziran',
                           'Temmuz', 'Ağustos', 'Eylül', 'Ekim', 'Kasım', 'Aralık']
                };
                const currentLang = currentLanguage || 'ru';
                const monthList = monthNames[currentLang] || monthNames['ru'];
                const monthName = monthList[trend.property_month - 1] || trend.property_month;
                return `${monthName} ${trend.property_year}`;
            }
            // Fallback to regular date formatting
            return formatTrendDate(trend.date);
        }

        // Add property trends section to the page
        async function addPropertyTrendsSection(trends) {
            console.log('📊 Adding property trends section with trends:', trends.length, 'records');
            console.log('🔍 First trend record:', trends[0]);
            
            // Проверяем, не существует ли уже секция трендов
            if (document.getElementById('propertyTrendsSection')) {
                console.log('⚠️ Property trends section already exists, skipping...');
                return;
            }
            
            const summarySection = document.getElementById('summaryDataSection');
            if (!summarySection) return;
            
            // Получаем базовые цены для текущего месяца
            let basePrices = null;
            try {
                basePrices = await getBasePricesFromTables();
                console.log('💰 Base prices for trends card:', basePrices);
            } catch (error) {
                console.error('❌ Ошибка получения базовых цен для карточки, используем fallback:', error);
            }
            
            // Create property trends section
            const trendsSection = document.createElement('div');
            trendsSection.className = 'data-section';
            trendsSection.id = 'propertyTrendsSection';
            
            // Группируем тренды по типам
            const groupedTrends = groupTrendsByType(trends);
            
            trendsSection.innerHTML = `
                <h3 class="data-section-title">${getText('marketTrendsTitle')}</h3>
                <div class="data-section-content">
                    <div class="trends-grid">
                        ${Object.entries(groupedTrends).map(([type, typeTrends]) => {
                            // Найти тренд за текущий месяц и год
                            const currentTrend = findCurrentMonthTrend(typeTrends);
                            if (!currentTrend) return '';
                            
                            // Используем базовые цены если доступны, иначе исходные данные
                            let displayValue = currentTrend.trend_value;
                            if (basePrices && type === 'price_trend') {
                                displayValue = basePrices.sale_price; // Используем базовую цену продажи
                                console.log(`💰 Using base price for card: ${displayValue}`);
                            }
                            
                            return `
                                <div class="trend-card trend-card-${type}">
                                    <div class="trend-title">${formatTrendType(type)}</div>
                                    <div class="trend-value">${formatTrendValue(displayValue, type)}</div>
                                    <div class="trend-details">
                                        <div class="trend-change">
                                            ${currentTrend.price_change_sale ? `${getText('saleLabel')} ${formatPercentage(currentTrend.price_change_sale)}` : ''}
                                            ${currentTrend.price_change_rent ? `${getText('rentLabel')} ${formatPercentage(currentTrend.price_change_rent)}` : ''}
                                            ${formatCurrentMonthDate(currentTrend)}
                                        </div>
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                    
                    <!-- Таблица со всеми записями трендов -->
                    <div class="trends-table-section">
                        <h4 class="trends-table-title">${getText('detailedTrendsDataTitle')}</h4>
                        <div class="trends-table-container" id="trendsTableContainer">
                            <!-- Тренды будут загружены асинхронно -->
                        </div>
                    </div>
                    
                    <!-- График трендов будет добавлен в generateTrendsTable -->
                </div>
            `;
            
            // Insert after summary section
            summarySection.parentNode.insertBefore(trendsSection, summarySection.nextSibling);
            
            // Асинхронно загружаем таблицу трендов
            const trendsTableContainer = document.getElementById('trendsTableContainer');
            if (trendsTableContainer) {
                const trendsTableHtml = await generateTrendsTable(trends);
                trendsTableContainer.innerHTML = trendsTableHtml;
                
                // Инициализируем график трендов после добавления HTML
                setTimeout(() => {
                    initializeTrendsChart(trends);
                }, 100);
            }
        }
        
        // Group trends by type for better display
        function groupTrendsByType(trends) {
            const grouped = {};
            trends.forEach(trend => {
                const key = trend.trend_type || 'general';
                if (!grouped[key]) {
                    grouped[key] = [];
                }
                grouped[key].push(trend);
            });
            return grouped;
        }
        
        // Format trend type for display
        function formatTrendType(type) {
            const typeMap = {
                'price_trend': getText('priceTrendLabel'),
                'yield_trend': getText('yieldTrendLabel'),
                'count_trend': getText('countTrendLabel'),
                'general': getText('generalTrendLabel'),
                'chart_title': getText('chart_title'),
                'sale_button': getText('sale_button'),
                'rent_button': getText('rent_button')
            };
            return typeMap[type] || type;
        }
        
        // Format percentage values
        function formatPercentage(value) {
            if (value === null || value === undefined) return '-';
            const numValue = parseFloat(value);
            if (isNaN(numValue)) return '-';
            const sign = numValue >= 0 ? '+' : '';
            return `${sign}${(numValue * 100).toFixed(2)}%`;
        }
        
        // Format trend date
        function formatTrendDate(dateStr) {
            if (!dateStr) return '';
            try {
                const date = new Date(dateStr);
                return date.toLocaleDateString('ru-RU', { 
                    year: 'numeric', 
                    month: 'short' 
                });
            } catch (e) {
                return dateStr;
            }
        }
        
        // Format trend date without "г." for shorter display
        function formatTrendDateShort(dateStr) {
            if (!dateStr) return '';
            try {
                const date = new Date(dateStr);
                const monthNames = {
                    'ru': ['янв', 'фев', 'мар', 'апр', 'май', 'июн',
                           'июл', 'авг', 'сен', 'окт', 'ноя', 'дек'],
                    'en': ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                           'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
                    'de': ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun',
                           'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'],
                    'fr': ['jan', 'fév', 'mar', 'avr', 'mai', 'juin',
                           'juil', 'août', 'sep', 'oct', 'nov', 'déc'],
                    'tr': ['Oca', 'Şub', 'Mar', 'Nis', 'May', 'Haz',
                           'Tem', 'Ağu', 'Eyl', 'Eki', 'Kas', 'Ara']
                };
                const currentLang = currentLanguage || 'ru';
                const monthList = monthNames[currentLang] || monthNames['ru'];
                
                const month = monthList[date.getMonth()];
                const year = date.getFullYear();
                
                return `${month}. ${year}`;
            } catch (e) {
                return dateStr;
            }
        }

                // Filter trends to show all historical data without month restrictions
        function filterTrendsByDateRange(trends, isAdmin = false) {
            if (!trends || trends.length === 0) return [];
            
            const currentYear = new Date().getFullYear();
            const currentMonth = new Date().getMonth() + 1; // getMonth() returns 0-11
            
            console.log(`🔍 Filtering trends: current date = ${currentYear}-${currentMonth}`);
            console.log(`🔍 Total trends = ${trends.length}`);
            console.log(`👤 User is admin: ${isAdmin}`);
            
            // Сортируем тренды по property_year и property_month (новые сначала)
            const sortedTrends = trends.sort((a, b) => {
                if (a.property_year !== b.property_year) {
                    return b.property_year - a.property_year;
                }
                return b.property_month - a.property_month;
            });
            
            console.log(`🔍 Sorted trends by property_year/property_month (newest first):`);
            sortedTrends.forEach((trend, index) => {
                console.log(`  ${index}: ${trend.property_year}-${trend.property_month} (${trend.date})`);
            });
            
            // Фильтруем тренды в зависимости от статуса пользователя
            let filteredTrends;
            if (isAdmin) {
                // Админы видят все данные (включая будущие)
                console.log(`👑 Admin access: showing ALL trends including future data`);
                filteredTrends = sortedTrends;
            } else {
                // Обычные пользователи видят ограниченный диапазон: 8 месяцев назад + текущий + 1 месяц вперед
                console.log(`👤 Regular user: showing limited range (8 months back + current + 1 month forward)`);
                
                // Создаем диапазон дат: от 8 месяцев назад до 1 месяца вперед
                const startDate = new Date(currentYear, currentMonth - 1 - 8, 1); // 8 месяцев назад
                const endDate = new Date(currentYear, currentMonth - 1 + 1, 1);   // 1 месяц вперед
                
                const startYear = startDate.getFullYear();
                const startMonth = startDate.getMonth() + 1;
                const endYear = endDate.getFullYear();
                const endMonth = endDate.getMonth() + 1;
                
                console.log(`📅 Table date range: ${startYear}-${startMonth} to ${endYear}-${endMonth}`);
                
                filteredTrends = sortedTrends.filter(trend => {
                    // Проверяем, что тренд попадает в диапазон
                    const trendDate = new Date(trend.property_year, trend.property_month - 1, 1);
                    const isInRange = trendDate >= startDate && trendDate <= endDate;
                    return isInRange;
                });
                
                console.log(`🔒 Filtered ${sortedTrends.length} trends to ${filteredTrends.length} (limited range for table)`);
            }
            
            // Обратная хронологическая сортировка: новые даты вверху, старые внизу
            const sortedForDisplay = filteredTrends.sort((a, b) => {
                const yearA = a.property_year;
                const monthA = a.property_month;
                const yearB = b.property_year;
                const monthB = b.property_month;
                
                // Сортируем по убыванию (новые даты сначала)
                if (yearA !== yearB) {
                    return yearB - yearA; // 2026 перед 2025, 2025 перед 2024, и т.д.
                }
                return monthB - monthA; // Декабрь перед ноябрем, ноябрь перед октябрем, и т.д.
            });
            
            console.log(`✅ Returning ${sortedForDisplay.length} trends for ${isAdmin ? 'admin' : 'regular'} user`);
            return sortedForDisplay;
        }

        // Calculate historical prices based on percentage changes
        function calculateHistoricalPrice(basePrice, percentageChange) {
            if (!basePrice || !percentageChange) return basePrice;
            
            // percentageChange уже в формате 0.0225 (2.25%), не нужно делить на 100
            const changeMultiplier = 1 + percentageChange;
            return basePrice / changeMultiplier;
        }

        // Кэш для рассчитанных трендов
        let trendsCalculationCache = null;
        let trendsCalculationCacheKey = null;

        // Prepare trends data with calculated historical prices
        async function prepareTrendsWithHistoricalPrices(trends) {
            if (!trends || trends.length === 0) return [];
            
            // Создаем ключ кэша на основе входных данных
            const cacheKey = JSON.stringify({
                trends: trends.map(t => ({
                    year: t.property_year,
                    month: t.property_month,
                    sale_price: t.unit_price_for_sale,
                    rent_price: t.unit_price_for_rent,
                    price_change_sale: t.price_change_sale,
                    price_change_rent: t.price_change_rent
                })),
                location: selectedLocation ? {
                    country_id: selectedLocation.country_id,
                    city_id: selectedLocation.city_id,
                    county_id: selectedLocation.county_id,
                    district_id: selectedLocation.district_id
                } : null
            });
            
            // Проверяем кэш
            if (trendsCalculationCache && trendsCalculationCacheKey === cacheKey) {
                console.log('💰 Using cached trends calculation result');
                console.log('💰 Cache hit - returning cached data for consistency between table and chart');
                return trendsCalculationCache;
            }
            
            console.log('💰 Starting price calculation with new logic: base prices from 4 tables');
            
            // Сортируем тренды по дате (новые сначала)
            const sortedTrends = trends.sort((a, b) => {
                if (a.property_year !== b.property_year) {
                    return b.property_year - a.property_year;
                }
                return b.property_month - a.property_month;
            });
            
            const currentDate = new Date();
            const currentYear = currentDate.getFullYear();
            const currentMonth = currentDate.getMonth() + 1;
            
            // Получаем базовые цены из 4 таблиц для текущего месяца
            let basePrices = null;
            try {
                basePrices = await getBasePricesFromTables();
                console.log('💰 Base prices received:', basePrices);
            } catch (error) {
                console.error('❌ Ошибка получения базовых цен, используем fallback:', error);
                // Fallback: используем данные из property_trends для текущего месяца
                const currentTrend = sortedTrends.find(t => t.property_year === currentYear && t.property_month === currentMonth);
                if (currentTrend) {
                    basePrices = {
                        sale_price: parseFloat(currentTrend.unit_price_for_sale) || 0,
                        rent_price: parseFloat(currentTrend.unit_price_for_rent) || 0
                    };
                    console.log('🔄 Using fallback base prices:', basePrices);
                }
            }
            
            if (!basePrices) {
                console.error('❌ Не удалось получить базовые цены, используем оригинальную логику');
                return prepareTrendsWithOriginalLogic(trends);
            }
            
            // Создаем кэш для рассчитанных цен
            const priceCache = new Map();
            
            // Сначала обрабатываем текущий месяц
            const currentTrend = sortedTrends.find(t => t.property_year === currentYear && t.property_month === currentMonth);
            if (currentTrend) {
                const cacheKey = `${currentYear}-${currentMonth}`;
                priceCache.set(cacheKey, {
                    salePrice: basePrices.sale_price,
                    rentPrice: basePrices.rent_price,
                    isCalculated: true
                });
                console.log(`💰 Base prices for current month ${currentYear}-${currentMonth}: sale ${basePrices.sale_price} ₺/m², rent ${basePrices.rent_price} ₺/m²`);
            }
            
            // Затем обрабатываем будущие месяцы в хронологическом порядке
            const futureTrends = sortedTrends.filter(trend => {
                const year = trend.property_year;
                const month = trend.property_month;
                return year > currentYear || (year === currentYear && month > currentMonth);
            }).sort((a, b) => {
                if (a.property_year !== b.property_year) {
                    return a.property_year - b.property_year;
                }
                return a.property_month - b.property_month;
            });
            
            for (const trend of futureTrends) {
                const year = trend.property_year;
                const month = trend.property_month;
                const cacheKey = `${year}-${month}`;
                
                let calculatedSalePrice = parseFloat(trend.unit_price_for_sale) || 0;
                let calculatedRentPrice = parseFloat(trend.unit_price_for_rent) || 0;
                
                // Ищем предыдущий месяц для расчета
                let prevMonthKey = null;
                if (month === 1) {
                    prevMonthKey = `${year - 1}-12`;
                } else {
                    prevMonthKey = `${year}-${month - 1}`;
                }
                
                const prevMonthData = priceCache.get(prevMonthKey);
                if (prevMonthData && trend.price_change_sale && trend.price_change_rent) {
                    // Формула: Цена_месяца = Цена_предыдущего_месяца × (1 + процент_изменения)
                    calculatedSalePrice = calculateFuturePrice(
                        prevMonthData.salePrice, 
                        trend.price_change_sale
                    );
                    calculatedRentPrice = calculateFuturePrice(
                        prevMonthData.rentPrice, 
                        trend.price_change_rent
                    );
                    
                    console.log(`🚀 Progressive calculation for ${year}-${month}: sale ${calculatedSalePrice} ₺/m², rent ${calculatedRentPrice} ₺/m²`);
                }
                
                priceCache.set(cacheKey, {
                    salePrice: calculatedSalePrice,
                    rentPrice: calculatedRentPrice,
                    isCalculated: true
                });
            }
            
            // Затем обрабатываем исторические месяцы в обратном хронологическом порядке
            const historicalTrends = sortedTrends.filter(trend => {
                const year = trend.property_year;
                const month = trend.property_month;
                return year < currentYear || (year === currentYear && month < currentMonth);
            }).sort((a, b) => {
                if (a.property_year !== b.property_year) {
                    return b.property_year - a.property_year;
                }
                return b.property_month - a.property_month;
            });
            
            for (const trend of historicalTrends) {
                const year = trend.property_year;
                const month = trend.property_month;
                const cacheKey = `${year}-${month}`;
                
                let calculatedSalePrice = parseFloat(trend.unit_price_for_sale) || 0;
                let calculatedRentPrice = parseFloat(trend.unit_price_for_rent) || 0;
                
                // Ищем следующий месяц для расчета
                let nextMonthKey = null;
                if (month === 12) {
                    nextMonthKey = `${year + 1}-1`;
                } else {
                    nextMonthKey = `${year}-${month + 1}`;
                }
                
                const nextMonthData = priceCache.get(nextMonthKey);
                if (nextMonthData && trend.price_change_sale && trend.price_change_rent) {
                    // Формула: Цена_месяца = Цена_следующего_месяца ÷ (1 + процент_изменения)
                    calculatedSalePrice = calculateHistoricalPrice(
                        nextMonthData.salePrice, 
                        trend.price_change_sale
                    );
                    calculatedRentPrice = calculateHistoricalPrice(
                        nextMonthData.rentPrice, 
                        trend.price_change_rent
                    );
                    
                    console.log(`⏪ Recursive calculation for ${year}-${month}: sale ${calculatedSalePrice} ₺/m², rent ${calculatedRentPrice} ₺/m²`);
                }
                
                priceCache.set(cacheKey, {
                    salePrice: calculatedSalePrice,
                    rentPrice: calculatedRentPrice,
                    isCalculated: true
                });
            }
            
            // Обновляем тренды с рассчитанными ценами
            const updatedTrends = sortedTrends.map(trend => {
                const year = trend.property_year;
                const month = trend.property_month;
                const cacheKey = `${year}-${month}`;
                const cachedData = priceCache.get(cacheKey);
                
                if (cachedData) {
                    return {
                        ...trend,
                        calculated_sale_price: cachedData.salePrice,
                        calculated_rent_price: cachedData.rentPrice,
                        is_price_calculated: cachedData.isCalculated
                    };
                }
                
                return trend;
            });
            
            console.log('📊 Trends with new calculation logic:', updatedTrends.length, 'records');
            
            // Сохраняем результат в кэш
            trendsCalculationCache = updatedTrends;
            trendsCalculationCacheKey = cacheKey;
            console.log('💰 Trends calculation result cached');
            
            return updatedTrends;
        }
        
        // Функция для получения текущей выбранной локации
        function getSelectedLocation() {
            return selectedLocation && selectedLocation.country_id && selectedLocation.city_id && 
                   selectedLocation.county_id && selectedLocation.district_id ? selectedLocation : null;
        }
        
        // Функция для очистки кэша расчетов
        function clearTrendsCalculationCache() {
            trendsCalculationCache = null;
            trendsCalculationCacheKey = null;
            console.log('💰 Trends calculation cache cleared - ensuring fresh data for next calculation');
        }
        
        // Функция для получения базовых цен из 4 таблиц
        async function getBasePricesFromTables() {
            const location = getSelectedLocation();
            if (!location) {
                throw new Error('Локация не выбрана');
            }
            
            console.log('💰 Requesting base prices from 4 tables for location:', location);
            
            const response = await fetch('/api/base_prices', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    country_id: location.country_id,
                    city_id: location.city_id,
                    county_id: location.county_id,
                    district_id: location.district_id
                })
            });
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const data = await response.json();
            if (!data.success) {
                throw new Error(data.error || 'Ошибка получения базовых цен');
            }
            
            return data.base_prices;
        }
        
        // Функция расчета будущих цен: Цена = Предыдущая × (1 + процент/100)
        function calculateFuturePrice(previousPrice, changePercent) {
            return previousPrice * (1 + changePercent);
        }
        
        // Fallback функция с оригинальной логикой
        function prepareTrendsWithOriginalLogic(trends) {
            // Оригинальная логика для случая, когда базовые цены недоступны
            const sortedTrends = trends.sort((a, b) => {
                if (a.property_year !== b.property_year) {
                    return b.property_year - a.property_year;
                }
                return b.property_month - a.property_month;
            });
            
            const currentDate = new Date();
            const currentYear = currentDate.getFullYear();
            const currentMonth = currentDate.getMonth() + 1;
            
            const priceCache = new Map();
            
            for (let i = 0; i < sortedTrends.length; i++) {
                const trend = sortedTrends[i];
                const year = trend.property_year;
                const month = trend.property_month;
                const cacheKey = `${year}-${month}`;
                
                const isCurrentMonth = year === currentYear && month === currentMonth;
                const isFutureMonth = year > currentYear || (year === currentYear && month > currentMonth);
                const isHistoricalMonth = year < currentYear || (year === currentYear && month < currentMonth);
                
                if (isCurrentMonth || isFutureMonth) {
                    priceCache.set(cacheKey, {
                        salePrice: parseFloat(trend.unit_price_for_sale) || 0,
                        rentPrice: parseFloat(trend.unit_price_for_rent) || 0,
                        isCalculated: false
                    });
                } else if (isHistoricalMonth) {
                    let calculatedSalePrice = parseFloat(trend.unit_price_for_sale) || 0;
                    let calculatedRentPrice = parseFloat(trend.unit_price_for_rent) || 0;
                    
                    let nextMonthKey = null;
                    if (month === 12) {
                        nextMonthKey = `${year + 1}-1`;
            } else {
                        nextMonthKey = `${year}-${month + 1}`;
                    }
                    
                    const nextMonthData = priceCache.get(nextMonthKey);
                    if (nextMonthData && trend.price_change_sale && trend.price_change_rent) {
                        calculatedSalePrice = calculateHistoricalPrice(
                            nextMonthData.salePrice, 
                            trend.price_change_sale
                        );
                        calculatedRentPrice = calculateHistoricalPrice(
                            nextMonthData.rentPrice, 
                            trend.price_change_rent
                        );
                    }
                    
                    priceCache.set(cacheKey, {
                        salePrice: calculatedSalePrice,
                        rentPrice: calculatedRentPrice,
                        isCalculated: true
                    });
                }
            }
            
            return sortedTrends.map(trend => {
                const year = trend.property_year;
                const month = trend.property_month;
                const cacheKey = `${year}-${month}`;
                const cachedData = priceCache.get(cacheKey);
                
                if (cachedData) {
                    return {
                        ...trend,
                        calculated_sale_price: cachedData.salePrice,
                        calculated_rent_price: cachedData.rentPrice,
                        is_price_calculated: cachedData.isCalculated
                    };
                }
                
                return trend;
            });
        }

        // Check if current user has admin status
        async function checkUserAdminStatus() {
            try {
                if (window.Telegram && window.Telegram.WebApp && window.Telegram.WebApp.initDataUnsafe && window.Telegram.WebApp.initDataUnsafe.user) {
                    const user = window.Telegram.WebApp.initDataUnsafe.user;
                    if (user && user.id) {
                        // Check if user is admin via API
                        const response = await fetch('/api/check_admin_status', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({ telegram_id: user.id })
                        });
                        
                        if (response.ok) {
                            const data = await response.json();
                            console.log('👤 Admin status check result:', data);
                            return data.is_admin === true;
            } else {
                            console.error('❌ Failed to check admin status:', response.status);
                            return false;
                        }
                    }
                }
                console.log('⚠️ No user data available for admin check');
                return false;
            } catch (error) {
                console.error('❌ Error checking admin status:', error);
                return false;
            }
        }

        // Generate detailed trends table
        async function generateTrendsTable(trends) {
            console.log('📊 Generating trends table with trends:', trends.length, 'records');
            
            if (!trends || trends.length === 0) {
                console.log('⚠️ No trends data for trends table');
                return '<div class="no-data">Нет данных для отображения</div>';
            }
            
            // Проверяем статус админа пользователя
            const isAdmin = await checkUserAdminStatus();
            console.log(`👤 User admin status: ${isAdmin}`);
            
            // Подготавливаем тренды с рассчитанными историческими ценами
            const trendsWithHistoricalPrices = await prepareTrendsWithHistoricalPrices(trends);
            console.log('🔢 Trends with historical prices prepared:', trendsWithHistoricalPrices.length, 'records');
            
            // Фильтруем тренды по диапазону дат (с учетом статуса админа)
            const filteredTrends = filterTrendsByDateRange(trendsWithHistoricalPrices, isAdmin);
            console.log('🔍 Filtered trends for table:', filteredTrends.length, 'records');
            
            if (filteredTrends.length === 0) {
                console.log('⚠️ No trends in date range for trends table');
                return '<div class="no-data">Нет данных для отображения в выбранном диапазоне</div>';
            }
            
            let html = '<table class="trends-table">';
            html += '<thead><tr>';
            html += `<th>${getText('dateLabel')}</th>`;
            html += `<th>${getText('saleLabel')}<br>(₺/${getText('unit_square_meters')})</th>`;
            html += `<th>${getText('priceChangeLabel')}<br>${getText('saleLabel').toLowerCase()}</th>`;
            html += `<th>${getText('rentLabel')}<br>(₺/${getText('unit_square_meters')})</th>`;
            html += `<th>${getText('priceChangeLabel')}<br>${getText('rentLabel').toLowerCase()}</th>`;
            html += `<th>${getText('yieldLabel')}</th>`;
            html += '</tr></thead><tbody>';
            
            // Добавляем информацию о фильтрации
            const currentDate = new Date();
            const currentYear = currentDate.getFullYear();
            const currentMonth = currentDate.getMonth() + 1;
            
            html += `<tr class="filter-info"><td colspan="6" style="text-align: center; font-size: 11px; color: #666; background: #f8f9fa; padding: 4px;">
                ${getText('trendsFilterInfo').replace('${filteredCount}', filteredTrends.length).replace('${totalCount}', trends.length)}
            </td></tr>`;
            
            filteredTrends.forEach((trend, index) => {
                // Проверяем, является ли этот тренд текущим месяцем
                const isCurrentMonth = trend.property_year === currentYear && trend.property_month === currentMonth;
                const isFutureMonth = trend.property_year > currentYear || (trend.property_year === currentYear && trend.property_month > currentMonth);
                const isHistoricalMonth = trend.property_year < currentYear || (trend.property_year === currentYear && trend.property_month < currentMonth);
                
                let rowClass = '';
                let rowStyle = '';
                
                if (isCurrentMonth) {
                    rowClass = 'current-month-row';
                    rowStyle = 'background-color: #e8f4fd;';
                } else if (isFutureMonth) {
                    rowClass = 'forecast-row';
                    rowStyle = 'background-color: #f0f8ff;';
                }                     else if (isHistoricalMonth) {
                        rowClass = 'historical-row';
                        rowStyle = '';
                }
                
                // Используем рассчитанные цены для исторических месяцев
                const salePrice = trend.is_price_calculated ? trend.calculated_sale_price : trend.unit_price_for_sale;
                const rentPrice = trend.is_price_calculated ? trend.calculated_rent_price : trend.unit_price_for_rent;
                
                html += `<tr class="${rowClass}" style="${rowStyle}">`;
                html += `<td>${formatTrendDateShort(trend.date)}</td>`;
                html += `<td>${formatTrendValue(salePrice, 'price')}</td>`;
                html += `<td>${formatPercentage(trend.price_change_sale)}</td>`;
                html += `<td>${formatTrendValue(rentPrice, 'price')}</td>`;
                html += `<td>${formatPercentage(trend.price_change_rent)}</td>`;
                html += `<td>${formatTrendValue(trend.yield, 'percentage')}</td>`;
                html += '</tr>';
            });
            
            html += '</tbody></table>';
            
            // Добавляем график трендов
            html += `
                <div class="trends-chart-section">
                    <h4 class="trends-chart-title">${getText('chart_title')}</h4>
                    <div class="chart-controls">
                        <button class="chart-button active" data-chart-type="sale" onclick="switchChartType('sale')">
                            ${getText('sale_button')}
                        </button>
                        <button class="chart-button" data-chart-type="rent" onclick="switchChartType('rent')">
                            ${getText('rent_button')}
                        </button>
                    </div>
                    <div class="chart-container">
                        <canvas id="trendsChart" width="400" height="200"></canvas>
                    </div>
                    <div class="chart-info">
                        <small style="color: #6c757d; font-style: italic; text-align: center; display: block; margin-top: 10px;">
                            ${getText('chart_info')}
                        </small>
                    </div>
                </div>
            `;
            
            // Добавляем блок "Вывод по тренду"
            html += await generateTrendsAnalysis(trends);
            
            // Инициализируем график прогноза после добавления HTML
            setTimeout(async () => {
                // Подготавливаем тренды с рассчитанными историческими ценами (как в таблице)
                const trendsWithHistoricalPrices = await prepareTrendsWithHistoricalPrices(trends);
                
                // Находим данные прогноза для графика
                const currentDate = new Date();
                const currentYear = currentDate.getFullYear();
                const currentMonth = currentDate.getMonth() + 1;
                
                const forecastTrends = trendsWithHistoricalPrices.filter(trend => {
                    if (trend.property_year > currentYear) {
                        return true; // Будущие годы
                    } else if (trend.property_year === currentYear) {
                        return trend.property_month >= currentMonth - 1; // 1 месяц до текущего + текущий + будущие
                    } else if (trend.property_year === currentYear - 1) {
                        // Для случая, когда текущий месяц - январь, а предыдущий - декабрь прошлого года
                        return currentMonth === 1 && trend.property_month === 12;
                    }
                    return false;
                });
                
                if (forecastTrends.length > 0) {
                    console.log('📊 Initializing forecast chart with calculated prices:', forecastTrends.length, 'records');
                    initializeForecastChart(forecastTrends);
                }
            }, 100);
            
            return html;
        }
        
        // Generate trends analysis based on table data
        async function generateTrendsAnalysis(trends) {
            console.log('📊 Generating trends analysis with trends:', trends.length, 'records');
            
            if (!trends || trends.length === 0) {
                console.log('⚠️ No trends data for trends analysis');
                return '';
            }
            
            // Подготавливаем тренды с рассчитанными ценами (как в таблице)
            const trendsWithCalculatedPrices = await prepareTrendsWithHistoricalPrices(trends);
            
            // Получаем текущую дату для определения периода анализа
            const currentDate = new Date();
            const currentYear = currentDate.getFullYear();
            const currentMonth = currentDate.getMonth() + 1; // JavaScript месяцы начинаются с 0
            
            console.log('🗓️ Current date for analysis:', currentYear, currentMonth);
            
            // Фильтруем только исторические данные (до текущего месяца включительно)
            const historicalTrends = trendsWithCalculatedPrices.filter(trend => {
                const trendDate = new Date(trend.property_year, trend.property_month - 1);
                const currentDateObj = new Date(currentYear, currentMonth - 1);
                return trendDate <= currentDateObj;
            });
            
            // Сортируем по дате (от старых к новым)
            const sortedTrends = historicalTrends.sort((a, b) => {
                if (a.property_year !== b.property_year) {
                    return a.property_year - b.property_year;
                }
                return a.property_month - b.property_month;
            });
            
            // Ограничиваем анализ последними 12 месяцами
            const last12MonthsTrends = sortedTrends.slice(-12);
            
            console.log('🔍 Historical trends for analysis:', last12MonthsTrends.length, 'records');
            console.log('📅 Analysis period:', 
                last12MonthsTrends.length > 0 ? `${last12MonthsTrends[0].property_year}-${last12MonthsTrends[0].property_month}` : 'N/A',
                'to',
                last12MonthsTrends.length > 0 ? `${last12MonthsTrends[last12MonthsTrends.length - 1].property_year}-${last12MonthsTrends[last12MonthsTrends.length - 1].property_month}` : 'N/A'
            );
            
            if (last12MonthsTrends.length < 2) {
                console.log('⚠️ Insufficient data for trends analysis (need at least 2 months)');
                return '';
            }
            
            // Находим первый и последний месяц для анализа (из последних 12 месяцев)
            const firstMonth = last12MonthsTrends[0];
            const lastMonth = last12MonthsTrends[last12MonthsTrends.length - 1];
            
            if (!firstMonth || !lastMonth) {
                return '';
            }
            
            // Используем РАССЧИТАННЫЕ цены из таблицы (приоритет calculated_*_price)
            const firstSalePrice = parseFloat(firstMonth.calculated_sale_price || firstMonth.unit_price_for_sale) || 0;
            const lastSalePrice = parseFloat(lastMonth.calculated_sale_price || lastMonth.unit_price_for_sale) || 0;
            const salePriceGrowth = firstSalePrice > 0 ? ((lastSalePrice - firstSalePrice) / firstSalePrice * 100) : 0;
            
            // Рассчитываем общий рост цен на аренду
            const firstRentPrice = parseFloat(firstMonth.calculated_rent_price || firstMonth.unit_price_for_rent) || 0;
            const lastRentPrice = parseFloat(lastMonth.calculated_rent_price || lastMonth.unit_price_for_rent) || 0;
            const rentPriceGrowth = firstRentPrice > 0 ? ((lastRentPrice - firstRentPrice) / firstRentPrice * 100) : 0;
            
            // Анализируем диапазон доходности (только для последних 12 месяцев)
            const yields = last12MonthsTrends.map(t => parseFloat(t.yield) || 0).filter(y => y > 0);
            const minYield = yields.length > 0 ? Math.min(...yields) : 0;
            const maxYield = yields.length > 0 ? Math.max(...yields) : 0;
            
            // Определяем тренд доходности (растет, падает или стабилен)
            let yieldTrend = '';
            if (yields.length >= 2) {
                const firstYield = yields[0];
                const lastYield = yields[yields.length - 1];
                const yieldChange = lastYield - firstYield;
                
                if (Math.abs(yieldChange) < 0.5) {
                    yieldTrend = 'стабильна';
                } else if (yieldChange > 0.5) {
                    yieldTrend = 'растет';
                } else {
                    yieldTrend = 'снижается';
                }
            }
            
            // Форматируем названия месяцев
            const monthNames = {
                'ru': ['январь', 'февраль', 'март', 'апрель', 'май', 'июнь',
                       'июль', 'август', 'сентябрь', 'октябрь', 'ноябрь', 'декабрь'],
                'en': ['January', 'February', 'March', 'April', 'May', 'June',
                       'July', 'August', 'September', 'October', 'November', 'December'],
                'de': ['Januar', 'Februar', 'März', 'April', 'Mai', 'Juni',
                       'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'],
                'fr': ['janvier', 'février', 'mars', 'avril', 'mai', 'juin',
                       'juillet', 'août', 'septembre', 'octobre', 'novembre', 'décembre'],
                'tr': ['Ocak', 'Şubat', 'Mart', 'Nisan', 'Mayıs', 'Haziran',
                       'Temmuz', 'Ağustos', 'Eylül', 'Ekim', 'Kasım', 'Aralık']
            };
            const currentLang = currentLanguage || 'ru';
            const monthList = monthNames[currentLang] || monthNames['ru'];
            
            const firstMonthName = monthList[firstMonth.property_month - 1] || '';
            const lastMonthName = monthList[lastMonth.property_month - 1] || '';
            
            // Формируем аналитический вывод
            let analysis = '<div class="trends-analysis-section">';
            analysis += `<h4 class="trends-analysis-title">${getText('trendsAnalysisTitle')}</h4>`;
            analysis += '<div class="trends-analysis-content">';
            
            if (salePriceGrowth > 0 && rentPriceGrowth > 0) {
                analysis += `${getText('marketGrowthText')}. `;
                analysis += `${getText('fromToText')} ${firstMonthName} ${getText('byToText')} ${lastMonthName} ${firstMonth.property_year} ${getText('yearText')} `;
                analysis += `${getText('salesPricesGrewText')} ${salePriceGrowth.toFixed(1)}%, `;
                analysis += `${getText('rentGrewText')} ${rentPriceGrowth.toFixed(1)}%. `;
                analysis += `${getText('yieldLabel')} ${getText('yieldRangeText')} ${minYield.toFixed(1)}–${maxYield.toFixed(1)}%, `;
                analysis += `${getText('showingInvestmentAttractivenessText')}. `;
                
                if (yieldTrend) {
                    analysis += `${getText('currentTrendIndicatesText')} ${yieldTrend === 'стабильна' ? getText('stabilityText') : yieldTrend === 'растет' ? getText('gradualIncreaseText') : getText('gradualDecreaseText')} `;
                    analysis += `${getText('yieldStabilityText')}.`;
                } else {
                    analysis += `${getText('currentTrendIndicatesText')} ${getText('gradualDecreaseText')} роста цен и доходности, но ${getText('yieldStabilityText')}.`;
                }
            } else if (salePriceGrowth > 0 || rentPriceGrowth > 0) {
                analysis += `${getText('mixedDynamicsText')}. `;
                if (salePriceGrowth > 0) {
                    analysis += `${getText('salesPricesGrewByText')} ${salePriceGrowth.toFixed(1)}%, `;
                }
                if (rentPriceGrowth > 0) {
                    analysis += `${getText('rentGrewByText')} ${rentPriceGrowth.toFixed(1)}%. `;
                }
                analysis += `${getText('yieldLabel')} ${getText('yieldRangeText')} ${minYield.toFixed(1)}–${maxYield.toFixed(1)}% `;
                analysis += `${getText('maintainsAttractivenessText')}.`;
            } else {
                analysis += `${getText('marketStabilityText')}. `;
                analysis += `${getText('yieldLabel')} ${getText('yieldRangeText')} ${minYield.toFixed(1)}–${maxYield.toFixed(1)}% `;
                analysis += `${getText('investmentPotentialText')}.`;
            }
            
            analysis += '</div></div>';
            
            // Добавляем блок "Вывод по объекту"
            console.log('🔍 Adding object summary to analysis...');
            const objectSummary = await generateObjectSummary(marketSummaryData);
            console.log('📊 Object summary result:', objectSummary);
            
            if (objectSummary) {
                analysis += objectSummary;
                console.log('✅ Object summary added to analysis');
            } else {
                console.log('⚠️ Object summary is empty, not adding to analysis');
            }
            
            // Добавляем таблицу "Прогноз цены и аренды"
            analysis += await generateForecastTable(trends);
            
            return analysis;
        }
        
        // Get exchange rate from currency table or API
        async function getExchangeRate(fromCurrency, toCurrency) {
            try {
                console.log(`🔄 Getting exchange rate: ${fromCurrency} -> ${toCurrency}`);
                
                // Сначала пытаемся получить курс из таблицы currency на текущую дату
                const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
                console.log(`📅 Requesting rate for date: ${today}`);
                
                const response = await fetch('/api/currency/rate', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        from_currency: fromCurrency,
                        to_currency: toCurrency,
                        date: today
                    })
                });
                
                console.log(`📡 API response status: ${response.status}`);
                
                if (response.ok) {
                    const data = await response.json();
                    console.log(`📊 API response data:`, data);
                    if (data.success && data.rate) {
                        console.log(`✅ Exchange rate from DB: ${fromCurrency} to ${toCurrency} = ${data.rate}`);
                        return data.rate;
                    }
                }
                
                // Если курс не найден в БД, получаем его через API
                console.log(`🔄 Getting exchange rate from API: ${fromCurrency} to ${toCurrency}`);
                const apiResponse = await fetch('/api/currency/update', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        from_currency: fromCurrency,
                        to_currency: toCurrency
                    })
                });
                
                console.log(`📡 API update response status: ${apiResponse.status}`);
                
                if (apiResponse.ok) {
                    const apiData = await apiResponse.json();
                    console.log(`📊 API update response data:`, apiData);
                    if (apiData.success && apiData.rate) {
                        console.log(`✅ Exchange rate from API: ${fromCurrency} to ${toCurrency} = ${apiData.rate}`);
                        return apiData.rate;
                    }
                }
                
                console.log(`⚠️ Failed to get exchange rate for ${fromCurrency} to ${toCurrency}`);
                return 1; // Возвращаем 1 как fallback
                
            } catch (error) {
                console.error('Error getting exchange rate:', error);
                return 1; // Возвращаем 1 как fallback
            }
        }

        // Recalculate object summary when currency changes
        async function recalculateObjectSummary() {
            if (!window.currentSummaryData) {
                console.log('⚠️ No summary data available for recalculation');
                return;
            }
            
            console.log('🔄 Recalculating object summary with new currency...');
            
            // Find the object summary section and update it
            const objectSummarySection = document.querySelector('.object-summary-section');
            if (objectSummarySection) {
                const newSummary = await generateObjectSummary(marketSummaryData);
                if (newSummary) {
                    objectSummarySection.outerHTML = newSummary;
                    console.log('✅ Object summary updated with new currency');
                }
            }
        }
        
        // Generate object summary block with market comparison
        async function generateObjectSummary(marketSummary = null) {
            try {
                console.log('🔍 Generating enhanced object summary...');
                
                // Получаем данные объекта из формы
                const objectPrice = parseFloat(document.getElementById('priceObjectInput')?.value) || 0;
                const objectArea = parseFloat(document.getElementById('areaObjectInput')?.value) || 0;
                const selectedCountry = selectedLocation.country_name || '';
                
                // Получаем выбранную валюту из кнопок
                const selectedCurrencyButton = document.querySelector('.currency-button.active');
                const objectCurrency = selectedCurrencyButton ? selectedCurrencyButton.dataset.currency : 'EUR';
                
                console.log('📊 Object data:', {
                    price: objectPrice,
                    area: objectArea,
                    country: selectedCountry,
                    currency: objectCurrency
                });
                
                if (!objectPrice || !objectArea || !selectedCountry) {
                    console.log('⚠️ Missing required data for object summary');
                    return '';
                }
                
                // Рассчитываем цену за м²
                const pricePerM2 = objectPrice / objectArea;
                
                // Определяем целевую валюту
                let targetCurrency = '';
                if (selectedCountry.toLowerCase().includes('türkiye') || selectedCountry.toLowerCase().includes('turkey')) {
                    targetCurrency = 'TRY';
                } else {
                    targetCurrency = 'EUR';
                }
                
                    // Получаем курс валюты
                let exchangeRate = 1;
                if (objectCurrency !== targetCurrency) {
                    exchangeRate = await getExchangeRate(objectCurrency, targetCurrency);
                }
                
                // Конвертируем цену
                const convertedPricePerM2 = pricePerM2 * exchangeRate;
                const currencySymbol = targetCurrency === 'TRY' ? '₺' : '€';
                
                // Начинаем создание компактного HTML
                let html = '<div class="object-summary-section">';
                html += `<h4 class="object-summary-title">${getText('objectSummaryTitle')}</h4>`;
                html += '<div class="object-summary-content">';
                
                // Создаем компактную таблицу с основными данными и сравнениями
                html += '<table class="object-comparison-table">';
                html += '<tbody>';
                
                // Строка 1: Цена за м²
                html += '<tr>';
                html += `<td class="comparison-label">${getText('pricePerM2Label')}:</td>`;
                html += `<td class="comparison-value"><strong>${currencySymbol}${convertedPricePerM2.toFixed(2)}</strong></td>`;
                html += '</tr>';
                
                // Строка 2: Площадь объекта
                html += '<tr>';
                html += `<td class="comparison-label">${getText('areaLabel')}:</td>`;
                html += `<td class="comparison-value"><strong>${objectArea} ${getText('unit_square_meters')}</strong></td>`;
                html += '</tr>';
                
                // Если есть данные рынка, добавляем сравнения
                if (marketSummary) {
                    console.log('📊 Adding market comparisons with summary:', marketSummary);
                    
                    // Сравнение цены продажи
                    if (marketSummary.unit_price_for_sale) {
                        const minPrice = marketSummary.unit_price_for_sale.min;
                        const maxPrice = marketSummary.unit_price_for_sale.max;
                        
                        // Расчет отклонения от минимальной цены
                        const minDiff = ((convertedPricePerM2 - minPrice) / minPrice * 100);
                        const maxDiff = ((convertedPricePerM2 - maxPrice) / maxPrice * 100);
                        
                        html += '<tr>';
                        html += `<td class="comparison-label">${getText('vsMinMarketPriceLabel')}:</td>`;
                        // Для цены: дешевле (отрицательное) = зеленый, дороже (положительное) = красный
                        html += `<td class="comparison-value ${minDiff < 0 ? 'comparison-cheaper' : 'comparison-expensive'}">`;
                        html += `${minDiff >= 0 ? '+' : ''}${minDiff.toFixed(1)}%</td>`;
                        html += '</tr>';
                        
                        html += '<tr>';
                        html += `<td class="comparison-label">${getText('vsMaxMarketPriceLabel')}:</td>`;
                        // Для цены: дешевле (отрицательное) = зеленый, дороже (положительное) = красный
                        html += `<td class="comparison-value ${maxDiff < 0 ? 'comparison-cheaper' : 'comparison-expensive'}">`;
                        html += `${maxDiff >= 0 ? '+' : ''}${maxDiff.toFixed(1)}%</td>`;
                        html += '</tr>';
                    }
                    
                    // Сравнение площади
                    if (marketSummary.comparable_area_for_sale) {
                        const avgMarketArea = Math.round((marketSummary.comparable_area_for_sale.min + marketSummary.comparable_area_for_sale.max) / 2);
                        const areaDiff = ((objectArea - avgMarketArea) / avgMarketArea * 100);
                        
                        html += '<tr>';
                        html += `<td class="comparison-label">${getText('vsAvgAreaLabel')}:</td>`;
                        // Для площади: меньше (отрицательное) = красный, больше (положительное) = зеленый
                        html += `<td class="comparison-value ${areaDiff >= 0 ? 'comparison-larger' : 'comparison-smaller'}">`;
                        html += `${areaDiff >= 0 ? '+' : ''}${areaDiff.toFixed(1)}%</td>`;
                        html += '</tr>';
                    }
                    
                    // Расчет примерной аренды
                    if (marketSummary.unit_price_for_rent) {
                        const minRent = marketSummary.unit_price_for_rent.min * objectArea;
                        const maxRent = marketSummary.unit_price_for_rent.max * objectArea;
                        
                        html += '<tr class="rental-estimate">';
                        html += `<td class="comparison-label">${getText('estimatedRentLabel')}:</td>`;
                        html += `<td class="comparison-value"><strong>${currencySymbol}${minRent.toFixed(0)} – ${currencySymbol}${maxRent.toFixed(0)}</strong></td>`;
                        html += '</tr>';
                    }
                }
                
                html += '</tbody>';
                html += '</table>';
                
                // Добавляем текстовый вывод под таблицей
                if (marketSummary) {
                    let textSummary = '';
                    
                    // Анализируем цену
                    let priceAnalysis = '';
                    if (marketSummary.unit_price_for_sale) {
                        const minPrice = marketSummary.unit_price_for_sale.min;
                        const maxPrice = marketSummary.unit_price_for_sale.max;
                        const minDiff = ((convertedPricePerM2 - minPrice) / minPrice * 100);
                        const maxDiff = ((convertedPricePerM2 - maxPrice) / maxPrice * 100);
                        
                        if (minDiff < 0 && maxDiff < 0) {
                            priceAnalysis = getText('cheaperThanBothText');
                        } else if (minDiff >= 0 && maxDiff < 0) {
                            priceAnalysis = getText('betweenMinMaxText');
                        } else {
                            priceAnalysis = getText('expensiveThanBothText');
                        }
                    }
                    
                    // Анализируем площадь
                    let areaAnalysis = '';
                    if (marketSummary.comparable_area_for_sale) {
                        const avgMarketArea = Math.round((marketSummary.comparable_area_for_sale.min + marketSummary.comparable_area_for_sale.max) / 2);
                        const areaDiff = ((objectArea - avgMarketArea) / avgMarketArea * 100);
                        
                        if (areaDiff >= 0) {
                            areaAnalysis = getText('largerAreaText');
                        } else {
                            areaAnalysis = getText('smallerAreaText');
                        }
                    }
                    
                    if (priceAnalysis && areaAnalysis) {
                        textSummary = `<div class="object-analysis-text">${getText('yourObjectLabel')} ${priceAnalysis} ${getText('andText')} ${areaAnalysis}.</div>`;
                    }
                    
                    html += textSummary;
                }
                
                html += '</div></div>';
                
                console.log('📝 Generated enhanced HTML for object summary');
                return html;
            } catch (error) {
                console.error('Error generating enhanced object summary:', error);
                return '';
            }
        }
        
        // Generate forecast table for current and future months
        async function generateForecastTable(trends) {
            if (!trends || trends.length === 0) {
                console.log('⚠️ No trends data for forecast table');
                return '';
            }
            
            console.log('📊 Generating forecast table with trends:', trends.length, 'records');
            
            // Проверяем доступ пользователя к премиум функциям
            const userAccess = await checkUserAccess();
            console.log('🔍 User access check for forecast:', userAccess);
            
            if (!userAccess.hasAccess) {
                console.log('⚠️ User does not have access to forecast features');
                return generateSubscriptionMessage();
            }
            
            // Подготавливаем тренды с рассчитанными историческими ценами (как в детальной таблице)
            const trendsWithHistoricalPrices = await prepareTrendsWithHistoricalPrices(trends);
            console.log('🔢 Prepared trends with calculated prices for forecast:', trendsWithHistoricalPrices.length, 'records');
            
            // Получаем текущую дату
            const currentDate = new Date();
            const currentYear = currentDate.getFullYear();
            const currentMonth = currentDate.getMonth() + 1; // getMonth() returns 0-11
            
            console.log('📅 Current date:', currentYear, currentMonth);
            
            // Фильтруем тренды: 1 месяц до текущего + текущий + будущие месяцы
            const forecastTrends = trendsWithHistoricalPrices.filter(trend => {
                if (trend.property_year > currentYear) {
                    return true; // Будущие годы
                } else if (trend.property_year === currentYear) {
                    return trend.property_month >= currentMonth - 1; // 1 месяц до текущего + текущий + будущие
                } else if (trend.property_year === currentYear - 1) {
                    // Для случая, когда текущий месяц - январь, а предыдущий - декабрь прошлого года
                    return currentMonth === 1 && trend.property_month === 12;
                }
                return false;
            });
            
            console.log('🔮 Filtered forecast trends (1 previous + current + future):', forecastTrends.length, 'records');
            
            if (forecastTrends.length === 0) {
                return '';
            }
            
            // Сортируем по дате (от текущего к будущему)
            forecastTrends.sort((a, b) => {
                if (a.property_year !== b.property_year) {
                    return a.property_year - b.property_year;
                }
                return a.property_month - b.property_month;
            });
            
            // Формируем таблицу прогноза
            let forecastHtml = '<div class="forecast-table-section">';
            forecastHtml += `<h4 class="forecast-table-title">${getText('forecastSaleLabel')} и ${getText('forecastRentLabel')}</h4>`;
            forecastHtml += '<div class="forecast-table-container">';
            forecastHtml += '<table class="forecast-table">';
            forecastHtml += '<thead><tr>';
            forecastHtml += `<th>${getText('dateLabel')}</th>`;
            forecastHtml += `<th>${getText('forecastSaleLabel')}<br>(₺/${getText('unit_square_meters')})</th>`;
            forecastHtml += `<th>${getText('forecastRentLabel')}<br>(₺/${getText('unit_square_meters')})</th>`;
            forecastHtml += `<th>${getText('forecastYieldLabel')}</th>`;
            forecastHtml += '</tr></thead><tbody>';
            
            // Добавляем информацию о прогнозе
            forecastHtml += `<tr class="forecast-info"><td colspan="4" style="text-align: center; font-size: 11px; color: #666; background: #f8f9fa; padding: 4px;">
                ${getText('forecastBasedOnText')} ${getText('forecastMonthsInfo').replace('${months}', forecastTrends.length)}
            </td></tr>`;
            
            forecastTrends.forEach((trend, index) => {
                // Определяем тип месяца для стилизации
                const isCurrentMonth = trend.property_year === currentYear && trend.property_month === currentMonth;
                const isPreviousMonth = (trend.property_year === currentYear && trend.property_month === currentMonth - 1) ||
                                      (currentMonth === 1 && trend.property_year === currentYear - 1 && trend.property_month === 12);
                const isFutureMonth = trend.property_year > currentYear || 
                                    (trend.property_year === currentYear && trend.property_month > currentMonth);
                
                let rowClass = 'forecast-row';
                let rowStyle = '';
                
                if (isCurrentMonth) {
                    rowClass = 'current-month-row';
                    rowStyle = 'background-color: #e8f4fd; font-weight: bold;';
                } else if (isPreviousMonth) {
                    rowClass = 'previous-month-row';
                    rowStyle = 'background-color: #f8f9fa;';
                } // Будущие месяцы остаются без дополнительного стиля
                
                // Используем рассчитанные цены если они есть, иначе исходные
                const salePrice = trend.is_price_calculated ? trend.calculated_sale_price : trend.unit_price_for_sale;
                const rentPrice = trend.is_price_calculated ? trend.calculated_rent_price : trend.unit_price_for_rent;
                const yieldValue = trend.yield;
                
                console.log(`🔮 Forecast row ${index + 1}: ${formatTrendDateShort(trend.date)} - Sale: ${salePrice}, Rent: ${rentPrice}, Type: ${isCurrentMonth ? 'current' : isPreviousMonth ? 'previous' : 'future'}`);
                
                forecastHtml += `<tr class="${rowClass}" style="${rowStyle}">`;
                forecastHtml += `<td>${formatTrendDateShort(trend.date)}</td>`;
                forecastHtml += `<td>${formatTrendValue(salePrice, 'price')}</td>`;
                forecastHtml += `<td>${formatTrendValue(rentPrice, 'price')}</td>`;
                forecastHtml += `<td>${formatTrendValue(yieldValue, 'percentage')}</td>`;
                forecastHtml += '</tr>';
            });
            
            forecastHtml += '</tbody></table>';
            forecastHtml += '</div></div>';
            
            // Добавляем график прогноза цен и аренды
            forecastHtml += `
                <div class="forecast-chart-section" id="forecastChartSection">
                    <h4 class="forecast-chart-title">${getText('forecast_chart_title')}</h4>
                    <div class="chart-controls">
                        <button class="chart-button active" data-chart-type="sale" onclick="switchForecastChartType('sale')">
                            ${getText('sale_button')}
                        </button>
                        <button class="chart-button" data-chart-type="rent" onclick="switchForecastChartType('rent')">
                            ${getText('rent_button')}
                        </button>
                    </div>
                    <div class="chart-container">
                        <canvas id="forecastChart" width="400" height="200"></canvas>
                    </div>
                    <div class="chart-info">
                        <small style="color: #6c757d; font-style: italic; text-align: center; display: block; margin-top: 10px;">
                            ${getText('forecast_chart_info')}
                        </small>
                    </div>
                </div>
            `;
            
            // Добавляем блок "Вывод прогноза"
            forecastHtml += await generateForecastAnalysis(forecastTrends);
            
            return forecastHtml;
        }
        
        // Generate forecast analysis based on forecast table data
        async function generateForecastAnalysis(forecastTrends) {
            if (!forecastTrends || forecastTrends.length === 0) {
                return '';
            }
            
            // Проверяем доступ пользователя к премиум функциям
            const userAccess = await checkUserAccess();
            console.log('🔍 User access check for forecast analysis:', userAccess);
            
            if (!userAccess.hasAccess) {
                console.log('⚠️ User does not have access to forecast analysis features');
                return generateSubscriptionMessage();
            }
            
            // Сортируем тренды по дате для правильного анализа
            const sortedTrends = forecastTrends.sort((a, b) => {
                if (a.property_year !== b.property_year) {
                    return a.property_year - b.property_year;
                }
                return a.property_month - b.property_month;
            });
            
            // Находим первый и последний месяц для анализа
            const firstMonth = sortedTrends[0];
            const lastMonth = sortedTrends[sortedTrends.length - 1];
            
            if (!firstMonth || !lastMonth) {
                return '';
            }
            
            // Рассчитываем рост цен на продажу
            const firstSalePrice = parseFloat(firstMonth.unit_price_for_sale) || 0;
            const lastSalePrice = parseFloat(lastMonth.unit_price_for_sale) || 0;
            const salePriceGrowth = firstSalePrice > 0 ? ((lastSalePrice - firstSalePrice) / firstSalePrice * 100) : 0;
            
            // Рассчитываем рост цен на аренду
            const firstRentPrice = parseFloat(firstMonth.unit_price_for_rent) || 0;
            const lastRentPrice = parseFloat(lastMonth.unit_price_for_rent) || 0;
            const rentPriceGrowth = firstRentPrice > 0 ? ((lastRentPrice - firstRentPrice) / firstRentPrice * 100) : 0;
            
            // Анализируем диапазон доходности
            const yields = forecastTrends.map(t => parseFloat(t.yield) || 0).filter(y => y > 0);
            const minYield = yields.length > 0 ? Math.min(...yields) : 0;
            const maxYield = yields.length > 0 ? Math.max(...yields) : 0;
            
            // Определяем тренд доходности
            let yieldTrend = '';
            if (yields.length >= 2) {
                const firstYield = yields[0];
                const lastYield = yields[yields.length - 1];
                const yieldChange = lastYield - firstYield;
                
                if (Math.abs(yieldChange) < 0.5) {
                    yieldTrend = 'стабильность';
                } else if (yieldChange > 0.5) {
                    yieldTrend = 'рост';
                } else {
                    yieldTrend = 'снижение';
                }
            }
            
            // Форматируем названия месяцев
            const monthNames = {
                'ru': ['январь', 'февраль', 'март', 'апрель', 'май', 'июнь',
                       'июль', 'август', 'сентябрь', 'октябрь', 'ноябрь', 'декабрь'],
                'en': ['January', 'February', 'March', 'April', 'May', 'June',
                       'July', 'August', 'September', 'October', 'November', 'December'],
                'de': ['Januar', 'Februar', 'März', 'April', 'Mai', 'Juni',
                       'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'],
                'fr': ['janvier', 'février', 'mars', 'avril', 'mai', 'juin',
                       'juillet', 'août', 'septembre', 'octobre', 'novembre', 'décembre'],
                'tr': ['Ocak', 'Şubat', 'Mart', 'Nisan', 'Mayıs', 'Haziran',
                       'Temmuz', 'Ağustos', 'Eylül', 'Ekim', 'Kasım', 'Aralık']
            };
            
            const firstMonthName = monthNames[userLanguage] ? monthNames[userLanguage][firstMonth.property_month - 1] : monthNames['ru'][firstMonth.property_month - 1];
            const lastMonthName = monthNames[userLanguage] ? monthNames[userLanguage][lastMonth.property_month - 1] : monthNames['ru'][lastMonth.property_month - 1];
            
            // Формируем аналитический вывод на разных языках
            const analysisTexts = {
                'ru': {
                    'title': 'Вывод прогноза',
                    'sale': `${getText('saleLabel')} ожидается стабильный рост цен с ${formatValue(firstSalePrice, 'price')}/м² в ${firstMonthName} ${firstMonth.property_year} до ${formatValue(lastSalePrice, 'price')}/м² в ${lastMonthName} ${lastMonth.property_year} (+${salePriceGrowth.toFixed(1)}% за ${forecastTrends.length} месяцев).`,
                    'rent': `${getText('rentLabel')} прогнозируется увеличение с ${formatValue(firstRentPrice, 'price')}/м² до ${formatValue(lastRentPrice, 'price')}/м² (+${rentPriceGrowth.toFixed(1)}%).`,
                    'yield': `${getText('yieldLabel')}: остаётся на уровне ${minYield.toFixed(1)}–${maxYield.toFixed(1)}%, с лёгким ${yieldTrend === 'снижение' ? 'снижением' : yieldTrend === 'рост' ? 'ростом' : 'изменением'} к ${lastMonthName} ${lastMonth.property_year} года.`
                },
                'en': {
                    'title': 'Forecast Analysis',
                    'sale': `Sales: stable price growth is expected from ${formatValue(firstSalePrice, 'price')}/m² in ${firstMonthName} ${firstMonth.property_year} to ${formatValue(lastSalePrice, 'price')}/m² in ${lastMonthName} ${lastMonth.property_year} (+${salePriceGrowth.toFixed(1)}% over ${forecastTrends.length} months).`,
                    'rent': `Rent: increase is forecasted from ${formatValue(firstRentPrice, 'price')}/m² to ${formatValue(lastRentPrice, 'price')}/m² (+${rentPriceGrowth.toFixed(1)}%).`,
                    'yield': `Yield: remains at ${minYield.toFixed(1)}–${maxYield.toFixed(1)}%, with a slight ${yieldTrend === 'снижение' ? 'decrease' : yieldTrend === 'рост' ? 'increase' : 'change'} by ${lastMonthName} ${lastMonth.property_year}.`
                },
                'de': {
                    'title': 'Prognose-Analyse',
                    'sale': `Verkauf: Stabile Preiserhöhung wird erwartet von ${formatValue(firstSalePrice, 'price')}/m² im ${firstMonthName} ${firstMonth.property_year} bis ${formatValue(lastSalePrice, 'price')}/m² im ${lastMonthName} ${lastMonth.property_year} (+${salePriceGrowth.toFixed(1)}% über ${forecastTrends.length} Monate).`,
                    'rent': `Miete: Anstieg wird prognostiziert von ${formatValue(firstRentPrice, 'price')}/m² auf ${formatValue(lastRentPrice, 'price')}/m² (+${rentPriceGrowth.toFixed(1)}%).`,
                    'yield': `Rendite: bleibt bei ${minYield.toFixed(1)}–${maxYield.toFixed(1)}%, mit leichter ${yieldTrend === 'снижение' ? 'Abnahme' : yieldTrend === 'рост' ? 'Zunahme' : 'Änderung'} bis ${lastMonthName} ${lastMonth.property_year}.`
                },
                'fr': {
                    'title': 'Analyse des prévisions',
                    'sale': `Vente: une croissance stable des prix est attendue de ${formatValue(firstSalePrice, 'price')}/m² en ${firstMonthName} ${firstMonth.property_year} à ${formatValue(lastSalePrice, 'price')}/m² en ${lastMonthName} ${lastMonth.property_year} (+${salePriceGrowth.toFixed(1)}% sur ${forecastTrends.length} mois).`,
                    'rent': `Location: une augmentation est prévue de ${formatValue(firstRentPrice, 'price')}/m² à ${formatValue(lastRentPrice, 'price')}/m² (+${rentPriceGrowth.toFixed(1)}%).`,
                    'yield': `Rendement: reste à ${minYield.toFixed(1)}–${maxYield.toFixed(1)}%, avec une légère ${yieldTrend === 'снижение' ? 'diminution' : yieldTrend === 'рост' ? 'augmentation' : 'variation'} d'ici ${lastMonthName} ${lastMonth.property_year}.`
                },
                'tr': {
                    'title': 'Tahmin Analizi',
                    'sale': `Satış: ${firstMonthName} ${firstMonth.property_year}'de ${formatValue(firstSalePrice, 'price')}/m²'den ${lastMonthName} ${lastMonth.property_year}'de ${formatValue(lastSalePrice, 'price')}/m²'ye kararlı fiyat artışı bekleniyor (+${salePriceGrowth.toFixed(1)}% ${forecastTrends.length} ay boyunca).`,
                    'rent': `Kiralama: ${formatValue(firstRentPrice, 'price')}/m²'den ${formatValue(lastRentPrice, 'price')}/m²'ye artış öngörülüyor (+${rentPriceGrowth.toFixed(1)}%).`,
                    'yield': `Getiri: ${minYield.toFixed(1)}–${maxYield.toFixed(1)}% seviyesinde kalıyor, ${lastMonthName} ${lastMonth.property_year}'ye kadar hafif ${yieldTrend === 'снижение' ? 'azalma' : yieldTrend === 'рост' ? 'artış' : 'değişim'} ile.`
                }
            };
            
            // Получаем текст для текущего языка
            const currentLanguage = userLanguage || 'ru';
            const texts = analysisTexts[currentLanguage] || analysisTexts['ru'];
            
            // Формируем HTML для блока анализа прогноза
            let analysisHtml = '<div class="forecast-analysis-section">';
            analysisHtml += `<h4 class="forecast-analysis-title">${texts.title}</h4>`;
            analysisHtml += '<div class="forecast-analysis-content">';
            analysisHtml += `<p><strong>${texts.sale.split(':')[0]}:</strong> ${texts.sale.split(':')[1]}</p>`;
            analysisHtml += `<p><strong>${texts.rent.split(':')[0]}:</strong> ${texts.rent.split(':')[1]}</p>`;
            analysisHtml += `<p><strong>${texts.yield.split(':')[0]}:</strong> ${texts.yield.split(':')[1]}</p>`;
            analysisHtml += '</div></div>';
            
            // Добавляем блок "Прогноз цен"
            analysisHtml += await generatePriceForecastBlock(forecastTrends);
            
            return analysisHtml;
        }
        
        // Generate price forecast block for user's property
        async function generatePriceForecastBlock(forecastTrends) {
            if (!forecastTrends || forecastTrends.length === 0) {
                return '';
            }
            
            // Проверяем доступ пользователя к премиум функциям
            const userAccess = await checkUserAccess();
            console.log('🔍 User access check for price forecast:', userAccess);
            
            if (!userAccess.hasAccess) {
                console.log('⚠️ User does not have access to price forecast features');
                return generateSubscriptionMessage();
            }
            
            // Получаем данные пользователя
            const userPrice = selectedListingTypes.price || 0;
            const userArea = selectedListingTypes.area || 0;
            const userCurrency = selectedListingTypes.currency || 'EUR';
            
            if (!userPrice || !userArea) {
                return '';
            }
            
            console.log('👤 User data for price forecast:', {
                userPrice: userPrice,
                userArea: userArea,
                userCurrency: userCurrency,
                userPricePerM2: userPrice / userArea
            });
            
            // Применяем расчет исторических цен к трендам
            const trendsWithCalculatedPrices = await prepareTrendsWithHistoricalPrices(forecastTrends);
            
            // Сортируем тренды по дате для правильного анализа
            const sortedTrends = trendsWithCalculatedPrices.sort((a, b) => {
                if (a.property_year !== b.property_year) {
                    return a.property_year - b.property_year;
                }
                return a.property_month - b.property_month;
            });
            
            // Находим текущий месяц (первый в отсортированном списке) и последний месяц
            const currentMonthTrend = sortedTrends[0];
            const lastMonthTrend = sortedTrends[sortedTrends.length - 1];
            
            if (!currentMonthTrend || !lastMonthTrend) {
                return '';
            }
            
            // Получаем текущую дату для определения текущего месяца
            const currentDate = new Date();
            const currentYear = currentDate.getFullYear();
            const currentMonth = currentDate.getMonth() + 1;
            
            // Проверяем, является ли первый тренд текущим месяцем
            const isFirstTrendCurrentMonth = currentMonthTrend.property_year === currentYear && currentMonthTrend.property_month === currentMonth;
            
            // Определяем тренды для расчетов
            const baseTrend = isFirstTrendCurrentMonth ? currentMonthTrend : sortedTrends.find(t => t.property_year === currentYear && t.property_month === currentMonth) || currentMonthTrend;
            const futureTrend = lastMonthTrend;
            
            if (!baseTrend || !futureTrend) {
                return '';
            }
            
            // Рассчитываем прогнозную цену продажи для объекта пользователя
            // Используем РАССЧИТАННЫЕ цены вместо базовых из БД
            const futureSalePricePerM2 = parseFloat(futureTrend.is_price_calculated ? futureTrend.calculated_sale_price : futureTrend.unit_price_for_sale) || 0;
            const forecastSalePriceInTRY = userArea * futureSalePricePerM2; // В лирах
            
            // Рассчитываем прогнозную ставку аренды
            // Используем РАССЧИТАННЫЕ цены вместо базовых из БД
            const futureRentPricePerM2 = parseFloat(futureTrend.is_price_calculated ? futureTrend.calculated_rent_price : futureTrend.unit_price_for_rent) || 0;
            const forecastRentPriceInTRY = userArea * futureRentPricePerM2; // В лирах
            
            console.log('🔮 Price forecast calculations:', {
                futureTrend: `${futureTrend.property_year}-${futureTrend.property_month}`,
                isCalculated: futureTrend.is_price_calculated,
                salePricePerM2: futureSalePricePerM2,
                rentPricePerM2: futureRentPricePerM2,
                userArea: userArea,
                totalSaleTRY: forecastSalePriceInTRY,
                totalRentTRY: forecastRentPriceInTRY
            });
            
            // Получаем актуальный курс валют из таблицы currency
            let tryToEurRate = 1; // По умолчанию 1:1
            let currencyDate = 'недоступно';
            try {
                // Получаем курс TRY к EUR из таблицы currency
                const currencyResponse = await fetch('/api/currency/latest', {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });
                
                if (currencyResponse.ok) {
                    const currencyData = await currencyResponse.json();
                    if (currencyData.success && currencyData.data) {
                        console.log('📊 Currency data received:', currencyData.data);
                        // В таблице currency базовая валюта - EUR
                        // Поле 'try' показывает сколько TRY за 1 EUR
                        // Нам нужен курс TRY к EUR для конвертации
                        const eurToTryRate = parseFloat(currencyData.data.try || 1);
                        tryToEurRate = 1 / eurToTryRate;
                        
                        // Извлекаем дату курса для дисклеймера
                        if (currencyData.created_at) {
                            const date = new Date(currencyData.created_at);
                            currencyDate = date.toLocaleDateString('ru-RU');
                        }
                        
                        console.log(`💱 Exchange rate: 1 EUR = ${eurToTryRate} TRY, 1 TRY = ${tryToEurRate} EUR (from ${currencyDate})`);
                    }
                }
            } catch (error) {
                console.log('⚠️ Failed to get exchange rates, using approximate values');
                // Используем примерный курс TRY к EUR как fallback
                tryToEurRate = 0.03; // Примерно 1 TRY = 0.03 EUR
                currencyDate = 'примерный';
            }
            
            console.log(`💱 Final exchange rate: 1 TRY = ${tryToEurRate} EUR`);
            
            // Конвертируем цены из лир в евро
            const forecastSalePriceInEUR = forecastSalePriceInTRY * tryToEurRate;
            const forecastRentPriceInEUR = forecastRentPriceInTRY * tryToEurRate;
            
            // Рассчитываем динамику роста цен
            const baseSalePricePerM2 = parseFloat(baseTrend.is_price_calculated ? baseTrend.calculated_sale_price : baseTrend.unit_price_for_sale) || 0;
            const baseRentPricePerM2 = parseFloat(baseTrend.is_price_calculated ? baseTrend.calculated_rent_price : baseTrend.unit_price_for_rent) || 0;
            
            // Рассчитываем цену пользователя в TRY и EUR
            const userPricePerM2 = userPrice / userArea;
            let userPriceInTRY = userPrice;
            let userPriceInEUR = userPrice;
            
            // Конвертируем цену пользователя в нужную валюту
            if (userCurrency === 'EUR') {
                userPriceInEUR = userPrice;
                userPriceInTRY = userPrice / tryToEurRate;
            } else if (userCurrency === 'TRY') {
                userPriceInTRY = userPrice;
                userPriceInEUR = userPrice * tryToEurRate;
            }
            
            // Рассчитываем текущую рыночную стоимость объекта
            const marketSalePriceInTRY = userArea * baseSalePricePerM2;
            const marketSalePriceInEUR = marketSalePriceInTRY * tryToEurRate;
            const marketRentPriceInTRY = userArea * baseRentPricePerM2;
            const marketRentPriceInEUR = marketRentPriceInTRY * tryToEurRate;
            
            // Сравнение цены пользователя с рыночной ценой
            const userVsMarketDiff = userPriceInEUR > 0 ? ((marketSalePriceInEUR - userPriceInEUR) / userPriceInEUR * 100) : 0;
            
            // Рассчитываем прирост от рыночной цены
            const marketSalePriceGrowth = baseSalePricePerM2 > 0 ? ((futureSalePricePerM2 - baseSalePricePerM2) / baseSalePricePerM2 * 100) : 0;
            const rentPriceGrowth = baseRentPricePerM2 > 0 ? ((futureRentPricePerM2 - baseRentPricePerM2) / baseRentPricePerM2 * 100) : 0;
            
            // Рассчитываем прирост от цены пользователя
            const userPriceGrowth = userPriceInEUR > 0 ? ((forecastSalePriceInEUR - userPriceInEUR) / userPriceInEUR * 100) : 0;
            
            // Рассчитываем количество месяцев прогноза
            const monthsDiff = (futureTrend.property_year - baseTrend.property_year) * 12 + (futureTrend.property_month - baseTrend.property_month);
            
            // Рассчитываем доходность
            const currentYield = parseFloat(baseTrend.yield) || 0;
            const futureYield = parseFloat(futureTrend.yield) || 0;
            const avgYield = (currentYield + futureYield) / 2;
            
            // ROI за весь период прогноза (используем прирост от цены пользователя)
            const totalROI = userPriceGrowth;
            
            // Срок окупаемости (в годах) = стоимость покупки пользователя / годовая аренда
            const annualRent = forecastRentPriceInEUR * 12;
            const paybackPeriod = userPriceInEUR > 0 ? (userPriceInEUR / annualRent) : 0;
            
            console.log('💰 Enhanced price calculations:', {
                userArea: userArea,
                userPriceInEUR: userPriceInEUR,
                marketSalePriceInEUR: marketSalePriceInEUR,
                forecastSalePriceInEUR: forecastSalePriceInEUR,
                userVsMarketDiff: userVsMarketDiff,
                marketSalePriceGrowth: marketSalePriceGrowth,
                userPriceGrowth: userPriceGrowth,
                rentPriceGrowth: rentPriceGrowth,
                totalROI: totalROI,
                avgYield: avgYield,
                paybackPeriod: paybackPeriod,
                monthsDiff: monthsDiff,
                tryToEurRate: tryToEurRate
            });
            
            // Форматируем названия месяцев
            const monthNames = {
                'ru': ['январь', 'февраль', 'март', 'апрель', 'май', 'июнь',
                       'июль', 'август', 'сентябрь', 'октябрь', 'ноябрь', 'декабрь'],
                'en': ['January', 'February', 'March', 'April', 'May', 'June',
                       'July', 'August', 'September', 'October', 'November', 'December'],
                'de': ['Januar', 'Februar', 'März', 'April', 'Mai', 'Juni',
                       'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'],
                'fr': ['janvier', 'février', 'mars', 'avril', 'mai', 'juin',
                       'juillet', 'août', 'septembre', 'octobre', 'novembre', 'décembre'],
                'tr': ['Ocak', 'Şubat', 'Mart', 'Nisan', 'Mayıs', 'Haziran',
                       'Temmuz', 'Ağustos', 'Eylül', 'Ekim', 'Kasım', 'Aralık']
            };
            
            const currentLanguage = userLanguage || 'ru';
            const monthNamesList = monthNames[currentLanguage] || monthNames['ru'];
            
            const futureMonthName = monthNamesList[futureTrend.property_month - 1] || '';
            
            // Формируем тексты на разных языках
            const forecastTexts = {
                'ru': {
                    'title': getText('priceForecastTitle'),
                    'currentPrice': getText('currentPriceLabel'),
                    'futurePrice': getText('futurePriceLabel'),
                    'userSaleLabel': getText('userSalePriceLabel'),
                    'marketSaleLabel': getText('marketSalePriceLabel'),
                    'rentLabel': getText('rentRateLabel'),
                    'metricsTitle': getText('keyMetricsLabel'),
                    'priceGrowth': getText('priceGrowthLabel'),
                    'rentGrowth': getText('rentGrowthLabel'), 
                    'avgYield': getText('avgYieldLabel'),
                    'totalROI': getText('totalROILabel'),
                    'paybackPeriod': getText('paybackPeriodLabel'),
                    'forecastPeriod': getText('forecastPeriodLabel'),
                    'years': getText('yearsUnit'),
                    'months': getText('monthsUnit'),
                    'date': `${futureMonthName} ${futureTrend.property_year}`,
                    'currencyInfo': `${getText('exchangeRateText')}: 1 EUR = ₺${(1 / tryToEurRate).toFixed(2)}`
                },
                'en': {
                    'title': 'Price Forecast',
                    'currentPrice': 'Current Value',
                    'futurePrice': 'Forecast Value',
                    'userSaleLabel': 'Sale Price',
                    'marketSaleLabel': 'Current Market Calculated Price',
                    'rentLabel': 'Rent Rate',
                    'metricsTitle': 'Key Metrics',
                    'priceGrowth': 'Price Growth',
                    'rentGrowth': 'Rent Growth',
                    'avgYield': 'Average Yield',
                    'totalROI': 'ROI for period',
                    'paybackPeriod': 'Payback Period',
                    'forecastPeriod': 'Forecast Period',
                    'years': 'years',
                    'months': 'months',
                    'date': `${futureMonthName} ${futureTrend.property_year}`,
                    'currencyInfo': `${getText('exchangeRateText')}: 1 EUR = ₺${(1 / tryToEurRate).toFixed(2)}`
                }
            };
            
            const texts = forecastTexts[currentLanguage] || forecastTexts['ru'];
            
            // Формируем HTML для блока прогноза цен в стиле "Показатели рынка"
            let forecastHtml = '<div class="price-forecast-table-block">';
            
            // Основная таблица в стиле показателей рынка
            forecastHtml += '<table class="price-forecast-market-table">';
            forecastHtml += '<thead>';
            forecastHtml += '<tr>';
            forecastHtml += `<th class="forecast-category-header">${texts.currentPrice}</th>`;
            forecastHtml += `<th class="forecast-category-header">${texts.futurePrice}</th>`;
            forecastHtml += '</tr>';
            forecastHtml += '</thead>';
            forecastHtml += '<tbody>';
            
            // Строка 1: Цена продажи
            forecastHtml += '<tr>';
            forecastHtml += '<td class="forecast-data-cell">';
            forecastHtml += `<div class="forecast-cell-label">${texts.userSaleLabel}:</div>`;
            forecastHtml += `<div class="forecast-cell-value user-price">€${userPriceInEUR.toLocaleString('ru-RU', { minimumFractionDigits: 0, maximumFractionDigits: 0 })}</div>`;
            forecastHtml += '</td>';
            forecastHtml += '<td class="forecast-data-cell">';
            forecastHtml += `<div class="forecast-cell-label">${texts.userSaleLabel}:</div>`;
            forecastHtml += `<div class="forecast-cell-value">€${forecastSalePriceInEUR.toLocaleString('ru-RU', { minimumFractionDigits: 0, maximumFractionDigits: 0 })}</div>`;
            forecastHtml += `<div class="forecast-cell-growth ${userPriceGrowth >= 0 ? 'positive' : 'negative'}">${userPriceGrowth >= 0 ? '+' : ''}${userPriceGrowth.toFixed(1)}%</div>`;
            forecastHtml += '</td>';
            forecastHtml += '</tr>';
            
            // Строка 2: Рыночная цена
            forecastHtml += '<tr>';
            forecastHtml += '<td class="forecast-data-cell">';
            forecastHtml += `<div class="forecast-cell-label">${texts.marketSaleLabel}:</div>`;
            forecastHtml += `<div class="forecast-cell-value market-price">€${marketSalePriceInEUR.toLocaleString('ru-RU', { minimumFractionDigits: 0, maximumFractionDigits: 0 })}</div>`;
            forecastHtml += `<div class="forecast-cell-growth ${userVsMarketDiff >= 0 ? 'positive' : 'negative'}">${getText('toYourPriceLabel')}: ${userVsMarketDiff >= 0 ? '+' : ''}${userVsMarketDiff.toFixed(1)}%</div>`;
            forecastHtml += '</td>';
            forecastHtml += '<td class="forecast-data-cell">';
            forecastHtml += `<div class="forecast-cell-label">${texts.marketSaleLabel}:</div>`;
            forecastHtml += `<div class="forecast-cell-value">€${forecastSalePriceInEUR.toLocaleString('ru-RU', { minimumFractionDigits: 0, maximumFractionDigits: 0 })}</div>`;
            forecastHtml += `<div class="forecast-cell-growth ${marketSalePriceGrowth >= 0 ? 'positive' : 'negative'}">${marketSalePriceGrowth >= 0 ? '+' : ''}${marketSalePriceGrowth.toFixed(1)}%</div>`;
            forecastHtml += '</td>';
            forecastHtml += '</tr>';
            
            // Строка 3: Ставка аренды
            forecastHtml += '<tr>';
            forecastHtml += '<td class="forecast-data-cell">';
            forecastHtml += `<div class="forecast-cell-label">${texts.rentLabel}:</div>`;
            forecastHtml += `<div class="forecast-cell-value">€${marketRentPriceInEUR.toLocaleString('ru-RU', { minimumFractionDigits: 0, maximumFractionDigits: 0 })}/мес</div>`;
            forecastHtml += '</td>';
            forecastHtml += '<td class="forecast-data-cell">';
            forecastHtml += `<div class="forecast-cell-label">${texts.rentLabel}:</div>`;
            forecastHtml += `<div class="forecast-cell-value">€${forecastRentPriceInEUR.toLocaleString('ru-RU', { minimumFractionDigits: 0, maximumFractionDigits: 0 })}/мес</div>`;
            forecastHtml += `<div class="forecast-cell-growth ${rentPriceGrowth >= 0 ? 'positive' : 'negative'}">${rentPriceGrowth >= 0 ? '+' : ''}${rentPriceGrowth.toFixed(1)}%</div>`;
            forecastHtml += '</td>';
            forecastHtml += '</tr>';
            
            forecastHtml += '</tbody>';
            forecastHtml += '</table>';
            
            // Блок с ключевыми метриками (компактный в 2 столбца)
            forecastHtml += `<div class="forecast-metrics-compact-section">`;
            forecastHtml += `<h5 class="forecast-metrics-compact-title">${texts.metricsTitle}</h5>`;
            forecastHtml += '<div class="forecast-metrics-compact-grid">';
            
            forecastHtml += '<div class="metric-compact-item">';
            forecastHtml += `<span class="metric-compact-label">${texts.avgYield}:</span>`;
            forecastHtml += `<span class="metric-compact-value">${avgYield.toFixed(1)}%</span>`;
            forecastHtml += '</div>';
            
            forecastHtml += '<div class="metric-compact-item">';
            forecastHtml += `<span class="metric-compact-label">${texts.totalROI}:</span>`;
            forecastHtml += `<span class="metric-compact-value ${totalROI >= 0 ? 'positive' : 'negative'}">${totalROI >= 0 ? '+' : ''}${totalROI.toFixed(1)}%</span>`;
            forecastHtml += '</div>';
            
            forecastHtml += '<div class="metric-compact-item">';
            forecastHtml += `<span class="metric-compact-label">${texts.paybackPeriod}:</span>`;
            forecastHtml += `<span class="metric-compact-value">${paybackPeriod.toFixed(1)} ${texts.years}</span>`;
            forecastHtml += '</div>';
            
            forecastHtml += '<div class="metric-compact-item">';
            forecastHtml += `<span class="metric-compact-label">${texts.forecastPeriod}:</span>`;
            forecastHtml += `<span class="metric-compact-value">${monthsDiff} ${texts.months}</span>`;
            forecastHtml += '</div>';
            
            forecastHtml += '</div>'; // Закрываем forecast-metrics-compact-grid
            forecastHtml += '</div>'; // Закрываем forecast-metrics-compact-section
            
            // Дата прогноза и курс валют
            forecastHtml += `<div class="price-forecast-date">${texts.date}</div>`;
            forecastHtml += `<div class="price-forecast-currency-info">${texts.currencyInfo}</div>`;
            
            // Добавляем дисклеймер о прогнозе
            const today = new Date().toLocaleDateString('ru-RU');
            const disclaimerTexts = {
                'ru': `прогноз сделан на основании текущей динамики и очищен от инфляции и курсовых разниц, актуален на ${today}`,
                'en': `forecast based on current dynamics and adjusted for inflation and exchange rate differences, current as of ${today}`,
                'de': `Prognose basiert auf aktueller Dynamik und ist bereinigt um Inflation und Wechselkursunterschiede, aktuell zum ${today}`,
                'fr': `prévision basée sur la dynamique actuelle et ajustée pour l'inflation et les différences de change, actuelle au ${today}`,
                'tr': `tahmin mevcut dinamiklere dayanmakta ve enflasyon ve döviz kuru farklarından arındırılmıştır, ${today} tarihinde geçerlidir`
            };
            
            const disclaimerText = disclaimerTexts[currentLanguage] || disclaimerTexts['ru'];
            forecastHtml += `<div class="price-forecast-disclaimer">${disclaimerText}</div>`;
            forecastHtml += '</div>'; // Закрываем price-forecast-table-block
            
            return forecastHtml;
        }
        
        // Format trend value based on type
        function formatTrendValue(value, type) {
            if (value === null || value === undefined) return '-';
            
            if (type && type.includes('price')) {
                return formatValue(value, 'price');
            } else if (type && type.includes('percentage')) {
                return formatValue(value, 'percentage');
            } else if (typeof value === 'number') {
                // Если это число, форматируем его
                if (value >= 1000) {
                    return value.toLocaleString('ru-RU');
                } else {
                    return value.toFixed(2);
                }
            } else {
                return value.toString();
            }
        }
        
        // Helper function to format values consistently
        function formatValue(value, type) {
            if (value === null || value === undefined) return '-';
            
            if (type === 'price') {
                if (typeof value === 'number') {
                    return `₺${value.toLocaleString('ru-RU', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
                }
                return value.toString();
            } else if (type === 'percentage') {
                if (typeof value === 'number') {
                    return `${value.toFixed(2)}%`;
                }
                return value.toString();
            }
            
            return value.toString();
        }
        
        // Format trend period
        function formatTrendPeriod(period) {
            if (!period) return '';
            
            // Convert period to readable format
            const periodMap = {
                'monthly': 'Месячный',
                'quarterly': 'Квартальный',
                'yearly': 'Годовой',
                'weekly': 'Недельный'
            };
            
            return periodMap[period] || period;
        }

        // Get AI insights for the region data




        // Show error
        function showError(message) {
            const errorState = document.getElementById('errorState');
            const errorText = document.getElementById('errorText');
            
            errorText.textContent = message;
            errorState.style.display = 'block';
        }

        // Function to go to main menu
        function goToMainMenu() {
            window.location.href = '/webapp_main';
        }

        // Function to convert currency to EUR (base currency)
        async function convertToEUR(amount, fromCurrency) {
            if (fromCurrency === 'EUR') {
                return amount;
            }
            
            try {
                // Get current exchange rates from currency table
                const response = await fetch('/api/currency/convert', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        amount: amount,
                        from_currency: fromCurrency,
                        to_currency: 'EUR'
                    })
                });
                
                const data = await response.json();
                if (data.success) {
                    return data.converted_amount;
                } else {
                    console.error('Currency conversion error:', data.error);
                    return amount; // Return original amount if conversion fails
                }
            } catch (error) {
                console.error('Error converting currency:', error);
                return amount; // Return original amount if conversion fails
            }
        }

        // Initialize page
        async function init() {
            // Получаем язык пользователя через API с учетом новой логики
            await getUserLanguage();
            currentLanguage = userLanguage;
            
            console.log(`🌐 Initializing page with language: ${currentLanguage}`);
            
            updatePageText();
            loadCountries();
            
            // Initialize additional components
            setupCheckboxHandlers();
            initPhotoUpload();
            
            // Дополнительная проверка полей ввода
            setTimeout(() => {
                const priceField = document.getElementById('priceObjectInput');
                const areaField = document.getElementById('areaObjectInput');
                
                console.log('🔍 Checking input fields after init:');
                console.log('Price field:', {
                    exists: !!priceField,
                    disabled: priceField?.disabled,
                    readonly: priceField?.readOnly,
                    pointerEvents: priceField?.style.pointerEvents,
                    cursor: priceField?.style.cursor
                });
                console.log('Area field:', {
                    exists: !!areaField,
                    disabled: areaField?.disabled,
                    readonly: areaField?.readOnly,
                    pointerEvents: areaField?.style.pointerEvents,
                    cursor: areaField?.style.cursor
                });
            }, 100);
            
            // Initialize price input
            const priceInput = document.getElementById('priceObjectInput');
            if (priceInput) {
                // Принудительно активируем поле
                priceInput.removeAttribute('disabled');
                priceInput.removeAttribute('readonly');
                priceInput.style.pointerEvents = 'auto';
                priceInput.style.cursor = 'text';
                
                // Добавляем отладочные обработчики
                priceInput.addEventListener('click', function() {
                    console.log('🖱️ Price input clicked');
                    this.focus();
                });
                
                priceInput.addEventListener('focus', function() {
                    console.log('🎯 Price input focused');
                });
                
                priceInput.addEventListener('input', function() {
                    console.log('⌨️ Price input changed:', this.value);
                    selectedListingTypes.price = this.value ? parseFloat(this.value) : null;
                    updateConfirmButton();
                    
                    // Recalculate object summary if data is already loaded
                    if (window.currentSummaryData) {
                        console.log('🔄 Price changed, recalculating object summary...');
                        recalculateObjectSummary();
                    }
                });
            }
            
            // Initialize area input
            const areaInput = document.getElementById('areaObjectInput');
            if (areaInput) {
                // Принудительно активируем поле
                areaInput.removeAttribute('disabled');
                areaInput.removeAttribute('readonly');
                areaInput.style.pointerEvents = 'auto';
                areaInput.style.cursor = 'text';
                
                // Добавляем отладочные обработчики
                areaInput.addEventListener('click', function() {
                    console.log('🖱️ Area input clicked');
                    this.focus();
                });
                
                areaInput.addEventListener('focus', function() {
                    console.log('🎯 Area input focused');
                });
                
                areaInput.addEventListener('input', function() {
                    console.log('⌨️ Area input changed:', this.value);
                    selectedListingTypes.area = this.value ? parseInt(this.value) : null;
                    updateConfirmButton();
                    
                    // Recalculate object summary if data is already loaded
                    if (window.currentSummaryData) {
                        console.log('🔄 Area changed, recalculating object summary...');
                        recalculateObjectSummary();
                    }
                });
            }
            
            // Initialize currency buttons
            const currencyButtons = document.querySelectorAll('.currency-button');
            currencyButtons.forEach(button => {
                button.addEventListener('click', function() {
                    const selectedCurrency = this.dataset.currency;
                    
                    // Remove active class from all buttons
                    currencyButtons.forEach(btn => btn.classList.remove('active'));
                    
                    // Add active class to clicked button
                    this.classList.add('active');
                    
                    // Update selected currency
                    selectedListingTypes.currency = selectedCurrency;
                    
                    // Recalculate object summary if data is already loaded
                    if (window.currentSummaryData) {
                        console.log('🔄 Currency changed, recalculating object summary...');
                        recalculateObjectSummary();
                    }
                });
            });
            
            // Set EUR as default active currency
            const eurButton = document.querySelector('.currency-button[data-currency="EUR"]');
            if (eurButton) {
                eurButton.classList.add('active');
                selectedListingTypes.currency = 'EUR';
            }
        }

        // Start initialization when page loads
        document.addEventListener('DOMContentLoaded', init);

        // Generate consolidated assessment block with market analysis (только для админов)
        async function generateConsolidatedAssessment(data) {
            if (!data) return '';
            
            // Check if user is admin
            try {
                const userAccess = await checkUserAccess();
                if (!userAccess.hasAccess || userAccess.reason !== 'admin') {
                    // User is not admin, return empty string to hide the block
                    return '';
                }
            } catch (error) {
                console.error('Error checking user access:', error);
                // On error, hide the block
                return '';
            }
            
            // Define coefficients for each category
            const coefficients = {
                house_type: 0.40,      // 40% - спальни
                age: 0.30,             // 30% - возраст
                floor_segment: 0.20,   // 20% - этаж
                heating: 0.10          // 10% - отопление
            };
            
            // Extract data for each category
            const houseTypeData = data.house_type_data && data.house_type_data.length > 0 ? data.house_type_data[0] : null;
            const floorSegmentData = data.floor_segment_data && data.floor_segment_data.length > 0 ? data.floor_segment_data[0] : null;
            const ageData = data.age_data && data.age_data.length > 0 ? data.age_data[0] : null;
            const heatingData = data.heating_data && data.heating_data.length > 0 ? data.heating_data[0] : null;
            
            // Calculate consolidated values
            const salePrice = calculateConsolidatedValue([
                { value: houseTypeData?.unit_price_for_sale, coefficient: coefficients.house_type, name: 'Спальни' },
                { value: floorSegmentData?.unit_price_for_sale, coefficient: coefficients.floor_segment, name: 'Этаж' },
                { value: ageData?.unit_price_for_sale, coefficient: coefficients.age, name: 'Возраст' },
                { value: heatingData?.unit_price_for_sale, coefficient: coefficients.heating, name: 'Отопление' }
            ]);
            
            const rentPrice = calculateConsolidatedValue([
                { value: houseTypeData?.unit_price_for_rent, coefficient: coefficients.house_type, name: 'Спальни' },
                { value: floorSegmentData?.unit_price_for_rent, coefficient: coefficients.floor_segment, name: 'Этаж' },
                { value: ageData?.unit_price_for_rent, coefficient: coefficients.age, name: 'Возраст' },
                { value: heatingData?.unit_price_for_rent, coefficient: coefficients.heating, name: 'Отопление' }
            ]);
            
            const yield = calculateConsolidatedValue([
                { value: houseTypeData?.yield, coefficient: coefficients.house_type, name: 'Спальни' },
                { value: floorSegmentData?.yield, coefficient: coefficients.floor_segment, name: 'Этаж' },
                { value: ageData?.yield, coefficient: coefficients.age, name: 'Возраст' },
                { value: heatingData?.yield, coefficient: coefficients.heating, name: 'Отопление' }
            ]);
            
            // Generate HTML for consolidated assessment
            let html = '<div class="consolidated-assessment-section">';
            html += `<h4 class="consolidated-assessment-title">${getText('marketAnalysisTitle')}</h4>`;
            html += '<div class="consolidated-assessment-content">';
            
            // Sale Price Section
            html += '<div class="assessment-category">';
            html += `<h5 class="assessment-category-title">${getText('salePriceTitle')}</h5>`;
            html += '<div class="assessment-items">';
            
            if (houseTypeData?.unit_price_for_sale) {
                const listingType = houseTypeData.listing_type || '1+1';
                html += `<div class="assessment-item">
                    <span class="assessment-label">${getText('bedroomsLabel')} ${listingType}:</span>
                    <span class="assessment-value">${formatValue(houseTypeData.unit_price_for_sale, 'price')}</span>
                </div>`;
            }
            
            if (floorSegmentData?.unit_price_for_sale) {
                const listingType = floorSegmentData.listing_type || 'Giriş';
                html += `<div class="assessment-item">
                    <span class="assessment-label">${getText('floorLabel')} ${listingType}:</span>
                    <span class="assessment-value">${formatValue(floorSegmentData.unit_price_for_sale, 'price')}</span>
                </div>`;
            }
            
            if (ageData?.unit_price_for_sale) {
                const listingType = ageData.listing_type || '0–4';
                html += `<div class="assessment-item">
                    <span class="assessment-label">${getText('ageLabel')} ${listingType}:</span>
                    <span class="assessment-value">${formatValue(ageData.unit_price_for_sale, 'price')}</span>
                </div>`;
            }
            
            if (heatingData?.unit_price_for_sale) {
                const listingType = heatingData.listing_type || 'Yok';
                html += `<div class="assessment-item">
                    <span class="assessment-label">${getText('heatingLabel')} ${listingType}:</span>
                    <span class="assessment-value">${formatValue(heatingData.unit_price_for_sale, 'price')}</span>
                </div>`;
            }
            
            html += '</div>';
            if (salePrice.calculated) {
                html += `<div class="assessment-consolidated">
                    <span class="assessment-consolidated-label">${getText('consolidatedAverageLabel')}</span>
                    <span class="assessment-consolidated-value">≈ ${formatValue(salePrice.value, 'price')}/${getText('unit_square_meters')}</span>
                </div>`;
            }
            html += '</div>';
            
            // Rent Price Section
            html += '<div class="assessment-category">';
            html += `<h5 class="assessment-category-title">${getText('rentPriceTitle')}</h5>`;
            html += '<div class="assessment-items">';
            
            if (houseTypeData?.unit_price_for_rent) {
                const listingType = houseTypeData.listing_type || '1+1';
                html += `<div class="assessment-item">
                    <span class="assessment-label">${getText('bedroomsLabel')} ${listingType}:</span>
                    <span class="assessment-value">${formatValue(houseTypeData.unit_price_for_rent, 'price')}</span>
                </div>`;
            }
            
            if (floorSegmentData?.unit_price_for_rent) {
                const listingType = floorSegmentData.listing_type || 'Giriş';
                html += `<div class="assessment-item">
                    <span class="assessment-label">${getText('floorLabel')} ${listingType}:</span>
                    <span class="assessment-value">${formatValue(floorSegmentData.unit_price_for_rent, 'price')}</span>
                </div>`;
            }
            
            if (ageData?.unit_price_for_rent) {
                const listingType = ageData.listing_type || '0–4';
                html += `<div class="assessment-item">
                    <span class="assessment-label">${getText('ageLabel')} ${listingType}:</span>
                    <span class="assessment-value">${formatValue(ageData.unit_price_for_rent, 'price')}</span>
                </div>`;
            }
            
            if (heatingData?.unit_price_for_rent) {
                const listingType = heatingData.listing_type || 'Yok';
                html += `<div class="assessment-item">
                    <span class="assessment-label">${getText('heatingLabel')} ${listingType}:</span>
                    <span class="assessment-value">${formatValue(heatingData.unit_price_for_rent, 'price')}</span>
                </div>`;
            }
            
            html += '</div>';
            if (rentPrice.calculated) {
                html += `<div class="assessment-consolidated">
                    <span class="assessment-consolidated-label">${getText('consolidatedAverageLabel')}</span>
                    <span class="assessment-consolidated-value">≈ ${formatValue(rentPrice.value, 'price')}/${getText('unit_square_meters')}</span>
                </div>`;
            }
            html += '</div>';
            
            // Yield Section
            html += '<div class="assessment-category">';
            html += `<h5 class="assessment-category-title">${getText('yieldTitle')}</h5>`;
            html += '<div class="assessment-items">';
            
            if (houseTypeData?.yield) {
                const listingType = houseTypeData.listing_type || '1+1';
                html += `<div class="assessment-item">
                    <span class="assessment-label">${getText('bedroomsLabel')}:</span>
                    <span class="assessment-value">${formatValue(houseTypeData.yield, 'percentage')}</span>
                </div>`;
            }
            
            if (floorSegmentData?.yield) {
                const listingType = floorSegmentData.listing_type || 'Giriş';
                html += `<div class="assessment-item">
                    <span class="assessment-label">${getText('floorLabel')}:</span>
                    <span class="assessment-value">${formatValue(floorSegmentData.yield, 'percentage')}</span>
                </div>`;
            }
            
            if (ageData?.yield) {
                const listingType = ageData.listing_type || '0–4';
                html += `<div class="assessment-item">
                    <span class="assessment-label">${getText('ageLabel')}:</span>
                    <span class="assessment-value">${formatValue(ageData.yield, 'percentage')}</span>
                </div>`;
            }
            
            if (heatingData?.yield) {
                const listingType = heatingData.listing_type || 'Yok';
                html += `<div class="assessment-item">
                    <span class="assessment-label">${getText('heatingLabel')}:</span>
                    <span class="assessment-value">${formatValue(heatingData.yield, 'percentage')}</span>
                </div>`;
            }
            
            html += '</div>';
            if (yield.calculated) {
                html += `<div class="assessment-consolidated">
                    <span class="assessment-consolidated-label">${getText('consolidatedAverageLabel')}</span>
                    <span class="assessment-consolidated-value">≈ ${formatValue(yield.value, 'percentage')}</span>
                </div>`;
            }
            html += '</div>';
            
            html += '</div></div>';
            
            return html;
        }

        // Check if user has access to premium features
        async function checkUserAccess() {
            try {
                const telegramId = getTelegramId();
                if (!telegramId) {
                    console.log('⚠️ No Telegram ID found');
                    return { hasAccess: false, reason: 'no_telegram_id' };
                }
                
                const response = await fetch('/api/check_admin_status', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ telegram_id: telegramId })
                });
                
                if (!response.ok) {
                    console.log('⚠️ Failed to check user access');
                    return { hasAccess: false, reason: 'api_error' };
                }
                
                const data = await response.json();
                console.log('🔍 User access check result:', data);
                console.log('🔍 Raw period_end value:', data.period_end);
                console.log('🔍 Type of period_end:', typeof data.period_end);
                
                if (data.success) {
                    // Check if user is admin
                    if (data.is_admin) {
                        return { hasAccess: true, reason: 'admin' };
                    }
                    
                    // Check if user has active subscription
                    if (data.period_end) {
                        const today = new Date();
                        // Set time to start of day to avoid timezone issues
                        today.setHours(0, 0, 0, 0);
                        
                        const periodEnd = new Date(data.period_end);
                        // Set time to end of day to include the full subscription day
                        periodEnd.setHours(23, 59, 59, 999);
                        
                        console.log('🔍 Date comparison debug:');
                        console.log('  Today:', today.toISOString(), '(', today.toDateString(), ')');
                        console.log('  Period end:', periodEnd.toISOString(), '(', periodEnd.toDateString(), ')');
                        console.log('  Raw period_end from API:', data.period_end);
                        
                        const hasActiveSubscription = today <= periodEnd;
                        console.log('  Has active subscription:', hasActiveSubscription);
                        
                        return { 
                            hasAccess: hasActiveSubscription, 
                            reason: hasActiveSubscription ? 'active_subscription' : 'expired_subscription',
                            periodEnd: data.period_end
                        };
                    }
                    
                    return { hasAccess: false, reason: 'no_subscription' };
                }
                
                return { hasAccess: false, reason: 'api_failed' };
            } catch (error) {
                console.error('❌ Error checking user access:', error);
                return { hasAccess: false, reason: 'error' };
            }
        }
        
        // Generate subscription required message
        function generateSubscriptionMessage() {
            const currentLanguage = userLanguage || 'ru';
            const texts = {
                'ru': {
                    title: 'subscriptionRequiredTitle',
                    benefits: 'subscriptionBenefits',
                    benefit1: 'subscriptionBenefit1',
                    benefit2: 'subscriptionBenefit2',
                    benefit3: 'subscriptionBenefit3',
                    howToSubscribe: 'howToSubscribe',
                    subscribeInstructions: 'subscribeInstructions',
                    followInstructions: 'followInstructions',
                    needHelp: 'needHelp',
                    contactSupport: 'contactSupport'
                },
                'en': {
                    title: 'subscriptionRequiredTitle',
                    benefits: 'subscriptionBenefits',
                    benefit1: 'subscriptionBenefit1',
                    benefit2: 'subscriptionBenefit2',
                    benefit3: 'subscriptionBenefit3',
                    howToSubscribe: 'howToSubscribe',
                    subscribeInstructions: 'subscribeInstructions',
                    followInstructions: 'followInstructions',
                    needHelp: 'needHelp',
                    contactSupport: 'contactSupport'
                },
                'de': {
                    title: 'subscriptionRequiredTitle',
                    benefits: 'subscriptionBenefits',
                    benefit1: 'subscriptionBenefit1',
                    benefit2: 'subscriptionBenefit2',
                    benefit3: 'subscriptionBenefit3',
                    howToSubscribe: 'howToSubscribe',
                    subscribeInstructions: 'subscribeInstructions',
                    followInstructions: 'followInstructions',
                    needHelp: 'needHelp',
                    contactSupport: 'contactSupport'
                },
                'fr': {
                    title: 'subscriptionRequiredTitle',
                    benefits: 'subscriptionBenefits',
                    benefit1: 'subscriptionBenefit1',
                    benefit2: 'subscriptionBenefit2',
                    benefit3: 'subscriptionBenefit3',
                    howToSubscribe: 'howToSubscribe',
                    subscribeInstructions: 'subscribeInstructions',
                    followInstructions: 'followInstructions',
                    needHelp: 'needHelp',
                    contactSupport: 'contactSupport'
                },
                'tr': {
                    title: 'subscriptionRequiredTitle',
                    benefits: 'subscriptionBenefits',
                    benefit1: 'subscriptionBenefit1',
                    benefit2: 'subscriptionBenefit2',
                    benefit3: 'subscriptionBenefit3',
                    howToSubscribe: 'howToSubscribe',
                    subscribeInstructions: 'subscribeInstructions',
                    followInstructions: 'followInstructions',
                    needHelp: 'needHelp',
                    contactSupport: 'contactSupport'
                }
            };
            
            const langTexts = texts[currentLanguage] || texts['ru'];
            
            let messageHtml = '<div class="subscription-required-section">';
            messageHtml += `<h4 class="subscription-required-title">${getText(langTexts.title)}</h4>`;
            messageHtml += '<div class="subscription-required-content">';
            messageHtml += `<p class="subscription-benefits-title">${getText(langTexts.benefits)}</p>`;
            messageHtml += '<ul class="subscription-benefits-list">';
            messageHtml += `<li>${getText(langTexts.benefit1)}</li>`;
            messageHtml += `<li>${getText(langTexts.benefit2)}</li>`;
            messageHtml += `<li>${getText(langTexts.benefit3)}</li>`;
            messageHtml += '</ul>';
            messageHtml += `<p class="subscription-how-title">${getText(langTexts.howToSubscribe)}</p>`;
            messageHtml += `<p class="subscription-instructions">${getText(langTexts.subscribeInstructions)}</p>`;
            messageHtml += `<p class="subscription-follow">${getText(langTexts.followInstructions)}</p>`;
            messageHtml += `<p class="subscription-help">${getText(langTexts.needHelp)}</p>`;
            messageHtml += `<p class="subscription-support">${getText(langTexts.contactSupport)}</p>`;
            messageHtml += '</div></div>';
            
            // Заменяем @username на ссылки
            messageHtml = messageHtml.replace(
                /@Aaadviser_pay_bot/g, 
                '<a href="http://t.me/Aaadviser_pay_bot" target="_blank">@Aaadviser_pay_bot</a>'
            );
            messageHtml = messageHtml.replace(
                /@Aaadviser_support_bot/g, 
                '<a href="http://t.me/Aaadviser_support_bot" target="_blank">@Aaadviser_support_bot</a>'
            );
            
            return messageHtml;
        }
        
        // Calculate consolidated value with coefficients
        function calculateConsolidatedValue(items) {
            const validItems = items.filter(item => item.value !== null && item.value !== undefined && item.value !== 0 && !isNaN(parseFloat(item.value)));
            
            if (validItems.length === 0) {
                return { calculated: false, value: 0 };
            }
            
            // If some items are missing, redistribute coefficients proportionally
            let totalCoefficient = 0;
            validItems.forEach(item => {
                totalCoefficient += item.coefficient;
            });
            
            let weightedSum = 0;
            validItems.forEach(item => {
                const adjustedCoefficient = item.coefficient / totalCoefficient;
                weightedSum += parseFloat(item.value) * adjustedCoefficient;
            });
            
            return {
                calculated: true,
                value: weightedSum
            };
        }
        
        // Глобальные переменные для графика
        let trendsChart = null;
        let currentChartType = 'sale';
        
        // Инициализация графика трендов
        async function initializeTrendsChart(trends) {
            if (!trends || trends.length === 0) {
                console.log('⚠️ No trends data for chart initialization');
                return;
            }
            
            console.log('📊 Initializing trends chart with data:', trends.length, 'records');
            
            // Проверяем статус админа для графика
            const isAdmin = await checkUserAdminStatus();
            console.log(`📊 Chart admin status: ${isAdmin}`);
            
            // Сортируем тренды по дате
            const sortedTrends = trends.sort((a, b) => {
                if (a.property_year !== b.property_year) {
                    return a.property_year - b.property_year;
                }
                return a.property_month - b.property_month;
            });
            
            // Фильтруем данные: до текущего месяца и один месяц вперед
            const today = new Date();
            const currentYear = today.getFullYear();
            const currentMonth = today.getMonth() + 1; // getMonth() returns 0-11
            
            const oneMonthAhead = new Date();
            oneMonthAhead.setMonth(today.getMonth() + 1); // Set to next month
            const oneMonthAheadYear = oneMonthAhead.getFullYear();
            const oneMonthAheadMonth = oneMonthAhead.getMonth() + 1;
            
            const filteredTrends = sortedTrends.filter(trend => {
                const trendDate = new Date(trend.property_year, trend.property_month - 1, 1); // Month is 0-indexed for Date object
                const filterEndDate = new Date(oneMonthAheadYear, oneMonthAheadMonth - 1, 1); // Month is 0-indexed for Date object
                
                // Include trends up to and including the month one month ahead
                return trendDate <= filterEndDate;
            });
            
            console.log('📊 Filtered trends for chart:', filteredTrends.length, 'records');
            console.log('📅 Chart date range: up to', oneMonthAheadMonth, oneMonthAheadYear);
            
            // Создаем график с отфильтрованными данными (с учетом статуса админа)
            createTrendsChart(filteredTrends, currentChartType, isAdmin);
        }
        
        // Создание графика трендов
        function createTrendsChart(trends, chartType, isAdmin = false) {
            const ctx = document.getElementById('trendsChart');
            if (!ctx) {
                console.log('⚠️ Chart canvas not found');
                return;
            }
            
            // Уничтожаем предыдущий график, если он существует
            if (trendsChart) {
                trendsChart.destroy();
            }
            
            // Фильтруем данные для графика в зависимости от статуса пользователя
            let filteredTrends;
            if (isAdmin) {
                // Админы видят все данные
                console.log(`👑 Admin chart access: showing ALL trend data`);
                filteredTrends = trends;
            } else {
                // Обычные пользователи видят данные с января 2021 года
                console.log(`👤 Regular user chart: filtering data from January 2021`);
                filteredTrends = trends.filter(trend => {
                    const isFromJan2021OrLater = trend.property_year > 2021 || 
                                               (trend.property_year === 2021 && trend.property_month >= 1);
                    return isFromJan2021OrLater;
                });
                console.log(`📊 Chart data filtered: ${trends.length} → ${filteredTrends.length} trends (from Jan 2021+)`);
            }
            
            // Подготавливаем данные для графика
            const chartData = prepareChartData(filteredTrends, chartType);
            
            // Создаем новый график
            trendsChart = new Chart(ctx, {
                type: 'line',
                data: chartData,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            titleColor: 'white',
                            bodyColor: 'white',
                            borderColor: '#667eea',
                            borderWidth: 1,
                            callbacks: {
                                label: function(context) {
                                    const value = context.parsed.y;
                                    if (chartType === 'sale') {
                                        return `${getText('salePriceTooltip')}: ₺${value.toLocaleString('ru-RU', { minimumFractionDigits: 2 })}/м²`;
                                    } else {
                                        return `${getText('rentPriceTooltip')}: ₺${value.toLocaleString('ru-RU', { minimumFractionDigits: 2 })}/м²`;
                                    }
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: true,
                                text: getText('monthAxisLabel'),
                                color: '#495057',
                                font: {
                                    size: 12,
                                    weight: '500'
                                }
                            },
                            ticks: {
                                color: '#6c757d',
                                font: {
                                    size: 10
                                }
                            },
                            grid: {
                                color: '#e9ecef',
                                drawBorder: false
                            }
                        },
                        y: {
                            display: true,
                            title: {
                                display: true,
                                text: chartType === 'sale' ? getText('salePriceAxisLabel') : getText('rentPriceAxisLabel'),
                                color: '#495057',
                                font: {
                                    size: 12,
                                    weight: '500'
                                }
                            },
                            ticks: {
                                color: '#6c757d',
                                font: {
                                    size: 10
                                },
                                callback: function(value) {
                                    if (chartType === 'sale') {
                                        return `₺${value.toLocaleString('ru-RU')}`;
                                    } else {
                                        return `₺${value}`;
                                    }
                                }
                            },
                            grid: {
                                color: '#e9ecef',
                                drawBorder: false
                            }
                        }
                    },
                    elements: {
                        line: {
                            tension: 0.4,
                            borderWidth: 3,
                            borderColor: chartType === 'sale' ? '#28a745' : '#ffc107'
                        },
                        point: {
                            radius: 4,
                            backgroundColor: chartType === 'sale' ? '#28a745' : '#ffc107',
                            borderColor: 'white',
                            borderWidth: 2,
                            hoverRadius: 6
                        }
                    },
                    interaction: {
                        mode: 'nearest',
                        axis: 'x',
                        intersect: false
                    }
                }
            });
        }
        
        // Подготовка данных для графика
        function prepareChartData(trends, chartType) {
            const monthNames = {
                'ru': ['Янв', 'Фев', 'Мар', 'Апр', 'Май', 'Июн',
                       'Июл', 'Авг', 'Сен', 'Окт', 'Ноя', 'Дек'],
                'en': ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                       'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
                'de': ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun',
                       'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'],
                'fr': ['jan', 'fév', 'mar', 'avr', 'mai', 'juin',
                       'juil', 'août', 'sep', 'oct', 'nov', 'déc'],
                'tr': ['Oca', 'Şub', 'Mar', 'Nis', 'May', 'Haz',
                       'Tem', 'Ağu', 'Eyl', 'Eki', 'Kas', 'Ara']
            };
            const currentLang = currentLanguage || 'ru';
            const monthList = monthNames[currentLang] || monthNames['ru'];
            
            // Дополнительная фильтрация для обеспечения правильного порядка
            const sortedTrends = trends.sort((a, b) => {
                if (a.property_year !== b.property_year) {
                    return a.property_year - b.property_year;
                }
                return a.property_month - b.property_month;
            });
            
            const labels = sortedTrends.map(trend => {
                const monthName = monthList[trend.property_month - 1] || trend.property_month;
                return `${monthName} ${trend.property_year}`;
            });
            
            const data = sortedTrends.map(trend => {
                if (chartType === 'sale') {
                    // Используем рассчитанные цены для исторических месяцев
                    return parseFloat(trend.is_price_calculated ? trend.calculated_sale_price : trend.unit_price_for_sale) || 0;
                } else {
                    // Используем рассчитанные цены для исторических месяцев
                    return parseFloat(trend.is_price_calculated ? trend.calculated_rent_price : trend.unit_price_for_rent) || 0;
                }
            });
            
            console.log('📊 Chart data prepared:', {
                chartType: chartType,
                dataPoints: data.length,
                dateRange: `${labels[0]} - ${labels[labels.length - 1]}`,
                sampleData: data.slice(0, 3)
            });
            
            return {
                labels: labels,
                datasets: [{
                    data: data,
                    fill: false,
                    pointBackgroundColor: chartType === 'sale' ? '#28a745' : '#ffc107',
                    pointBorderColor: 'white',
                    pointBorderWidth: 2,
                    pointRadius: 4,
                    pointHoverRadius: 6
                }]
            };
        }
        
        // Переключение типа графика
        async function switchChartType(chartType) {
            console.log('🔄 Switching chart type to:', chartType);
            
            // Обновляем активную кнопку
            document.querySelectorAll('.chart-button').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-chart-type="${chartType}"]`).classList.add('active');
            
            // Обновляем тип графика
            currentChartType = chartType;
            
            // Пересоздаем график с отфильтрованными данными
            if (window.currentTrendsData) {
                // Проверяем статус админа для переключения графика
                const isAdmin = await checkUserAdminStatus();
                console.log(`📊 Chart switch admin status: ${isAdmin}`);
                
                // Применяем ту же фильтрацию, что и при инициализации
                const sortedTrends = window.currentTrendsData.sort((a, b) => {
                    if (a.property_year !== b.property_year) {
                        return a.property_year - b.property_year;
                    }
                    return a.property_month - b.property_month;
                });
                
                const today = new Date();
                const oneMonthAhead = new Date();
                oneMonthAhead.setMonth(today.getMonth() + 1);
                const oneMonthAheadYear = oneMonthAhead.getFullYear();
                const oneMonthAheadMonth = oneMonthAhead.getMonth() + 1;
                
                const filteredTrends = sortedTrends.filter(trend => {
                    const trendDate = new Date(trend.property_year, trend.property_month - 1, 1);
                    const filterEndDate = new Date(oneMonthAheadYear, oneMonthAheadMonth - 1, 1);
                    return trendDate <= filterEndDate;
                });
                
                createTrendsChart(filteredTrends, chartType, isAdmin);
            }
        }
        
        // Сохраняем данные трендов глобально для переключения графиков
        window.currentTrendsData = null;
        
        // Глобальные переменные для графика прогноза
        let forecastChart = null;
        let currentForecastChartType = 'sale';
        let currentForecastData = null;
        
        // Инициализация графика прогноза
        function initializeForecastChart(forecastTrends) {
            if (!forecastTrends || forecastTrends.length === 0) {
                console.log('⚠️ No forecast data for chart initialization');
                return;
            }
            
            console.log('📊 Initializing forecast chart with data:', forecastTrends.length, 'records');
            
            // Сохраняем данные глобально
            currentForecastData = forecastTrends;
            
            // Сортируем тренды по дате
            const sortedTrends = forecastTrends.sort((a, b) => {
                if (a.property_year !== b.property_year) {
                    return a.property_year - b.property_year;
                }
                return a.property_month - b.property_month;
            });
            
            // Создаем график прогноза
            createForecastChart(sortedTrends, currentForecastChartType);
        }
        
        // Создание графика прогноза
        function createForecastChart(forecastTrends, chartType) {
            const ctx = document.getElementById('forecastChart');
            if (!ctx) {
                console.log('⚠️ Forecast chart canvas not found');
                return;
            }
            
            // Уничтожаем предыдущий график, если он существует
            if (forecastChart) {
                forecastChart.destroy();
            }
            
            // Подготавливаем данные для графика
            const chartData = prepareForecastChartData(forecastTrends, chartType);
            
            // Создаем новый график
            forecastChart = new Chart(ctx, {
                type: 'line',
                data: chartData,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            titleColor: 'white',
                            bodyColor: 'white',
                            borderColor: '#667eea',
                            borderWidth: 1,
                            callbacks: {
                                label: function(context) {
                                    const value = context.parsed.y;
                                    if (chartType === 'sale') {
                                        return `${getText('saleForecastTooltip')}: ₺${value.toLocaleString('ru-RU', { minimumFractionDigits: 2 })}/${getText('unit_square_meters')}`;
                                    } else {
                                        return `${getText('rentForecastTooltip')}: ₺${value.toLocaleString('ru-RU', { minimumFractionDigits: 2 })}/${getText('unit_square_meters')}`;
                                    }
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: true,
                                text: getText('monthAxisLabel'),
                                color: '#495057',
                                font: {
                                    size: 12,
                                    weight: '500'
                                }
                            },
                            ticks: {
                                color: '#6c757d',
                                font: {
                                    size: 10
                                }
                            },
                            grid: {
                                color: '#e9ecef',
                                drawBorder: false
                            }
                        },
                        y: {
                            display: true,
                            title: {
                                display: true,
                                text: chartType === 'sale' ? `${getText('saleForecastYAxis')} (₺/${getText('unit_square_meters')})` : `${getText('rentForecastYAxis')} (₺/${getText('unit_square_meters')})`,
                                color: '#495057',
                                font: {
                                    size: 12,
                                    weight: '500'
                                }
                            },
                            ticks: {
                                color: '#6c757d',
                                font: {
                                    size: 10
                                },
                                callback: function(value) {
                                    if (chartType === 'sale') {
                                        return `₺${value.toLocaleString('ru-RU')}`;
                                    } else {
                                        return `₺${value}`;
                                    }
                                }
                            },
                            grid: {
                                color: '#e9ecef',
                                drawBorder: false
                            }
                        }
                    },
                    elements: {
                        line: {
                            tension: 0.4,
                            borderWidth: 3,
                            borderColor: chartType === 'sale' ? '#28a745' : '#ffc107'
                        },
                        point: {
                            radius: 4,
                            backgroundColor: chartType === 'sale' ? '#28a745' : '#ffc107',
                            borderColor: 'white',
                            borderWidth: 2,
                            hoverRadius: 6
                        }
                    },
                    interaction: {
                        mode: 'nearest',
                        axis: 'x',
                        intersect: false
                    }
                }
            });
        }
        
        // Подготовка данных для графика прогноза
        function prepareForecastChartData(forecastTrends, chartType) {
            const monthNames = {
                'ru': ['Янв', 'Фев', 'Мар', 'Апр', 'Май', 'Июн',
                       'Июл', 'Авг', 'Сен', 'Окт', 'Ноя', 'Дек'],
                'en': ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                       'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
                'de': ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun',
                       'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'],
                'fr': ['jan', 'fév', 'mar', 'avr', 'mai', 'juin',
                       'juil', 'août', 'sep', 'oct', 'nov', 'déc'],
                'tr': ['Oca', 'Şub', 'Mar', 'Nis', 'May', 'Haz',
                       'Tem', 'Ağu', 'Eyl', 'Eki', 'Kas', 'Ara']
            };
            const currentLang = currentLanguage || 'ru';
            const monthList = monthNames[currentLang] || monthNames['ru'];
            
            // Дополнительная фильтрация для обеспечения правильного порядка
            const sortedTrends = forecastTrends.sort((a, b) => {
                if (a.property_year !== b.property_year) {
                    return a.property_year - b.property_year;
                }
                return a.property_month - b.property_month;
            });
            
            const labels = sortedTrends.map(trend => {
                const monthName = monthList[trend.property_month - 1] || trend.property_month;
                return `${monthName} ${trend.property_year}`;
            });
            
            const data = sortedTrends.map(trend => {
                if (chartType === 'sale') {
                    // Используем рассчитанные цены если они есть, иначе исходные
                    return parseFloat(trend.is_price_calculated ? trend.calculated_sale_price : trend.unit_price_for_sale) || 0;
                } else {
                    // Используем рассчитанные цены если они есть, иначе исходные
                    return parseFloat(trend.is_price_calculated ? trend.calculated_rent_price : trend.unit_price_for_rent) || 0;
                }
            });
            
            console.log('📊 Forecast chart data prepared:', {
                chartType: chartType,
                dataPoints: data.length,
                dateRange: `${labels[0]} - ${labels[labels.length - 1]}`,
                sampleData: data.slice(0, 3)
            });
            
            return {
                labels: labels,
                datasets: [{
                    data: data,
                    fill: false,
                    pointBackgroundColor: chartType === 'sale' ? '#28a745' : '#ffc107',
                    pointBorderColor: 'white',
                    pointBorderWidth: 2,
                    pointRadius: 4,
                    pointHoverRadius: 6
                }]
            };
        }
        
        // Переключение типа графика прогноза
        function switchForecastChartType(chartType) {
            console.log('🔄 Switching forecast chart type to:', chartType);
            
            // Обновляем активную кнопку
            document.querySelectorAll('#forecastChartSection .chart-button').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`#forecastChartSection [data-chart-type="${chartType}"]`).classList.add('active');
            
            // Обновляем тип графика
            currentForecastChartType = chartType;
            
            // Пересоздаем график с новыми данными
            if (currentForecastData) {
                createForecastChart(currentForecastData, chartType);
            }
        }

        // Save and Share Report Functions
        async function saveAndShareReport() {
            const saveButton = document.getElementById('saveShareButton');
            const originalText = saveButton.innerHTML;
            
            try {
                // Disable button and show loading
                saveButton.disabled = true;
                saveButton.innerHTML = `<span>${getText('savingReport')}</span>`;
                
                // Get report content
                const reportContent = extractReportContent();
                
                // Get location info
                const locationInfo = getLocationInfo();
                
                // Get additional report data
                const reportData = getReportData();
                
                // Debug: log property info
                console.log('Property Info before sending:', propertyInfo);
                console.log('Number of photos:', propertyInfo.photos ? propertyInfo.photos.length : 0);
                
                // Get telegram_id 
                let telegramId = null;
                if (window.Telegram && window.Telegram.WebApp && window.Telegram.WebApp.initDataUnsafe) {
                    telegramId = window.Telegram.WebApp.initDataUnsafe.user?.id;
                }
                
                // Check additional options
                const includeRealtorInfo = document.getElementById('includeRealtorInfo')?.checked || false;
                const includePropertyInfo = document.getElementById('includePropertyInfo')?.checked || false;
                
                // Save report via API
                const response = await fetch('/api/save_html_report', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        telegram_id: telegramId,
                        report_content: reportContent,
                        location_info: locationInfo,
                        report_data: reportData,
                        include_realtor_info: includeRealtorInfo,
                        include_property_info: includePropertyInfo,
                        property_info: includePropertyInfo ? propertyInfo : null
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    // Show modal with link
                    showShareModal(result.report_url);
                } else {
                    throw new Error(result.error || 'Unknown error');
                }
                
            } catch (error) {
                console.error('Error saving report:', error);
                alert(getText('errorSaving'));
            } finally {
                // Re-enable button
                saveButton.disabled = false;
                saveButton.innerHTML = originalText;
            }
        }

        function extractReportContent() {
            // Get the main content section
            const dataContent = document.getElementById('dataContent');
            if (!dataContent) {
                return '<p>Отчет не найден</p>';
            }
            
            // Clone the content to avoid modifying the original
            const clonedContent = dataContent.cloneNode(true);
            
            // Сохраняем данные графиков перед удалением интерактивных элементов
            saveChartData(clonedContent);
            
            // Remove interactive elements
            removeInteractiveElements(clonedContent);
            
            return clonedContent.innerHTML;
        }

        function saveChartData(element) {
            // Находим все canvas элементы с графиками
            const canvasElements = element.querySelectorAll('canvas');
            
            canvasElements.forEach(canvas => {
                try {
                    const chartId = canvas.id;
                    const chart = Chart.getChart(canvas);
                    
                    if (chart) {
                        // Сохраняем полные данные графика
                        const chartData = {
                            type: chart.config.type,
                            data: chart.config.data,
                            options: chart.config.options
                        };
                        
                        canvas.setAttribute('data-chart-data', JSON.stringify(chartData));
                        canvas.setAttribute('data-chart-type', chart.config.type);
                        canvas.setAttribute('data-chart-id', chartId);
                        
                        console.log(`Chart data saved for ${chartId}:`, chartData);
                    } else {
                        // Если график не найден, сохраняем данные из глобальных переменных
                        const savedData = getChartDataFromGlobalVariables(chartId);
                        if (savedData) {
                            canvas.setAttribute('data-chart-data', JSON.stringify(savedData));
                            canvas.setAttribute('data-chart-type', 'line');
                            canvas.setAttribute('data-chart-id', chartId);
                            console.log(`Global data saved for ${chartId}:`, savedData);
                        }
                    }
                } catch (error) {
                    console.error('Error saving chart data:', error);
                    // Fallback: попробуем получить данные из глобальных переменных
                    try {
                        const chartId = canvas.id;
                        const savedData = getChartDataFromGlobalVariables(chartId);
                        if (savedData) {
                            canvas.setAttribute('data-chart-data', JSON.stringify(savedData));
                            canvas.setAttribute('data-chart-type', 'line');
                            canvas.setAttribute('data-chart-id', chartId);
                            console.log(`Fallback global data for ${chartId}:`, savedData);
                        }
                    } catch (fallbackError) {
                        console.error('Fallback error:', fallbackError);
                    }
                }
            });
        }

        function getChartDataFromGlobalVariables(chartId) {
            if (chartId === 'trendsChart' && window.currentTrendsData) {
                // Сохраняем данные для обоих типов графиков
                return {
                    sale: prepareChartDataForSave(window.currentTrendsData, 'sale'),
                    rent: prepareChartDataForSave(window.currentTrendsData, 'rent')
                };
            } else if (chartId === 'forecastChart' && currentForecastData) {
                // Сохраняем данные для обоих типов графиков
                return {
                    sale: prepareForecastChartDataForSave(currentForecastData, 'sale'),
                    rent: prepareForecastChartDataForSave(currentForecastData, 'rent')
                };
            }
            return null;
        }

        function prepareChartDataForSave(trends, chartType) {
            if (!trends || trends.length === 0) return null;
            
            const monthNames = {
                'ru': ['Янв', 'Фев', 'Мар', 'Апр', 'Май', 'Июн',
                       'Июл', 'Авг', 'Сен', 'Окт', 'Ноя', 'Дек'],
                'en': ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                       'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
                'de': ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun',
                       'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'],
                'fr': ['jan', 'fév', 'mar', 'avr', 'mai', 'juin',
                       'juil', 'août', 'sep', 'oct', 'nov', 'déc'],
                'tr': ['Oca', 'Şub', 'Mar', 'Nis', 'May', 'Haz',
                       'Tem', 'Ağu', 'Eyl', 'Eki', 'Kas', 'Ara']
            };
            const currentLang = currentLanguage || 'ru';
            const monthList = monthNames[currentLang] || monthNames['ru'];
            
            // Сортируем тренды по дате
            const sortedTrends = trends.sort((a, b) => {
                if (a.property_year !== b.property_year) {
                    return a.property_year - b.property_year;
                }
                return a.property_month - b.property_month;
            });
            
            // Фильтруем данные: до текущего месяца и один месяц вперед
            const today = new Date();
            const currentYear = today.getFullYear();
            const currentMonth = today.getMonth() + 1;
            
            const oneMonthAhead = new Date();
            oneMonthAhead.setMonth(today.getMonth() + 1);
            const oneMonthAheadYear = oneMonthAhead.getFullYear();
            const oneMonthAheadMonth = oneMonthAhead.getMonth() + 1;
            
            const filteredTrends = sortedTrends.filter(trend => {
                const trendDate = new Date(trend.property_year, trend.property_month - 1, 1);
                const filterEndDate = new Date(oneMonthAheadYear, oneMonthAheadMonth - 1, 1);
                return trendDate <= filterEndDate;
            });
            
            const labels = filteredTrends.map(trend => {
                const monthName = monthNames[trend.property_month - 1] || trend.property_month;
                return `${monthName} ${trend.property_year}`;
            });
            
            const data = filteredTrends.map(trend => {
                if (chartType === 'sale') {
                    return parseFloat(trend.is_price_calculated ? trend.calculated_sale_price : trend.unit_price_for_sale) || 0;
                } else {
                    return parseFloat(trend.is_price_calculated ? trend.calculated_rent_price : trend.unit_price_for_rent) || 0;
                }
            });
            
            return {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        data: data,
                        fill: false,
                        pointBackgroundColor: chartType === 'sale' ? '#28a745' : '#ffc107',
                        pointBorderColor: 'white',
                        pointBorderWidth: 2,
                        pointRadius: 4,
                        pointHoverRadius: 6,
                        borderColor: chartType === 'sale' ? '#28a745' : '#ffc107',
                        borderWidth: 3,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            titleColor: 'white',
                            bodyColor: 'white',
                            borderColor: '#667eea',
                            borderWidth: 1,
                            callbacks: {
                                label: function(context) {
                                    const value = context.parsed.y;
                                    if (chartType === 'sale') {
                                        return `${getText('salePriceTooltip')}: ₺${value.toLocaleString('ru-RU', { minimumFractionDigits: 2 })}/м²`;
                                    } else {
                                        return `${getText('rentPriceTooltip')}: ₺${value.toLocaleString('ru-RU', { minimumFractionDigits: 2 })}/м²`;
                                    }
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: true,
                                text: getText('monthAxisLabel'),
                                color: '#495057',
                                font: {
                                    size: 12,
                                    weight: '500'
                                }
                            },
                            ticks: {
                                color: '#6c757d',
                                font: {
                                    size: 10
                                }
                            },
                            grid: {
                                color: '#e9ecef',
                                drawBorder: false
                            }
                        },
                        y: {
                            display: true,
                            title: {
                                display: true,
                                text: chartType === 'sale' ? getText('salePriceAxisLabel') : getText('rentPriceAxisLabel'),
                                color: '#495057',
                                font: {
                                    size: 12,
                                    weight: '500'
                                }
                            },
                            ticks: {
                                color: '#6c757d',
                                font: {
                                    size: 10
                                },
                                callback: function(value) {
                                    if (chartType === 'sale') {
                                        return `₺${value.toLocaleString('ru-RU')}`;
                                    } else {
                                        return `₺${value}`;
                                    }
                                }
                            },
                            grid: {
                                color: '#e9ecef',
                                drawBorder: false
                            }
                        }
                    },
                    interaction: {
                        mode: 'nearest',
                        axis: 'x',
                        intersect: false
                    }
                }
            };
        }

        function prepareForecastChartDataForSave(forecastTrends, chartType) {
            if (!forecastTrends || forecastTrends.length === 0) return null;
            
            const monthNames = {
                'ru': ['Янв', 'Фев', 'Мар', 'Апр', 'Май', 'Июн',
                       'Июл', 'Авг', 'Сен', 'Окт', 'Ноя', 'Дек'],
                'en': ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                       'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
                'de': ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun',
                       'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'],
                'fr': ['jan', 'fév', 'mar', 'avr', 'mai', 'juin',
                       'juil', 'août', 'sep', 'oct', 'nov', 'déc'],
                'tr': ['Oca', 'Şub', 'Mar', 'Nis', 'May', 'Haz',
                       'Tem', 'Ağu', 'Eyl', 'Eki', 'Kas', 'Ara']
            };
            const currentLang = currentLanguage || 'ru';
            const monthList = monthNames[currentLang] || monthNames['ru'];
            
            // Сортируем тренды по дате
            const sortedTrends = forecastTrends.sort((a, b) => {
                if (a.property_year !== b.property_year) {
                    return a.property_year - b.property_year;
                }
                return a.property_month - b.property_month;
            });
            
            const labels = sortedTrends.map(trend => {
                const monthName = monthList[trend.property_month - 1] || trend.property_month;
                return `${monthName} ${trend.property_year}`;
            });
            
            const data = sortedTrends.map(trend => {
                if (chartType === 'sale') {
                    return parseFloat(trend.calculated_sale_price || trend.unit_price_for_sale) || 0;
                } else {
                    return parseFloat(trend.calculated_rent_price || trend.unit_price_for_rent) || 0;
                }
            });
            
            return {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        data: data,
                        fill: false,
                        pointBackgroundColor: chartType === 'sale' ? '#9b59b6' : '#f39c12',
                        pointBorderColor: 'white',
                        pointBorderWidth: 2,
                        pointRadius: 4,
                        pointHoverRadius: 6,
                        borderColor: chartType === 'sale' ? '#9b59b6' : '#f39c12',
                        borderWidth: 3,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            titleColor: 'white',
                            bodyColor: 'white',
                            borderColor: '#667eea',
                            borderWidth: 1,
                            callbacks: {
                                label: function(context) {
                                    const value = context.parsed.y;
                                    if (chartType === 'sale') {
                                        return `${getText('saleForecastTooltip')}: ₺${value.toLocaleString('ru-RU', { minimumFractionDigits: 2 })}/${getText('unit_square_meters')}`;
                                    } else {
                                        return `${getText('rentForecastTooltip')}: ₺${value.toLocaleString('ru-RU', { minimumFractionDigits: 2 })}/${getText('unit_square_meters')}`;
                                    }
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: true,
                                text: getText('monthAxisLabel'),
                                color: '#495057',
                                font: {
                                    size: 12,
                                    weight: '500'
                                }
                            },
                            ticks: {
                                color: '#6c757d',
                                font: {
                                    size: 10
                                }
                            },
                            grid: {
                                color: '#e9ecef',
                                drawBorder: false
                            }
                        },
                        y: {
                            display: true,
                            title: {
                                display: true,
                                text: chartType === 'sale' ? `${getText('saleForecastYAxis')} (₺/${getText('unit_square_meters')})` : `${getText('rentForecastYAxis')} (₺/${getText('unit_square_meters')})`,
                                color: '#495057',
                                font: {
                                    size: 12,
                                    weight: '500'
                                }
                            },
                            ticks: {
                                color: '#6c757d',
                                font: {
                                    size: 10
                                },
                                callback: function(value) {
                                    if (chartType === 'sale') {
                                        return `₺${value.toLocaleString('ru-RU')}`;
                                    } else {
                                        return `₺${value}`;
                                    }
                                }
                            },
                            grid: {
                                color: '#e9ecef',
                                drawBorder: false
                            }
                        }
                    },
                    interaction: {
                        mode: 'nearest',
                        axis: 'x',
                        intersect: false
                    }
                }
            };
        }

        function removeInteractiveElements(element) {
            // Remove buttons
            const buttons = element.querySelectorAll('button');
            buttons.forEach(button => button.remove());
            
            // Remove select elements
            const selects = element.querySelectorAll('select');
            selects.forEach(select => {
                const selectedText = select.options[select.selectedIndex]?.text || '';
                const span = document.createElement('span');
                span.textContent = selectedText;
                span.className = 'static-value';
                select.parentNode.replaceChild(span, select);
            });
            
            // Remove input elements and replace with their values
            const inputs = element.querySelectorAll('input');
            inputs.forEach(input => {
                const span = document.createElement('span');
                span.textContent = input.value || '';
                span.className = 'static-value';
                input.parentNode.replaceChild(span, input);
            });
            
            // Remove onclick attributes
            const clickableElements = element.querySelectorAll('[onclick]');
            clickableElements.forEach(el => el.removeAttribute('onclick'));
            
            // Remove event listeners by cloning elements
            const elementsWithEvents = element.querySelectorAll('[onchange], [onfocus], [onblur]');
            elementsWithEvents.forEach(el => {
                el.removeAttribute('onchange');
                el.removeAttribute('onfocus');
                el.removeAttribute('onblur');
            });
            
            // НЕ удаляем canvas элементы - они нужны для графиков
            // Вместо этого удаляем только элементы управления графиками
            const chartControls = element.querySelectorAll('.chart-controls, .chart-type-buttons');
            chartControls.forEach(control => control.remove());
        }

        function getLocationInfo() {
            const locationDetails = document.getElementById('locationDetails');
            return locationDetails ? locationDetails.textContent.trim() : 'Локация не указана';
        }

        function getReportData() {
            // Собираем данные о выбранных параметрах объекта
            const reportData = {
                parameters: {},
                bedrooms: null,
                floor: null,
                age: null,
                heating: null,
                price: null,
                area: null,
                latitude: null,
                longitude: null,
                price_range_min: null,
                price_range_max: null
            };
            
            // Получаем данные из выбранных параметров
            if (selectedListingTypes) {
                reportData.bedrooms = selectedListingTypes.house_type;  // Оставляем как есть - "2+1", "3+1" и т.д.
                reportData.floor = selectedListingTypes.floor_segment;
                reportData.age = selectedListingTypes.age;
                reportData.heating = selectedListingTypes.heating;
                reportData.parameters = { ...selectedListingTypes };
            }
            
            // Получаем цену и площадь из полей ввода
            const priceInput = document.getElementById('priceObjectInput');
            if (priceInput && priceInput.value) {
                reportData.price = parseFloat(priceInput.value);
            }
            
            const areaInput = document.getElementById('areaObjectInput');
            if (areaInput && areaInput.value) {
                reportData.area = parseFloat(areaInput.value);
            }
            
            // Получаем данные о локации
            if (selectedLocation) {
                reportData.latitude = selectedLocation.latitude;
                reportData.longitude = selectedLocation.longitude;
                reportData.country_name = selectedLocation.country_name;
                reportData.city_name = selectedLocation.city_name;
                reportData.county_name = selectedLocation.county_name;
                reportData.district_name = selectedLocation.district_name;
            }
            
            // Получаем данные о ценовом диапазоне из отчета (если есть)
            const marketData = window.currentSummaryData;
            if (marketData && marketData.market_indicators) {
                const saleData = marketData.market_indicators.find(item => item.category === 'sale');
                if (saleData) {
                    const priceRange = saleData.price_range;
                    if (priceRange) {
                        reportData.price_range_min = parseFloat(priceRange.min);
                        reportData.price_range_max = parseFloat(priceRange.max);
                    }
                }
            }
            
            return reportData;
        }

        function showShareModal(reportUrl) {
            const modal = document.getElementById('shareModal');
            const modalLink = document.getElementById('modalLink');
            
            modalLink.href = reportUrl;
            modalLink.textContent = reportUrl;
            
            modal.style.display = 'flex';
            
            // Store the URL for copying
            window.currentReportUrl = reportUrl;
        }

        function closeShareModal() {
            const modal = document.getElementById('shareModal');
            modal.style.display = 'none';
        }

        async function copyReportLink() {
            const copyButton = document.querySelector('#shareModal .modal-button-primary');
            const originalText = copyButton.innerHTML;
            
            try {
                if (navigator.clipboard) {
                    await navigator.clipboard.writeText(window.currentReportUrl);
                } else {
                    // Fallback for older browsers
                    const textArea = document.createElement('textarea');
                    textArea.value = window.currentReportUrl;
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                }
                
                copyButton.innerHTML = `<span>${getText('linkCopied')}</span>`;
                
                setTimeout(() => {
                    copyButton.innerHTML = originalText;
                }, 2000);
                
            } catch (error) {
                console.error('Error copying link:', error);
                alert('Не удалось скопировать ссылку');
            }
        }

        // Show save button when report is loaded
        async function showSaveButton() {
            const saveButton = document.getElementById('saveShareButton');
            const reportOptions = document.getElementById('reportOptions');
            
            // Проверяем доступ пользователя к премиум функциям
            const userAccess = await checkUserAccess();
            console.log('🔍 User access check for report options:', userAccess);
            
            if (saveButton) {
                saveButton.style.display = 'block';
            }
            
            // Показываем опции отчета только для пользователей с активной подпиской или админов
            if (reportOptions) {
                if (userAccess.hasAccess) {
                    reportOptions.style.display = 'block';
                } else {
                    reportOptions.style.display = 'none';
                    console.log('⚠️ Report options hidden - user subscription expired');
                }
            }
        }

        // Property Info Modal Functions
        function openPropertyInfoModal() {
            const modal = document.getElementById('propertyInfoModal');
            modal.style.display = 'flex';
        }

        function closePropertyInfoModal() {
            const modal = document.getElementById('propertyInfoModal');
            modal.style.display = 'none';
        }

        function savePropertyInfo() {
            const urlInput = document.getElementById('propertyUrl');
            propertyInfo.url = urlInput.value;
            
            console.log('Saving property info:', {
                url: propertyInfo.url,
                photosCount: propertyInfo.photos.length
            });
            
            closePropertyInfoModal();
            
            // CHECK the checkbox since we've saved the data
            const checkbox = document.getElementById('includePropertyInfo');
            if (checkbox) {
                checkbox.checked = true; // Устанавливаем галочку после сохранения
            }
        }

        // Photo upload handling
        function initPhotoUpload() {
            const photoInput = document.getElementById('photoInput');
            const uploadArea = document.getElementById('photoUploadArea');
            const previewContainer = document.getElementById('photoPreviewContainer');

            photoInput.addEventListener('change', handlePhotoSelect);
            
            // Drag and drop functionality
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.classList.add('dragover');
            });
            
            uploadArea.addEventListener('dragleave', () => {
                uploadArea.classList.remove('dragover');
            });
            
            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.classList.remove('dragover');
                const files = e.dataTransfer.files;
                handlePhotoFiles(files);
            });
            
            uploadArea.addEventListener('click', () => {
                photoInput.click();
            });
        }

        function handlePhotoSelect(event) {
            const files = event.target.files;
            handlePhotoFiles(files);
        }

        function handlePhotoFiles(files) {
            Array.from(files).forEach(file => {
                if (file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        propertyInfo.photos.push({
                            name: file.name,
                            data: e.target.result
                        });
                        console.log(`Added photo: ${file.name}, total photos: ${propertyInfo.photos.length}`);
                        updatePhotoPreview();
                    };
                    reader.readAsDataURL(file);
                }
            });
        }

        function updatePhotoPreview() {
            const previewContainer = document.getElementById('photoPreviewContainer');
            previewContainer.innerHTML = '';
            
            propertyInfo.photos.forEach((photo, index) => {
                const preview = document.createElement('div');
                preview.className = 'photo-preview';
                preview.innerHTML = `
                    <img src="${photo.data}" alt="${photo.name}">
                    <button class="photo-preview-remove" onclick="removePhoto(${index})">×</button>
                `;
                previewContainer.appendChild(preview);
            });
        }

        function removePhoto(index) {
            propertyInfo.photos.splice(index, 1);
            updatePhotoPreview();
        }

        // Handle checkbox changes
        function setupCheckboxHandlers() {
            const realtorCheckbox = document.getElementById('includeRealtorInfo');
            const propertyCheckbox = document.getElementById('includePropertyInfo');
            
            if (propertyCheckbox) {
                propertyCheckbox.addEventListener('change', function() {
                    if (this.checked) {
                        openPropertyInfoModal();
                    }
                });
            }
        }



        // Close modals when clicking outside
        document.addEventListener('click', function(event) {
            const shareModal = document.getElementById('shareModal');
            const propertyModal = document.getElementById('propertyInfoModal');
            
            if (event.target === shareModal) {
                closeShareModal();
            }
            if (event.target === propertyModal) {
                closePropertyInfoModal();
            }
        });

        // Close modals with Escape key
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                closeShareModal();
                closePropertyInfoModal();
            }
        });
    </script>
</body>
</html>
